# BUG: Vec Element Field Access Corruption

**Status:** ✅ ALL FIXED
**Last Updated:** 2025-01-27

---

## EXECUTIVE SUMMARY

There were **TWO DISTINCT BUGS** causing Vec element field access corruption. Both are now fixed.

| Bug | Status | Root Cause | Fix |
|-----|--------|------------|-----|
| Bug 1: LLVM Instruction Combining | ✅ FIXED | `instruction_combining_pass` misoptimizes GEP | Excluded from optimization |
| Bug 2: LLVM Memcpy Optimization | ✅ FIXED | `memcpy_optimize_pass` uses wrong struct size | Excluded from optimization |

---

## Bug 1: LLVM Instruction Combining (FIXED)

### Symptom
- First Vec element `span.start` access correct
- Second Vec element `span.start` access returns wrong value (e.g., `span.end` instead of `span.start`)
- Only manifests WITH optimization enabled

### Root Cause
LLVM's `instruction_combining_pass` incorrectly combines GEP (GetElementPtr) operations when accessing nested struct fields through Vec elements. The optimizer uses wrong field indices (e.g., `i32 1` instead of `i32 0`).

### Fix Applied
Excluded `instruction_combining_pass` from `optimize_module_safe()` in `bloodc/src/codegen/mod.rs`.

---

## Bug 2: LLVM Memcpy Optimization (FIXED)

### Symptom
- Fields that come AFTER a nested struct in a parent struct return 0 or garbage
- `d0.body_id` returns 0 (expected 111)
- `d1.body_id` returns garbage (expected 222)
- Only manifests WITH optimization enabled

### Root Cause
LLVM's `memcpy_optimize_pass` converts struct load/store operations into `llvm.memcpy` intrinsic calls. When a struct contains nested structs, the pass incorrectly uses the size of the **inner struct** instead of the **total struct size**.

In the LLVM IR:
```llvm
; WRONG: copies only 32 bytes (size of SpannedSymbol), missing body_id
call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 %3, i64 32, i1 false)
; SHOULD BE: 40 bytes (full Decl struct with body_id)
```

### Fix Applied
Excluded `memcpy_optimize_pass` from `optimize_module_safe()` in `bloodc/src/codegen/mod.rs`.

---

## Final Verification

All fields now return correct values:
```
Testing Vec element field access:

Testing span.start:
  d0.name.span.start = 100 ✓
  d1.name.span.start = 300 ✓

Testing body_id:
  d0.body_id = 111 ✓
  d1.body_id = 222 ✓

Testing symbol.index:
  d0.name.symbol.index = 11 ✓
  d1.name.symbol.index = 22 ✓

Testing span.line:
  d0.name.span.line = 1 ✓
  d1.name.span.line = 2 ✓
```

All tests pass (169 at time of fix; 1,779 as of 2026-01-29).

---

## Optimization Passes Excluded

The following LLVM optimization passes are excluded from `optimize_module_safe()` due to miscompilation bugs:

1. **`instruction_combining_pass`** - Incorrectly combines GEP operations, causing wrong field indices
2. **`GVN` (Global Value Numbering)** - Similar issues with value numbering
3. **`memcpy_optimize_pass`** - Uses wrong size when copying structs with nested structs

These passes are known to have issues with the code patterns generated by the Blood compiler. The remaining optimization passes provide sufficient optimization without these bugs.

---

## Historical Context

### Original 16-byte Alignment Bug (BUG-003)
Previously fixed in commit `a09f689`. This was about odd Vec indices for 16-byte aligned types (like i128) returning corrupted discriminants. Fixed by properly casting the Vec data pointer before GEP and using explicit byte offset calculation.

This document now covers all Vec-related corruption bugs that have been identified and fixed.
