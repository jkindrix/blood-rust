// Blood Standard Library - VecDeque
//
// A double-ended queue implemented with a growable ring buffer.

use crate::mem;
use crate::ptr;

/// A double-ended queue implemented as a ring buffer
///
/// VecDeque provides O(1) push/pop at both ends.
pub struct VecDeque<T> {
    buffer: Vec<Option<T>>,
    head: usize,  // Index of front element
    len: usize,
}

impl<T> VecDeque<T> {
    /// Creates an empty VecDeque
    pub fn new() -> Self / pure {
        VecDeque::with_capacity(0)
    }

    /// Creates an empty VecDeque with the specified capacity
    pub fn with_capacity(capacity: usize) -> Self / pure {
        let capacity = if capacity == 0 { 0 } else { capacity.next_power_of_two() };
        let mut buffer = Vec::with_capacity(capacity);
        for _ in 0..capacity {
            buffer.push(None);
        }
        VecDeque {
            buffer,
            head: 0,
            len: 0,
        }
    }

    /// Returns the number of elements
    pub fn len(self: &Self) -> usize / pure {
        self.len
    }

    /// Returns true if the deque is empty
    pub fn is_empty(self: &Self) -> bool / pure {
        self.len == 0
    }

    /// Returns the capacity
    pub fn capacity(self: &Self) -> usize / pure {
        self.buffer.len()
    }

    /// Clears the deque
    pub fn clear(self: &mut Self) / pure {
        while self.pop_front().is_some() {}
    }

    /// Returns a reference to the front element
    pub fn front(self: &Self) -> Option<&T> / pure {
        if self.is_empty() {
            None
        } else {
            self.buffer[self.head].as_ref()
        }
    }

    /// Returns a mutable reference to the front element
    pub fn front_mut(self: &mut Self) -> Option<&mut T> / pure {
        if self.is_empty() {
            None
        } else {
            self.buffer[self.head].as_mut()
        }
    }

    /// Returns a reference to the back element
    pub fn back(self: &Self) -> Option<&T> / pure {
        if self.is_empty() {
            None
        } else {
            let idx = self.wrap_index(self.head + self.len - 1);
            self.buffer[idx].as_ref()
        }
    }

    /// Returns a mutable reference to the back element
    pub fn back_mut(self: &mut Self) -> Option<&mut T> / pure {
        if self.is_empty() {
            None
        } else {
            let idx = self.wrap_index(self.head + self.len - 1);
            self.buffer[idx].as_mut()
        }
    }

    /// Returns a reference to an element by index
    pub fn get(self: &Self, index: usize) -> Option<&T> / pure {
        if index >= self.len {
            None
        } else {
            let idx = self.wrap_index(self.head + index);
            self.buffer[idx].as_ref()
        }
    }

    /// Returns a mutable reference to an element by index
    pub fn get_mut(self: &mut Self, index: usize) -> Option<&mut T> / pure {
        if index >= self.len {
            None
        } else {
            let idx = self.wrap_index(self.head + index);
            self.buffer[idx].as_mut()
        }
    }

    /// Adds an element to the front
    pub fn push_front(self: &mut Self, value: T) / pure {
        if self.len == self.capacity() {
            self.grow();
        }

        self.head = self.wrap_sub(self.head, 1);
        self.buffer[self.head] = Some(value);
        self.len += 1;
    }

    /// Adds an element to the back
    pub fn push_back(self: &mut Self, value: T) / pure {
        if self.len == self.capacity() {
            self.grow();
        }

        let idx = self.wrap_index(self.head + self.len);
        self.buffer[idx] = Some(value);
        self.len += 1;
    }

    /// Removes and returns the front element
    pub fn pop_front(self: &mut Self) -> Option<T> / pure {
        if self.is_empty() {
            None
        } else {
            let value = self.buffer[self.head].take();
            self.head = self.wrap_add(self.head, 1);
            self.len -= 1;
            value
        }
    }

    /// Removes and returns the back element
    pub fn pop_back(self: &mut Self) -> Option<T> / pure {
        if self.is_empty() {
            None
        } else {
            self.len -= 1;
            let idx = self.wrap_index(self.head + self.len);
            self.buffer[idx].take()
        }
    }

    /// Inserts an element at index
    pub fn insert(self: &mut Self, index: usize, value: T) / pure {
        assert!(index <= self.len, "insertion index out of bounds");

        if self.len == self.capacity() {
            self.grow();
        }

        // Decide whether to shift front or back
        let distance_to_back = self.len - index;

        if index < distance_to_back {
            // Shift front elements left
            self.head = self.wrap_sub(self.head, 1);
            for i in 0..index {
                let src = self.wrap_index(self.head + i + 1);
                let dst = self.wrap_index(self.head + i);
                self.buffer.swap(src, dst);
            }
            let idx = self.wrap_index(self.head + index);
            self.buffer[idx] = Some(value);
        } else {
            // Shift back elements right
            for i in (index..self.len).rev() {
                let src = self.wrap_index(self.head + i);
                let dst = self.wrap_index(self.head + i + 1);
                self.buffer.swap(src, dst);
            }
            let idx = self.wrap_index(self.head + index);
            self.buffer[idx] = Some(value);
        }

        self.len += 1;
    }

    /// Removes and returns the element at index
    pub fn remove(self: &mut Self, index: usize) -> Option<T> / pure {
        if index >= self.len {
            return None;
        }

        let value = {
            let idx = self.wrap_index(self.head + index);
            self.buffer[idx].take()
        };

        let distance_to_back = self.len - index - 1;

        if index < distance_to_back {
            // Shift front elements right
            for i in (0..index).rev() {
                let src = self.wrap_index(self.head + i);
                let dst = self.wrap_index(self.head + i + 1);
                self.buffer.swap(src, dst);
            }
            self.head = self.wrap_add(self.head, 1);
        } else {
            // Shift back elements left
            for i in index..self.len - 1 {
                let src = self.wrap_index(self.head + i + 1);
                let dst = self.wrap_index(self.head + i);
                self.buffer.swap(src, dst);
            }
        }

        self.len -= 1;
        value
    }

    /// Swaps elements at two indices
    pub fn swap(self: &mut Self, i: usize, j: usize) / pure {
        assert!(i < self.len && j < self.len, "indices out of bounds");
        let idx_i = self.wrap_index(self.head + i);
        let idx_j = self.wrap_index(self.head + j);
        self.buffer.swap(idx_i, idx_j);
    }

    /// Returns true if the deque contains the value
    pub fn contains(self: &Self, value: &T) -> bool / pure
    where
        T: PartialEq,
    {
        self.iter().any(|x| x == value)
    }

    /// Reserves capacity for at least `additional` more elements
    pub fn reserve(self: &mut Self, additional: usize) / pure {
        let required = self.len.saturating_add(additional);
        if required > self.capacity() {
            self.grow_to(required.next_power_of_two());
        }
    }

    /// Shrinks the capacity as close as possible to the length
    pub fn shrink_to_fit(self: &mut Self) / pure {
        if self.len < self.capacity() / 4 && self.capacity() > 8 {
            let new_cap = (self.len * 2).max(8).next_power_of_two();
            self.shrink_to(new_cap);
        }
    }

    /// Converts into a Vec
    pub fn into_vec(self: Self) -> Vec<T> / pure {
        self.into_iter().collect()
    }

    /// Creates an iterator over references
    pub fn iter(self: &Self) -> Iter<'_, T> / pure {
        Iter {
            deque: self,
            front: 0,
            back: self.len,
        }
    }

    /// Creates an iterator over mutable references
    pub fn iter_mut(self: &mut Self) -> IterMut<'_, T> / pure {
        let len = self.len;
        IterMut {
            deque: self,
            front: 0,
            back: len,
        }
    }

    /// Returns the two slices that make up the deque
    pub fn as_slices(self: &Self) -> (&[Option<T>], &[Option<T>]) / pure {
        if self.is_empty() {
            return (&[], &[]);
        }

        let tail = self.wrap_index(self.head + self.len);

        if self.head < tail {
            (&self.buffer[self.head..tail], &[])
        } else {
            (&self.buffer[self.head..], &self.buffer[..tail])
        }
    }

    /// Returns the two mutable slices that make up the deque
    pub fn as_mut_slices(self: &mut Self) -> (&mut [Option<T>], &mut [Option<T>]) / pure {
        if self.is_empty() {
            return (&mut [], &mut []);
        }

        let tail = self.wrap_index(self.head + self.len);
        let cap = self.capacity();

        if self.head < tail {
            let (_, right) = self.buffer.split_at_mut(self.head);
            let (slice, _) = right.split_at_mut(tail - self.head);
            (slice, &mut [])
        } else {
            let (left, right) = self.buffer.split_at_mut(self.head);
            (&mut right[..], &mut left[..tail])
        }
    }

    /// Rotates the deque left by n positions
    pub fn rotate_left(self: &mut Self, n: usize) / pure {
        if self.len <= 1 || n == 0 {
            return;
        }
        let n = n % self.len;
        self.head = self.wrap_add(self.head, n);
    }

    /// Rotates the deque right by n positions
    pub fn rotate_right(self: &mut Self, n: usize) / pure {
        if self.len <= 1 || n == 0 {
            return;
        }
        let n = n % self.len;
        self.head = self.wrap_sub(self.head, n);
    }

    /// Makes the deque contiguous
    pub fn make_contiguous(self: &mut Self) -> &mut [Option<T>] / pure {
        if self.is_empty() {
            return &mut [];
        }

        let tail = self.wrap_index(self.head + self.len);

        if self.head >= tail && self.len > 0 {
            // Buffer wraps around, need to rotate
            self.buffer.rotate_left(self.head);
            self.head = 0;
        }

        &mut self.buffer[self.head..self.head + self.len]
    }

    // Private helper methods

    fn wrap_index(self: &Self, index: usize) -> usize / pure {
        if self.capacity() == 0 {
            0
        } else {
            index & (self.capacity() - 1)
        }
    }

    fn wrap_add(self: &Self, index: usize, amount: usize) -> usize / pure {
        self.wrap_index(index.wrapping_add(amount))
    }

    fn wrap_sub(self: &Self, index: usize, amount: usize) -> usize / pure {
        self.wrap_index(index.wrapping_sub(amount).wrapping_add(self.capacity()))
    }

    fn grow(self: &mut Self) / pure {
        let new_cap = if self.capacity() == 0 { 4 } else { self.capacity() * 2 };
        self.grow_to(new_cap);
    }

    fn grow_to(self: &mut Self, new_cap: usize) / pure {
        assert!(new_cap >= self.len, "new capacity must be >= len");

        let mut new_buffer = Vec::with_capacity(new_cap);
        for _ in 0..new_cap {
            new_buffer.push(None);
        }

        // Copy elements to new buffer at position 0
        for i in 0..self.len {
            let old_idx = self.wrap_index(self.head + i);
            new_buffer[i] = self.buffer[old_idx].take();
        }

        self.buffer = new_buffer;
        self.head = 0;
    }

    fn shrink_to(self: &mut Self, new_cap: usize) / pure {
        assert!(new_cap >= self.len, "new capacity must be >= len");

        // Make contiguous first
        self.make_contiguous();

        let mut new_buffer = Vec::with_capacity(new_cap);
        for i in 0..new_cap {
            if i < self.len {
                new_buffer.push(self.buffer[i].take());
            } else {
                new_buffer.push(None);
            }
        }

        self.buffer = new_buffer;
        self.head = 0;
    }
}

impl<T> Default for VecDeque<T> {
    fn default() -> Self / pure {
        VecDeque::new()
    }
}

impl<T: Clone> Clone for VecDeque<T> {
    fn clone(self: &Self) -> Self / pure {
        let mut new_deque = VecDeque::with_capacity(self.len);
        for item in self.iter() {
            new_deque.push_back(item.clone());
        }
        new_deque
    }
}

impl<T: PartialEq> PartialEq for VecDeque<T> {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        if self.len != other.len {
            return false;
        }
        self.iter().zip(other.iter()).all(|(a, b)| a == b)
    }
}

impl<T: Eq> Eq for VecDeque<T> {}

impl<T: Hash> Hash for VecDeque<T> {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_length_prefix(self.len);
        for item in self.iter() {
            item.hash(state);
        }
    }
}

impl<T: Debug> Debug for VecDeque<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.debug_list().entries(self.iter()).finish()
    }
}

impl<T> Index<usize> for VecDeque<T> {
    type Output = T;

    fn index(self: &Self, index: usize) -> &T / pure {
        self.get(index).expect("index out of bounds")
    }
}

impl<T> IndexMut<usize> for VecDeque<T> {
    fn index_mut(self: &mut Self, index: usize) -> &mut T / pure {
        self.get_mut(index).expect("index out of bounds")
    }
}

impl<T> FromIterator<T> for VecDeque<T> {
    fn from_iter<I: Iterator<Item = T>>(iter: I) -> Self / pure {
        let mut deque = VecDeque::new();
        for item in iter {
            deque.push_back(item);
        }
        deque
    }
}

impl<T> Extend<T> for VecDeque<T> {
    fn extend<I: Iterator<Item = T>>(self: &mut Self, iter: I) / pure {
        for item in iter {
            self.push_back(item);
        }
    }
}

impl<T> IntoIterator for VecDeque<T> {
    type Item = T;
    type IntoIter = IntoIter<T>;

    fn into_iter(self: Self) -> IntoIter<T> / pure {
        IntoIter { deque: self }
    }
}

impl<'a, T> IntoIterator for &'a VecDeque<T> {
    type Item = &'a T;
    type IntoIter = Iter<'a, T>;

    fn into_iter(self: Self) -> Iter<'a, T> / pure {
        self.iter()
    }
}

impl<'a, T> IntoIterator for &'a mut VecDeque<T> {
    type Item = &'a mut T;
    type IntoIter = IterMut<'a, T>;

    fn into_iter(self: Self) -> IterMut<'a, T> / pure {
        self.iter_mut()
    }
}

// Iterators

/// Iterator over references
pub struct Iter<'a, T> {
    deque: &'a VecDeque<T>,
    front: usize,
    back: usize,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        if self.front >= self.back {
            None
        } else {
            let item = self.deque.get(self.front);
            self.front += 1;
            item
        }
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let len = self.back - self.front;
        (len, Some(len))
    }
}

impl<'a, T> DoubleEndedIterator for Iter<'a, T> {
    fn next_back(self: &mut Self) -> Option<&'a T> / pure {
        if self.front >= self.back {
            None
        } else {
            self.back -= 1;
            self.deque.get(self.back)
        }
    }
}

impl<'a, T> ExactSizeIterator for Iter<'a, T> {}

/// Iterator over mutable references
pub struct IterMut<'a, T> {
    deque: &'a mut VecDeque<T>,
    front: usize,
    back: usize,
}

impl<'a, T> Iterator for IterMut<'a, T> {
    type Item = &'a mut T;

    fn next(self: &mut Self) -> Option<&'a mut T> / pure {
        if self.front >= self.back {
            None
        } else {
            let idx = self.deque.wrap_index(self.deque.head + self.front);
            self.front += 1;
            // Safety: We're iterating without overlap
            unsafe {
                let ptr = self.deque.buffer.as_mut_ptr().add(idx);
                (*ptr).as_mut()
            }
        }
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let len = self.back - self.front;
        (len, Some(len))
    }
}

impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {
    fn next_back(self: &mut Self) -> Option<&'a mut T> / pure {
        if self.front >= self.back {
            None
        } else {
            self.back -= 1;
            let idx = self.deque.wrap_index(self.deque.head + self.back);
            unsafe {
                let ptr = self.deque.buffer.as_mut_ptr().add(idx);
                (*ptr).as_mut()
            }
        }
    }
}

impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}

/// Owning iterator
pub struct IntoIter<T> {
    deque: VecDeque<T>,
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.deque.pop_front()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (self.deque.len, Some(self.deque.len))
    }
}

impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(self: &mut Self) -> Option<T> / pure {
        self.deque.pop_back()
    }
}

impl<T> ExactSizeIterator for IntoIter<T> {}
