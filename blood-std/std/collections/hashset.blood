// Blood Standard Library - HashSet
//
// A hash set implemented as a wrapper around HashMap.

use crate::hash::{Hash, BuildHasher, RandomState};
use super::hashmap::{HashMap, self};

/// A hash set implementation
///
/// HashSet provides O(1) average-case lookup, insertion, and removal.
/// It is implemented as a thin wrapper around HashMap<T, ()>.
pub struct HashSet<T, S = RandomState> {
    map: HashMap<T, (), S>,
}

impl<T> HashSet<T, RandomState>
where
    T: Hash + Eq,
{
    /// Creates an empty HashSet
    pub fn new() -> Self / pure {
        HashSet::with_hasher(RandomState::default())
    }

    /// Creates an empty HashSet with the specified capacity
    pub fn with_capacity(capacity: usize) -> Self / pure {
        HashSet::with_capacity_and_hasher(capacity, RandomState::default())
    }
}

impl<T, S> HashSet<T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    /// Creates an empty HashSet with a custom hasher
    pub fn with_hasher(hash_builder: S) -> Self / pure {
        HashSet {
            map: HashMap::with_hasher(hash_builder),
        }
    }

    /// Creates an empty HashSet with capacity and custom hasher
    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> Self / pure {
        HashSet {
            map: HashMap::with_capacity_and_hasher(capacity, hash_builder),
        }
    }

    /// Returns the number of elements
    pub fn len(self: &Self) -> usize / pure {
        self.map.len()
    }

    /// Returns true if the set is empty
    pub fn is_empty(self: &Self) -> bool / pure {
        self.map.is_empty()
    }

    /// Returns the capacity
    pub fn capacity(self: &Self) -> usize / pure {
        self.map.capacity()
    }

    /// Clears the set
    pub fn clear(self: &mut Self) / pure {
        self.map.clear()
    }

    /// Returns a reference to the hasher
    pub fn hasher(self: &Self) -> &S / pure {
        self.map.hasher()
    }

    /// Reserves capacity for at least `additional` more elements
    pub fn reserve(self: &mut Self, additional: usize) / pure {
        self.map.reserve(additional)
    }

    /// Shrinks the capacity of the set as much as possible
    pub fn shrink_to_fit(self: &mut Self) / pure {
        self.map.shrink_to_fit()
    }

    /// Shrinks the capacity of the set with a lower limit
    pub fn shrink_to(self: &mut Self, min_capacity: usize) / pure {
        self.map.shrink_to(min_capacity)
    }

    /// Inserts a value into the set
    ///
    /// Returns true if the value was newly inserted, false if it already existed.
    pub fn insert(self: &mut Self, value: T) -> bool / pure {
        self.map.insert(value, ()).is_none()
    }

    /// Removes a value from the set
    ///
    /// Returns true if the value was present.
    pub fn remove(self: &mut Self, value: &T) -> bool / pure {
        self.map.remove(value).is_some()
    }

    /// Removes and returns a value from the set
    pub fn take(self: &mut Self, value: &T) -> Option<T> / pure {
        self.map.remove_entry(value).map(|(k, _)| k)
    }

    /// Returns true if the set contains the given value
    pub fn contains(self: &Self, value: &T) -> bool / pure {
        self.map.contains_key(value)
    }

    /// Returns a reference to the value if it exists
    pub fn get(self: &Self, value: &T) -> Option<&T> / pure {
        self.map.get_key_value(value).map(|(k, _)| k)
    }

    /// Returns an iterator over the values
    pub fn iter(self: &Self) -> Iter<'_, T> / pure {
        Iter {
            inner: self.map.keys(),
        }
    }

    /// Returns true if self has no elements in common with other
    pub fn is_disjoint(self: &Self, other: &HashSet<T, S>) -> bool / pure {
        if self.len() <= other.len() {
            self.iter().all(|v| !other.contains(v))
        } else {
            other.iter().all(|v| !self.contains(v))
        }
    }

    /// Returns true if self is a subset of other
    pub fn is_subset(self: &Self, other: &HashSet<T, S>) -> bool / pure {
        if self.len() > other.len() {
            return false;
        }
        self.iter().all(|v| other.contains(v))
    }

    /// Returns true if self is a superset of other
    pub fn is_superset(self: &Self, other: &HashSet<T, S>) -> bool / pure {
        other.is_subset(self)
    }

    /// Returns an iterator over values in self but not in other
    pub fn difference<'a>(self: &'a Self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> / pure {
        Difference {
            iter: self.iter(),
            other,
        }
    }

    /// Returns an iterator over values in either self or other but not both
    pub fn symmetric_difference<'a>(
        self: &'a Self,
        other: &'a HashSet<T, S>,
    ) -> SymmetricDifference<'a, T, S> / pure {
        SymmetricDifference {
            iter: self.difference(other).chain(other.difference(self)),
        }
    }

    /// Returns an iterator over values in both self and other
    pub fn intersection<'a>(self: &'a Self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> / pure {
        if self.len() <= other.len() {
            Intersection {
                iter: self.iter(),
                other,
            }
        } else {
            Intersection {
                iter: other.iter(),
                other: self,
            }
        }
    }

    /// Returns an iterator over values in either self or other
    pub fn union<'a>(self: &'a Self, other: &'a HashSet<T, S>) -> Union<'a, T, S> / pure {
        if self.len() >= other.len() {
            Union {
                iter: self.iter().chain(other.difference(self)),
            }
        } else {
            Union {
                iter: other.iter().chain(self.difference(other)),
            }
        }
    }

    /// Retains only elements that satisfy the predicate
    pub fn retain<F: FnMut(&T) -> bool>(self: &mut Self, f: F) / pure {
        self.map.retain(|k, _| f(k))
    }

    /// Drains the set, returning all elements
    pub fn drain(self: &mut Self) -> Drain<'_, T> / pure {
        Drain {
            inner: self.map.drain(),
        }
    }
}

impl<T, S> Default for HashSet<T, S>
where
    T: Hash + Eq,
    S: BuildHasher + Default,
{
    fn default() -> Self / pure {
        HashSet::with_hasher(S::default())
    }
}

impl<T, S> Clone for HashSet<T, S>
where
    T: Hash + Eq + Clone,
    S: BuildHasher + Clone,
{
    fn clone(self: &Self) -> Self / pure {
        HashSet {
            map: self.map.clone(),
        }
    }
}

impl<T, S> PartialEq for HashSet<T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    fn eq(self: &Self, other: &Self) -> bool / pure {
        if self.len() != other.len() {
            return false;
        }
        self.iter().all(|v| other.contains(v))
    }
}

impl<T, S> Eq for HashSet<T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{}

impl<T, S> Debug for HashSet<T, S>
where
    T: Debug,
{
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.debug_set().entries(self.iter()).finish()
    }
}

impl<T, S> FromIterator<T> for HashSet<T, S>
where
    T: Hash + Eq,
    S: BuildHasher + Default,
{
    fn from_iter<I: Iterator<Item = T>>(iter: I) -> Self / pure {
        let mut set = HashSet::default();
        for item in iter {
            set.insert(item);
        }
        set
    }
}

impl<T, S> Extend<T> for HashSet<T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    fn extend<I: Iterator<Item = T>>(self: &mut Self, iter: I) / pure {
        for item in iter {
            self.insert(item);
        }
    }
}

impl<'a, T, S> IntoIterator for &'a HashSet<T, S>
where
    T: Hash + Eq,
{
    type Item = &'a T;
    type IntoIter = Iter<'a, T>;

    fn into_iter(self: Self) -> Iter<'a, T> / pure {
        self.iter()
    }
}

impl<T, S> IntoIterator for HashSet<T, S>
where
    T: Hash + Eq,
{
    type Item = T;
    type IntoIter = IntoIter<T>;

    fn into_iter(self: Self) -> IntoIter<T> / pure {
        IntoIter {
            inner: self.map.into_iter(),
        }
    }
}

// Set operations that return new sets

impl<T, S> BitOr<&HashSet<T, S>> for &HashSet<T, S>
where
    T: Hash + Eq + Clone,
    S: BuildHasher + Default + Clone,
{
    type Output = HashSet<T, S>;

    /// Returns the union of two sets
    fn bitor(self: Self, other: &HashSet<T, S>) -> HashSet<T, S> / pure {
        self.union(other).cloned().collect()
    }
}

impl<T, S> BitAnd<&HashSet<T, S>> for &HashSet<T, S>
where
    T: Hash + Eq + Clone,
    S: BuildHasher + Default + Clone,
{
    type Output = HashSet<T, S>;

    /// Returns the intersection of two sets
    fn bitand(self: Self, other: &HashSet<T, S>) -> HashSet<T, S> / pure {
        self.intersection(other).cloned().collect()
    }
}

impl<T, S> BitXor<&HashSet<T, S>> for &HashSet<T, S>
where
    T: Hash + Eq + Clone,
    S: BuildHasher + Default + Clone,
{
    type Output = HashSet<T, S>;

    /// Returns the symmetric difference of two sets
    fn bitxor(self: Self, other: &HashSet<T, S>) -> HashSet<T, S> / pure {
        self.symmetric_difference(other).cloned().collect()
    }
}

impl<T, S> Sub<&HashSet<T, S>> for &HashSet<T, S>
where
    T: Hash + Eq + Clone,
    S: BuildHasher + Default + Clone,
{
    type Output = HashSet<T, S>;

    /// Returns the difference of two sets
    fn sub(self: Self, other: &HashSet<T, S>) -> HashSet<T, S> / pure {
        self.difference(other).cloned().collect()
    }
}

// Iterators

/// Iterator over values in a HashSet
pub struct Iter<'a, T> {
    inner: hashmap::Keys<'a, T, ()>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        self.inner.next()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        self.inner.size_hint()
    }
}

/// Owning iterator over values in a HashSet
pub struct IntoIter<T> {
    inner: hashmap::IntoIter<T, ()>,
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.inner.next().map(|(k, _)| k)
    }
}

/// Draining iterator over values in a HashSet
pub struct Drain<'a, T> {
    inner: hashmap::Drain<'a, T, ()>,
}

impl<'a, T> Iterator for Drain<'a, T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.inner.next().map(|(k, _)| k)
    }
}

/// Iterator over values in self but not in other
pub struct Difference<'a, T, S> {
    iter: Iter<'a, T>,
    other: &'a HashSet<T, S>,
}

impl<'a, T, S> Iterator for Difference<'a, T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        loop {
            let item = self.iter.next()?;
            if !self.other.contains(item) {
                return Some(item);
            }
        }
    }
}

/// Iterator over values in either self or other but not both
pub struct SymmetricDifference<'a, T, S> {
    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,
}

impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        self.iter.next()
    }
}

/// Iterator over values in both self and other
pub struct Intersection<'a, T, S> {
    iter: Iter<'a, T>,
    other: &'a HashSet<T, S>,
}

impl<'a, T, S> Iterator for Intersection<'a, T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        loop {
            let item = self.iter.next()?;
            if self.other.contains(item) {
                return Some(item);
            }
        }
    }
}

/// Iterator over values in either self or other
pub struct Union<'a, T, S> {
    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,
}

impl<'a, T, S> Iterator for Union<'a, T, S>
where
    T: Hash + Eq,
    S: BuildHasher,
{
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        self.iter.next()
    }
}

/// Chain iterator helper
pub struct Chain<A, B> {
    a: Option<A>,
    b: B,
}

impl<A, B> Chain<A, B> {
    fn new(a: A, b: B) -> Self / pure {
        Chain { a: Some(a), b }
    }
}

impl<T, A, B> Iterator for Chain<A, B>
where
    A: Iterator<Item = T>,
    B: Iterator<Item = T>,
{
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        if let Some(ref mut a) = self.a {
            if let Some(item) = a.next() {
                return Some(item);
            }
            self.a = None;
        }
        self.b.next()
    }
}

// Extension trait for chaining iterators
trait IteratorExt: Iterator + Sized {
    fn chain<U: Iterator<Item = Self::Item>>(self: Self, other: U) -> Chain<Self, U> / pure {
        Chain::new(self, other)
    }
}

impl<I: Iterator> IteratorExt for I {}
