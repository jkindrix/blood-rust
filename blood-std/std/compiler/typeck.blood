/// Blood Type Checker - Third step toward self-hosting
///
/// This module implements the type checking and inference engine for Blood,
/// using a bidirectional Hindley-Milner type system extended with:
/// - Effect row polymorphism (from Koka)
/// - Linear and affine types
/// - Record row polymorphism
/// - Trait-based dispatch
///
/// Part of Phase 6: Self-Hosting.

use std.compiler.parser::{
    Program, Declaration, FnDecl, StructDecl, EnumDecl, TraitDecl,
    ImplBlock, EffectDecl, HandlerDecl, TypeDecl, ConstDecl, StaticDecl,
    Expr, ExprKind, Pattern, PatternKind, Block, Statement,
    Type as AstType, TypeKind as AstTypeKind, TypePath, TypeArgs,
    BinOp, UnaryOp, Literal, LiteralKind,
    Span, Spanned, Visibility,
};

// ============================================================
// Definition IDs
// ============================================================

/// Unique identifier for any named definition (function, type, etc.)
struct DefId {
    module: u32,
    local: u32,
}

impl DefId {
    fn new(module: u32, local: u32) -> DefId {
        DefId { module, local }
    }
}

/// Unique identifier for a type variable (used during inference)
struct TyVarId {
    id: u32,
}

impl TyVarId {
    fn new(id: u32) -> TyVarId {
        TyVarId { id }
    }
}

/// Unique identifier for a record row variable (row polymorphism)
struct RecordRowVarId {
    id: u32,
}

/// Unique identifier for an effect row variable (effect polymorphism)
struct EffectRowVarId {
    id: u32,
}

impl EffectRowVarId {
    fn new(id: u32) -> EffectRowVarId {
        EffectRowVarId { id }
    }
}

/// Unique identifier for a type-checked body
struct BodyId {
    id: u32,
}

// ============================================================
// Type Representation
// ============================================================

/// Core type representation used throughout type checking.
/// This is the internal type, distinct from the parser's AST Type.
struct Type {
    kind: TypeKind,
}

/// Primitive types
enum PrimitiveTy {
    Bool,
    I8, I16, I32, I64, I128, Isize,
    U8, U16, U32, U64, U128, Usize,
    F32, F64,
    Char,
    Str,
    Unit,
}

/// The kind of a type
enum TypeKind {
    /// Primitive type: `i32`, `bool`, `()`, etc.
    Primitive(PrimitiveTy),
    /// Type variable for inference: `?T`
    Infer(TyVarId),
    /// Forall-bound type parameter: `T` in `fn<T>(x: T) -> T`
    Param(TyVarId),
    /// Function type: `fn(T, U) -> V / {E}`
    Fn { params: [Type], ret: Box<Type>, effects: EffectRow },
    /// Closure type (anonymous function with captures)
    Closure { def_id: DefId, params: [Type], ret: Box<Type> },
    /// Algebraic data type (struct or enum): `Vec<i32>`, `Option<T>`
    Adt { def_id: DefId, args: [Type] },
    /// Tuple type: `(T, U, V)`
    Tuple([Type]),
    /// Array type with compile-time known size: `[T; N]`
    Array { element: Box<Type>, size: u64 },
    /// Slice type: `[T]`
    Slice { element: Box<Type> },
    /// Reference type: `&T` or `&mut T`
    Ref { inner: Box<Type>, mutable: bool },
    /// Pointer type: `*const T` or `*mut T`
    Ptr { inner: Box<Type>, mutable: bool },
    /// Record type with row polymorphism: `{ x: i32, y: bool | R }`
    Record { fields: [RecordField], row_var: Option<RecordRowVarId> },
    /// Universally quantified type: `forall<T>. T -> T`
    Forall { params: [TyVarId], body: Box<Type> },
    /// Range type
    Range { element: Box<Type>, inclusive: bool },
    /// Dynamic trait object: `dyn Trait`
    DynTrait { trait_id: DefId },
    /// Ownership qualifier: `linear T` or `affine T`
    Ownership { qualifier: OwnershipQualifier, inner: Box<Type> },
    /// The never/bottom type: `!`
    Never,
    /// Error type (for error recovery — unifies with anything)
    Error,
}

struct RecordField {
    name: String,
    ty: Type,
}

enum OwnershipQualifier {
    Linear,
    Affine,
}

// ============================================================
// Effect Row Types
// ============================================================

/// Effect row for tracking computational effects
struct EffectRow {
    kind: EffectRowKind,
}

enum EffectRowKind {
    /// Pure computation (no effects)
    Pure,
    /// Closed set of effects: `{IO, Error<E>}`
    Closed { effects: [EffectEntry] },
    /// Open row with rest variable: `{IO | e}`
    Open { effects: [EffectEntry], rest: EffectRowVarId },
    /// Row variable: `e`
    Var(EffectRowVarId),
}

struct EffectEntry {
    effect_id: DefId,
    type_args: [Type],
}

impl EffectEntry {
    /// Check if two effect entries refer to the same effect (ignoring type args)
    fn same_effect(&self, other: &EffectEntry) -> bool {
        self.effect_id.module == other.effect_id.module
            && self.effect_id.local == other.effect_id.local
    }
}

impl EffectRow {
    fn pure() -> EffectRow {
        EffectRow { kind: EffectRowKind::Pure }
    }

    fn closed(effects: [EffectEntry]) -> EffectRow {
        if effects.is_empty() {
            EffectRow { kind: EffectRowKind::Pure }
        } else {
            EffectRow { kind: EffectRowKind::Closed { effects } }
        }
    }

    fn open(effects: [EffectEntry], rest: EffectRowVarId) -> EffectRow {
        EffectRow { kind: EffectRowKind::Open { effects, rest } }
    }

    fn var(v: EffectRowVarId) -> EffectRow {
        EffectRow { kind: EffectRowKind::Var(v) }
    }

    /// Returns true if the row has no effects and no row variable
    fn is_pure(&self) -> bool {
        match self.kind {
            EffectRowKind::Pure => true,
            EffectRowKind::Closed { effects } => effects.is_empty(),
            EffectRowKind::Open { effects, .. } => false,
            EffectRowKind::Var(_) => false,
        }
    }

    /// Returns true if the row has a row variable (is polymorphic)
    fn is_polymorphic(&self) -> bool {
        match self.kind {
            EffectRowKind::Pure => false,
            EffectRowKind::Closed { .. } => false,
            EffectRowKind::Open { .. } => true,
            EffectRowKind::Var(_) => true,
        }
    }

    /// Get the concrete effects in this row (empty for Pure and Var)
    fn effects(&self) -> &[EffectEntry] {
        match self.kind {
            EffectRowKind::Pure => &[],
            EffectRowKind::Closed { effects } => &effects,
            EffectRowKind::Open { effects, .. } => &effects,
            EffectRowKind::Var(_) => &[],
        }
    }

    /// Get the row variable if present
    fn row_var(&self) -> Option<EffectRowVarId> {
        match self.kind {
            EffectRowKind::Pure => None,
            EffectRowKind::Closed { .. } => None,
            EffectRowKind::Open { rest, .. } => Some(rest),
            EffectRowKind::Var(v) => Some(v),
        }
    }

    /// Check if this row contains a specific effect (by DefId)
    fn contains_effect(&self, def_id: &DefId) -> bool {
        let effs = self.effects();
        for e in effs {
            if e.effect_id.module == def_id.module && e.effect_id.local == def_id.local {
                return true;
            }
        }
        false
    }

    /// Find an effect entry by DefId
    fn find_effect(&self, def_id: &DefId) -> Option<&EffectEntry> {
        let effs = self.effects();
        for e in effs {
            if e.effect_id.module == def_id.module && e.effect_id.local == def_id.local {
                return Some(e);
            }
        }
        None
    }

    /// Add an effect to this row. Converts Pure to Closed or Open as needed.
    fn add_effect(&mut self, entry: EffectEntry) {
        match self.kind {
            EffectRowKind::Pure => {
                self.kind = EffectRowKind::Closed { effects: [entry] };
            }
            EffectRowKind::Closed { effects } => {
                effects.push(entry);
            }
            EffectRowKind::Open { effects, .. } => {
                effects.push(entry);
            }
            EffectRowKind::Var(v) => {
                self.kind = EffectRowKind::Open { effects: [entry], rest: v };
            }
        }
    }
}

// ============================================================
// Type Scheme (Polymorphic Types)
// ============================================================

/// A polymorphic type scheme: `forall a b. a -> b -> a`
struct TypeScheme {
    /// Bound type variables
    params: [TyVarId],
    /// The body type (may reference params)
    body: Type,
    /// Trait bounds on type variables
    bounds: [TypeBound],
}

struct TypeBound {
    var: TyVarId,
    trait_id: DefId,
    type_args: [Type],
}

// ============================================================
// Function Signatures
// ============================================================

struct FnSig {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    params: [ParamInfo],
    return_type: Type,
    effects: EffectRow,
    where_clause: [WherePredicate],
    is_unsafe: bool,
    span: Span,
}

struct TypeParamInfo {
    name: String,
    var_id: TyVarId,
    bounds: [Type],
}

struct ParamInfo {
    name: String,
    ty: Type,
    qualifier: Option<OwnershipQualifier>,
}

struct WherePredicate {
    ty: Type,
    bounds: [Type],
}

// ============================================================
// Type Definitions
// ============================================================

struct StructInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    fields: [FieldInfo],
    vis: Visibility,
    span: Span,
}

struct FieldInfo {
    name: String,
    ty: Type,
    vis: Visibility,
}

struct EnumInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    variants: [VariantInfo],
    vis: Visibility,
    span: Span,
}

struct VariantInfo {
    name: String,
    fields: [FieldInfo],
    /// Discriminant value (auto-assigned if not explicit)
    discriminant: Option<i64>,
}

// ============================================================
// Trait & Impl Definitions
// ============================================================

struct TraitInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    supertraits: [DefId],
    methods: [FnSig],
    assoc_types: [AssocTypeInfo],
    assoc_consts: [AssocConstInfo],
    span: Span,
}

struct AssocTypeInfo {
    name: String,
    bounds: [Type],
    default: Option<Type>,
}

struct AssocConstInfo {
    name: String,
    ty: Type,
    default: Option<DefId>,
}

struct ImplBlockInfo {
    def_id: DefId,
    type_params: [TypeParamInfo],
    self_ty: Type,
    trait_ref: Option<TraitRef>,
    methods: [FnSig],
    assoc_types: [(String, Type)],
    where_clause: [WherePredicate],
    span: Span,
}

struct TraitRef {
    trait_id: DefId,
    type_args: [Type],
}

// ============================================================
// Effect & Handler Definitions
// ============================================================

struct EffectInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    operations: [OperationInfo],
    span: Span,
}

struct OperationInfo {
    name: String,
    params: [ParamInfo],
    return_type: Type,
}

struct HandlerInfo {
    def_id: DefId,
    name: String,
    kind: HandlerKindTy,
    type_params: [TypeParamInfo],
    effect_ref: TraitRef,
    state_vars: [StateVarInfo],
    operations: [HandlerOpInfo],
    return_clause: Option<ReturnClauseInfo>,
    span: Span,
}

enum HandlerKindTy {
    Deep,
    Shallow,
}

struct StateVarInfo {
    name: String,
    ty: Type,
    is_mut: bool,
    default: Option<DefId>,
}

struct HandlerOpInfo {
    name: String,
    params: [String],
    body_id: BodyId,
}

struct ReturnClauseInfo {
    param_name: String,
    body_id: BodyId,
}

// ============================================================
// Type Error
// ============================================================

struct TypeError {
    kind: TypeErrorKind,
    span: Span,
}

enum TypeErrorKind {
    /// Type mismatch: expected `T`, found `U`
    Mismatch { expected: Type, found: Type },
    /// Infinite type: `?T` occurs in `T`
    InfiniteType { var: TyVarId, ty: Type },
    /// Unknown name
    UnknownName { name: String },
    /// Duplicate definition
    DuplicateDefinition { name: String },
    /// Expression is not callable
    NotAFunction { ty: Type },
    /// Argument count mismatch
    ArgCountMismatch { expected: u32, found: u32 },
    /// Unknown struct/enum field
    UnknownField { ty_name: String, field: String },
    /// Missing struct fields
    MissingFields { ty_name: String, fields: [String] },
    /// Not an effect
    NotAnEffect { name: String },
    /// Effect not handled
    UnhandledEffect { effect: String },
    /// No method found
    NoMatchingMethod { ty_name: String, method: String },
    /// Ambiguous method
    AmbiguousMethod { method: String, candidates: [String] },
    /// Non-exhaustive match
    NonExhaustiveMatch { missing: [String] },
    /// Unreachable pattern
    UnreachablePattern,
    /// Linear type not consumed
    LinearNotConsumed { name: String, ty: Type },
    /// Linear type used more than once
    LinearUsedMultiple { name: String, ty: Type },
    /// Affine type used more than once
    AffineUsedMultiple { name: String, ty: Type },
    /// Effect row mismatch (different effect sets)
    EffectRowMismatch { expected: [String], found: [String] },
    /// Feature not yet supported
    UnsupportedFeature { feature: String },
}

// ============================================================
// Unifier (Type Variable Substitutions)
// ============================================================

/// The Unifier manages type variable bindings and performs unification.
///
/// Unification determines if two types can be made equal by substituting
/// type variables, following the Hindley-Milner algorithm.
struct Unifier {
    /// Map from type variable to its binding
    substitutions: [(TyVarId, Type)],
    /// Next fresh variable ID
    next_var: u32,
    /// Row variable substitutions for record types
    row_substitutions: [(RecordRowVarId, [RecordField])],
    /// Next fresh row variable ID
    next_row_var: u32,
    /// Effect row variable substitutions
    effect_row_substitutions: [(EffectRowVarId, EffectRow)],
    /// Next fresh effect row variable ID
    next_effect_row_var: u32,
}

impl Unifier {
    fn new() -> Unifier {
        Unifier {
            substitutions: [],
            next_var: 0,
            row_substitutions: [],
            next_row_var: 0,
            effect_row_substitutions: [],
            next_effect_row_var: 0,
        }
    }

    /// Generate a fresh type variable
    fn fresh_var(&mut self) -> Type {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        Type { kind: TypeKind::Infer(id) }
    }

    /// Generate N fresh type variables
    fn fresh_vars(&mut self, n: u32) -> [Type] {
        let mut vars = [];
        let mut i: u32 = 0;
        while i < n {
            vars.push(self.fresh_var());
            i = i + 1;
        }
        vars
    }

    /// Generate a fresh forall-bound type parameter
    fn fresh_param(&mut self) -> TyVarId {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        id
    }

    /// Generate a fresh effect row variable
    fn fresh_effect_row_var(&mut self) -> EffectRowVarId {
        let id = EffectRowVarId::new(self.next_effect_row_var);
        self.next_effect_row_var = self.next_effect_row_var + 1;
        id
    }

    /// Bind an effect row variable to an effect row
    fn bind_effect_row_var(&mut self, var: EffectRowVarId, row: EffectRow) {
        self.effect_row_substitutions.push((var, row));
    }

    /// Resolve an effect row by following substitution chains
    fn resolve_row(&self, row: &EffectRow) -> EffectRow {
        match row.kind {
            EffectRowKind::Var(v) => {
                for (bound_var, bound_row) in &self.effect_row_substitutions {
                    if bound_var.id == v.id {
                        return self.resolve_row(bound_row);
                    }
                }
                row.clone()
            }
            EffectRowKind::Open { effects, rest } => {
                // Resolve the rest variable
                for (bound_var, bound_row) in &self.effect_row_substitutions {
                    if bound_var.id == rest.id {
                        // Merge: concrete effects from this row + resolved rest
                        let resolved_rest = self.resolve_row(bound_row);
                        let mut merged_effects = effects.clone();
                        let rest_effects = resolved_rest.effects();
                        for e in rest_effects {
                            // Only add if not already present
                            let mut found = false;
                            for existing in &merged_effects {
                                if existing.same_effect(e) {
                                    found = true;
                                    break;
                                }
                            }
                            if !found {
                                merged_effects.push(e.clone());
                            }
                        }
                        // Propagate the rest's row variable if any
                        match resolved_rest.row_var() {
                            Some(new_rest) => {
                                return EffectRow::open(merged_effects, new_rest);
                            }
                            None => {
                                return EffectRow::closed(merged_effects);
                            }
                        }
                    }
                }
                row.clone()
            }
            _ => row.clone(),
        }
    }

    /// Unify two effect rows.
    ///
    /// Effect row unification follows the Koka/row-polymorphism algorithm:
    /// - Pure rows unify only with other pure rows or row variables bound to pure
    /// - Closed rows must have exactly matching effects
    /// - Open rows bind their row variable to the "difference" set from the other row
    /// - Two open rows create a fresh row variable for the union extension
    fn unify_rows(&mut self, r1: &EffectRow, r2: &EffectRow, span: Span) -> Result<(), TypeError> {
        let row1 = self.resolve_row(r1);
        let row2 = self.resolve_row(r2);

        match (&row1.kind, &row2.kind) {
            // Pure + Pure: trivially unifies
            (EffectRowKind::Pure, EffectRowKind::Pure) => Ok(()),

            // Pure + Var: bind var to pure
            (EffectRowKind::Pure, EffectRowKind::Var(v)) => {
                self.bind_effect_row_var(*v, EffectRow::pure());
                Ok(())
            }
            (EffectRowKind::Var(v), EffectRowKind::Pure) => {
                self.bind_effect_row_var(*v, EffectRow::pure());
                Ok(())
            }

            // Pure + Closed: error if closed has effects
            (EffectRowKind::Pure, EffectRowKind::Closed { effects }) => {
                if effects.is_empty() {
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::EffectRowMismatch {
                            expected: [],
                            found: self.effect_names(effects),
                        },
                        span,
                    })
                }
            }
            (EffectRowKind::Closed { effects }, EffectRowKind::Pure) => {
                if effects.is_empty() {
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::EffectRowMismatch {
                            expected: self.effect_names(effects),
                            found: [],
                        },
                        span,
                    })
                }
            }

            // Pure + Open: bind row var to pure, but only if no concrete effects
            (EffectRowKind::Pure, EffectRowKind::Open { effects, rest }) => {
                if effects.is_empty() {
                    self.bind_effect_row_var(*rest, EffectRow::pure());
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::EffectRowMismatch {
                            expected: [],
                            found: self.effect_names(effects),
                        },
                        span,
                    })
                }
            }
            (EffectRowKind::Open { effects, rest }, EffectRowKind::Pure) => {
                if effects.is_empty() {
                    self.bind_effect_row_var(*rest, EffectRow::pure());
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::EffectRowMismatch {
                            expected: self.effect_names(effects),
                            found: [],
                        },
                        span,
                    })
                }
            }

            // Var + Var: same var is identity, different vars link them
            (EffectRowKind::Var(v1), EffectRowKind::Var(v2)) => {
                if v1.id == v2.id {
                    Ok(())
                } else {
                    // Bind v1 to Var(v2)
                    self.bind_effect_row_var(*v1, EffectRow::var(*v2));
                    Ok(())
                }
            }

            // Var + Closed: bind var to the closed row
            (EffectRowKind::Var(v), EffectRowKind::Closed { effects }) => {
                self.bind_effect_row_var(*v, EffectRow::closed(effects.clone()));
                Ok(())
            }
            (EffectRowKind::Closed { effects }, EffectRowKind::Var(v)) => {
                self.bind_effect_row_var(*v, EffectRow::closed(effects.clone()));
                Ok(())
            }

            // Var + Open: bind var to the open row
            (EffectRowKind::Var(v), EffectRowKind::Open { effects, rest }) => {
                self.bind_effect_row_var(*v, EffectRow::open(effects.clone(), *rest));
                Ok(())
            }
            (EffectRowKind::Open { effects, rest }, EffectRowKind::Var(v)) => {
                self.bind_effect_row_var(*v, EffectRow::open(effects.clone(), *rest));
                Ok(())
            }

            // Closed + Closed: effects must match exactly
            (EffectRowKind::Closed { effects: e1 }, EffectRowKind::Closed { effects: e2 }) => {
                self.unify_effect_sets(e1, e2, span)
            }

            // Open + Closed: bind row var to remaining effects (closed)
            (EffectRowKind::Open { effects: e1, rest: rv1 },
             EffectRowKind::Closed { effects: e2 }) => {
                // First unify common effects
                self.unify_common_effects(e1, e2, span)?;
                // Find effects in e2 not in e1 — these go into rv1's binding
                let only_in_2 = self.effects_only_in(e2, e1);
                self.bind_effect_row_var(*rv1, EffectRow::closed(only_in_2));
                Ok(())
            }
            (EffectRowKind::Closed { effects: e1 },
             EffectRowKind::Open { effects: e2, rest: rv2 }) => {
                self.unify_common_effects(e1, e2, span)?;
                let only_in_1 = self.effects_only_in(e1, e2);
                self.bind_effect_row_var(*rv2, EffectRow::closed(only_in_1));
                Ok(())
            }

            // Open + Open: create fresh row var, bind both to extensions
            (EffectRowKind::Open { effects: e1, rest: rv1 },
             EffectRowKind::Open { effects: e2, rest: rv2 }) => {
                if rv1.id == rv2.id {
                    // Same row variable — effects must match exactly
                    self.unify_effect_sets(e1, e2, span)
                } else {
                    // Different row variables — create extensions
                    self.unify_common_effects(e1, e2, span)?;
                    let fresh = self.fresh_effect_row_var();
                    let only_in_1 = self.effects_only_in(e1, e2);
                    let only_in_2 = self.effects_only_in(e2, e1);
                    // rv1 = {only_in_2... | fresh}
                    self.bind_effect_row_var(*rv1, EffectRow::open(only_in_2, fresh));
                    // rv2 = {only_in_1... | fresh}
                    self.bind_effect_row_var(*rv2, EffectRow::open(only_in_1, fresh));
                    Ok(())
                }
            }
        }
    }

    /// Unify the type arguments of common effects between two effect sets.
    /// For each effect that appears in both sets, unify their type arguments.
    fn unify_common_effects(
        &mut self,
        e1: &[EffectEntry],
        e2: &[EffectEntry],
        span: Span,
    ) -> Result<(), TypeError> {
        for entry1 in e1 {
            for entry2 in e2 {
                if entry1.same_effect(entry2) {
                    // Same effect — unify type arguments
                    if entry1.type_args.len() == entry2.type_args.len() {
                        let mut i: usize = 0;
                        while i < entry1.type_args.len() {
                            self.unify(&entry1.type_args[i], &entry2.type_args[i], span)?;
                            i = i + 1;
                        }
                    }
                }
            }
        }
        Ok(())
    }

    /// Check that two closed effect sets match exactly (same effects, same order not required).
    fn unify_effect_sets(
        &mut self,
        e1: &[EffectEntry],
        e2: &[EffectEntry],
        span: Span,
    ) -> Result<(), TypeError> {
        if e1.len() != e2.len() {
            return Err(TypeError {
                kind: TypeErrorKind::EffectRowMismatch {
                    expected: self.effect_names(e1),
                    found: self.effect_names(e2),
                },
                span,
            });
        }
        // Check each effect in e1 exists in e2
        for entry1 in e1 {
            let mut found = false;
            for entry2 in e2 {
                if entry1.same_effect(entry2) {
                    found = true;
                    // Unify type args
                    if entry1.type_args.len() == entry2.type_args.len() {
                        let mut i: usize = 0;
                        while i < entry1.type_args.len() {
                            self.unify(&entry1.type_args[i], &entry2.type_args[i], span)?;
                            i = i + 1;
                        }
                    }
                    break;
                }
            }
            if !found {
                return Err(TypeError {
                    kind: TypeErrorKind::UnhandledEffect {
                        effect: "unknown".to_string(),
                    },
                    span,
                });
            }
        }
        Ok(())
    }

    /// Convert effect entries to a list of name strings for error reporting.
    /// Uses DefId as a stand-in since we don't have access to names at this level.
    fn effect_names(&self, entries: &[EffectEntry]) -> [String] {
        let mut names = [];
        for e in entries {
            names.push(format!("effect({}:{})", e.effect_id.module, e.effect_id.local));
        }
        names
    }

    /// Return effects that are in `source` but not in `exclude`.
    fn effects_only_in(&self, source: &[EffectEntry], exclude: &[EffectEntry]) -> [EffectEntry] {
        let mut result = [];
        for s in source {
            let mut found = false;
            for e in exclude {
                if s.same_effect(e) {
                    found = true;
                    break;
                }
            }
            if !found {
                result.push(s.clone());
            }
        }
        result
    }

    /// Resolve a type by following substitution chains
    fn resolve(&self, ty: &Type) -> Type {
        match ty.kind {
            TypeKind::Infer(var) => {
                // Look up substitution
                for (v, bound_ty) in &self.substitutions {
                    if v.id == var.id {
                        // Recursively resolve (follow chain)
                        return self.resolve(bound_ty);
                    }
                }
                // No substitution found — return as-is
                Type { kind: TypeKind::Infer(var) }
            }
            _ => ty.clone(),
        }
    }

    /// Bind a type variable to a type (after occurs check)
    fn bind(&mut self, var: TyVarId, ty: &Type, span: Span) -> Result<(), TypeError> {
        // Occurs check: prevent infinite types like ?T = List<?T>
        if self.occurs_in(var, ty) {
            return Err(TypeError {
                kind: TypeErrorKind::InfiniteType { var, ty: ty.clone() },
                span,
            });
        }
        self.substitutions.push((var, ty.clone()));
        Ok(())
    }

    /// Check if a type variable occurs within a type (prevents infinite types)
    fn occurs_in(&self, var: TyVarId, ty: &Type) -> bool {
        let resolved = self.resolve(ty);
        match resolved.kind {
            TypeKind::Infer(other) => var.id == other.id,
            TypeKind::Param(other) => var.id == other.id,
            TypeKind::Fn { params, ret, .. } => {
                for p in &params {
                    if self.occurs_in(var, p) {
                        return true;
                    }
                }
                self.occurs_in(var, &ret)
            }
            TypeKind::Adt { args, .. } => {
                for a in &args {
                    if self.occurs_in(var, a) {
                        return true;
                    }
                }
                false
            }
            TypeKind::Tuple(elems) => {
                for e in &elems {
                    if self.occurs_in(var, e) {
                        return true;
                    }
                }
                false
            }
            TypeKind::Array { element, .. } => self.occurs_in(var, &element),
            TypeKind::Slice { element } => self.occurs_in(var, &element),
            TypeKind::Ref { inner, .. } => self.occurs_in(var, &inner),
            TypeKind::Ptr { inner, .. } => self.occurs_in(var, &inner),
            TypeKind::Forall { body, .. } => self.occurs_in(var, &body),
            TypeKind::Ownership { inner, .. } => self.occurs_in(var, &inner),
            TypeKind::Record { fields, .. } => {
                for f in &fields {
                    if self.occurs_in(var, &f.ty) {
                        return true;
                    }
                }
                false
            }
            _ => false,
        }
    }

    /// Unify two types, making them equal by binding type variables.
    /// Returns Ok(()) on success, Err(TypeError) on mismatch.
    fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        let r1 = self.resolve(t1);
        let r2 = self.resolve(t2);

        match (&r1.kind, &r2.kind) {
            // Identity: same primitive
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => {
                if p1 == p2 {
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Type variable: bind to concrete type
            (TypeKind::Infer(v), _) => self.bind(*v, &r2, span),
            (_, TypeKind::Infer(v)) => self.bind(*v, &r1, span),

            // Type parameters: must be identical
            (TypeKind::Param(p1), TypeKind::Param(p2)) => {
                if p1.id == p2.id {
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // ADT: same def + unify args
            (TypeKind::Adt { def_id: d1, args: a1 }, TypeKind::Adt { def_id: d2, args: a2 }) => {
                if d1.module == d2.module && d1.local == d2.local && a1.len() == a2.len() {
                    let mut i: usize = 0;
                    while i < a1.len() {
                        self.unify(&a1[i], &a2[i], span)?;
                        i = i + 1;
                    }
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Tuple: same length + unify elements
            (TypeKind::Tuple(ts1), TypeKind::Tuple(ts2)) => {
                if ts1.len() == ts2.len() {
                    let mut i: usize = 0;
                    while i < ts1.len() {
                        self.unify(&ts1[i], &ts2[i], span)?;
                        i = i + 1;
                    }
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Function: same arity + unify params + unify return + unify effects
            (TypeKind::Fn { params: p1, ret: ret1, effects: eff1 },
             TypeKind::Fn { params: p2, ret: ret2, effects: eff2 }) => {
                if p1.len() == p2.len() {
                    let mut i: usize = 0;
                    while i < p1.len() {
                        self.unify(&p1[i], &p2[i], span)?;
                        i = i + 1;
                    }
                    self.unify(&ret1, &ret2, span)?;
                    self.unify_rows(&eff1, &eff2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Array: same size + unify element
            (TypeKind::Array { element: e1, size: s1 },
             TypeKind::Array { element: e2, size: s2 }) => {
                if s1 == s2 {
                    self.unify(&e1, &e2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Slice: unify element
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.unify(&e1, &e2, span)
            }

            // Reference: same mutability + unify inner
            (TypeKind::Ref { inner: i1, mutable: m1 },
             TypeKind::Ref { inner: i2, mutable: m2 }) => {
                if m1 == m2 {
                    self.unify(&i1, &i2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Pointer: same mutability + unify inner
            (TypeKind::Ptr { inner: i1, mutable: m1 },
             TypeKind::Ptr { inner: i2, mutable: m2 }) => {
                if m1 == m2 {
                    self.unify(&i1, &i2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Ownership: same qualifier + unify inner
            (TypeKind::Ownership { qualifier: q1, inner: i1 },
             TypeKind::Ownership { qualifier: q2, inner: i2 }) => {
                if q1 == q2 {
                    self.unify(&i1, &i2, span)
                } else {
                    // Affine subsumes linear
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Never type unifies with anything
            (TypeKind::Never, _) => Ok(()),
            (_, TypeKind::Never) => Ok(()),

            // Error type unifies with anything (for error recovery)
            (TypeKind::Error, _) => Ok(()),
            (_, TypeKind::Error) => Ok(()),

            // Mismatch
            _ => Err(TypeError {
                kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                span,
            }),
        }
    }

    /// Apply all substitutions to resolve a type completely ("zonking")
    fn zonk(&self, ty: &Type) -> Type {
        match ty.kind {
            TypeKind::Infer(var) => {
                let resolved = self.resolve(ty);
                match resolved.kind {
                    TypeKind::Infer(_) => resolved,
                    _ => self.zonk(&resolved),
                }
            }
            TypeKind::Fn { params, ret, effects } => {
                let mut zonked_params = [];
                for p in &params {
                    zonked_params.push(self.zonk(p));
                }
                Type {
                    kind: TypeKind::Fn {
                        params: zonked_params,
                        ret: Box::new(self.zonk(&ret)),
                        effects: self.zonk_row(&effects),
                    },
                }
            }
            TypeKind::Adt { def_id, args } => {
                let mut zonked_args = [];
                for a in &args {
                    zonked_args.push(self.zonk(a));
                }
                Type { kind: TypeKind::Adt { def_id, args: zonked_args } }
            }
            TypeKind::Tuple(elems) => {
                let mut zonked = [];
                for e in &elems {
                    zonked.push(self.zonk(e));
                }
                Type { kind: TypeKind::Tuple(zonked) }
            }
            TypeKind::Array { element, size } => {
                Type { kind: TypeKind::Array { element: Box::new(self.zonk(&element)), size } }
            }
            TypeKind::Slice { element } => {
                Type { kind: TypeKind::Slice { element: Box::new(self.zonk(&element)) } }
            }
            TypeKind::Ref { inner, mutable } => {
                Type { kind: TypeKind::Ref { inner: Box::new(self.zonk(&inner)), mutable } }
            }
            TypeKind::Ptr { inner, mutable } => {
                Type { kind: TypeKind::Ptr { inner: Box::new(self.zonk(&inner)), mutable } }
            }
            TypeKind::Forall { params, body } => {
                Type { kind: TypeKind::Forall { params, body: Box::new(self.zonk(&body)) } }
            }
            TypeKind::Ownership { qualifier, inner } => {
                Type { kind: TypeKind::Ownership { qualifier, inner: Box::new(self.zonk(&inner)) } }
            }
            TypeKind::Record { fields, row_var } => {
                let mut zonked_fields = [];
                for f in &fields {
                    zonked_fields.push(RecordField { name: f.name.clone(), ty: self.zonk(&f.ty) });
                }
                Type { kind: TypeKind::Record { fields: zonked_fields, row_var } }
            }
            _ => ty.clone(),
        }
    }

    /// Zonk an effect row: resolve all effect row variables and zonk type args
    fn zonk_row(&self, row: &EffectRow) -> EffectRow {
        let resolved = self.resolve_row(row);
        match resolved.kind {
            EffectRowKind::Pure => EffectRow::pure(),
            EffectRowKind::Closed { effects } => {
                let mut zonked = [];
                for e in &effects {
                    zonked.push(self.zonk_effect_entry(e));
                }
                EffectRow::closed(zonked)
            }
            EffectRowKind::Open { effects, rest } => {
                let mut zonked = [];
                for e in &effects {
                    zonked.push(self.zonk_effect_entry(e));
                }
                EffectRow::open(zonked, rest)
            }
            EffectRowKind::Var(v) => {
                // Unresolved row variable — leave as-is
                EffectRow::var(v)
            }
        }
    }

    /// Zonk type arguments inside an effect entry
    fn zonk_effect_entry(&self, entry: &EffectEntry) -> EffectEntry {
        let mut zonked_args = [];
        for a in &entry.type_args {
            zonked_args.push(self.zonk(a));
        }
        EffectEntry {
            effect_id: entry.effect_id.clone(),
            type_args: zonked_args,
        }
    }

    /// Instantiate a polymorphic type scheme with fresh type variables.
    /// Replaces all bound type parameters with fresh inference variables.
    fn instantiate(&mut self, scheme: &TypeScheme) -> Type {
        if scheme.params.is_empty() {
            return scheme.body.clone();
        }
        // Generate fresh variables for each bound parameter
        let mut subst = [];
        for param in &scheme.params {
            subst.push((*param, self.fresh_var()));
        }
        self.apply_subst(&scheme.body, &subst)
    }

    /// Apply a substitution mapping (TyVarId -> Type) to a type
    fn apply_subst(&self, ty: &Type, subst: &[(TyVarId, Type)]) -> Type {
        match ty.kind {
            TypeKind::Param(v) => {
                for (from, to) in subst {
                    if from.id == v.id {
                        return to.clone();
                    }
                }
                ty.clone()
            }
            TypeKind::Infer(_) => ty.clone(),
            TypeKind::Fn { params, ret, effects } => {
                let mut new_params = [];
                for p in &params {
                    new_params.push(self.apply_subst(p, subst));
                }
                Type {
                    kind: TypeKind::Fn {
                        params: new_params,
                        ret: Box::new(self.apply_subst(&ret, subst)),
                        effects: self.apply_subst_row(&effects, subst),
                    },
                }
            }
            TypeKind::Adt { def_id, args } => {
                let mut new_args = [];
                for a in &args {
                    new_args.push(self.apply_subst(a, subst));
                }
                Type { kind: TypeKind::Adt { def_id, args: new_args } }
            }
            TypeKind::Tuple(elems) => {
                let mut new_elems = [];
                for e in &elems {
                    new_elems.push(self.apply_subst(e, subst));
                }
                Type { kind: TypeKind::Tuple(new_elems) }
            }
            TypeKind::Array { element, size } => {
                Type { kind: TypeKind::Array {
                    element: Box::new(self.apply_subst(&element, subst)),
                    size,
                }}
            }
            TypeKind::Slice { element } => {
                Type { kind: TypeKind::Slice {
                    element: Box::new(self.apply_subst(&element, subst)),
                }}
            }
            TypeKind::Ref { inner, mutable } => {
                Type { kind: TypeKind::Ref {
                    inner: Box::new(self.apply_subst(&inner, subst)),
                    mutable,
                }}
            }
            TypeKind::Ptr { inner, mutable } => {
                Type { kind: TypeKind::Ptr {
                    inner: Box::new(self.apply_subst(&inner, subst)),
                    mutable,
                }}
            }
            TypeKind::Forall { params, body } => {
                // Don't substitute into the body for params that are shadowed
                let mut filtered = [];
                for (from, to) in subst {
                    let mut shadowed = false;
                    for p in &params {
                        if p.id == from.id {
                            shadowed = true;
                            break;
                        }
                    }
                    if !shadowed {
                        filtered.push((*from, to.clone()));
                    }
                }
                Type { kind: TypeKind::Forall {
                    params,
                    body: Box::new(self.apply_subst(&body, &filtered)),
                }}
            }
            TypeKind::Ownership { qualifier, inner } => {
                Type { kind: TypeKind::Ownership {
                    qualifier,
                    inner: Box::new(self.apply_subst(&inner, subst)),
                }}
            }
            TypeKind::Record { fields, row_var } => {
                let mut new_fields = [];
                for f in &fields {
                    new_fields.push(RecordField {
                        name: f.name.clone(),
                        ty: self.apply_subst(&f.ty, subst),
                    });
                }
                Type { kind: TypeKind::Record { fields: new_fields, row_var } }
            }
            _ => ty.clone(),
        }
    }

    /// Apply a type substitution to an effect row (type args in effect entries)
    fn apply_subst_row(&self, row: &EffectRow, subst: &[(TyVarId, Type)]) -> EffectRow {
        match row.kind {
            EffectRowKind::Pure => EffectRow::pure(),
            EffectRowKind::Closed { effects } => {
                let mut new_effects = [];
                for e in &effects {
                    let mut new_args = [];
                    for a in &e.type_args {
                        new_args.push(self.apply_subst(a, subst));
                    }
                    new_effects.push(EffectEntry {
                        effect_id: e.effect_id.clone(),
                        type_args: new_args,
                    });
                }
                EffectRow::closed(new_effects)
            }
            EffectRowKind::Open { effects, rest } => {
                let mut new_effects = [];
                for e in &effects {
                    let mut new_args = [];
                    for a in &e.type_args {
                        new_args.push(self.apply_subst(a, subst));
                    }
                    new_effects.push(EffectEntry {
                        effect_id: e.effect_id.clone(),
                        type_args: new_args,
                    });
                }
                EffectRow::open(new_effects, rest)
            }
            EffectRowKind::Var(v) => EffectRow::var(v),
        }
    }
}

// ============================================================
// Name Resolution Scope
// ============================================================

enum ScopeKind {
    Module,
    Function,
    Block,
    Handler,
    Loop,
}

struct Binding {
    name: String,
    def_id: DefId,
    ty: Type,
    is_mutable: bool,
}

struct Scope {
    kind: ScopeKind,
    bindings: [Binding],
    type_bindings: [(String, DefId)],
}

struct Resolver {
    scopes: [Scope],
    next_def_id: u32,
    module_id: u32,
}

impl Resolver {
    fn new(module_id: u32) -> Resolver {
        Resolver {
            scopes: [Scope { kind: ScopeKind::Module, bindings: [], type_bindings: [] }],
            next_def_id: 0,
            module_id,
        }
    }

    /// Allocate a fresh DefId
    fn fresh_def_id(&mut self) -> DefId {
        let id = DefId::new(self.module_id, self.next_def_id);
        self.next_def_id = self.next_def_id + 1;
        id
    }

    /// Push a new scope
    fn push_scope(&mut self, kind: ScopeKind) {
        self.scopes.push(Scope { kind, bindings: [], type_bindings: [] });
    }

    /// Pop the current scope
    fn pop_scope(&mut self) {
        self.scopes.pop();
    }

    /// Add a value binding to the current scope
    fn add_binding(&mut self, name: String, def_id: DefId, ty: Type, is_mutable: bool) {
        let scope = &mut self.scopes[self.scopes.len() - 1];
        scope.bindings.push(Binding { name, def_id, ty, is_mutable });
    }

    /// Add a type binding to the current scope
    fn add_type_binding(&mut self, name: String, def_id: DefId) {
        let scope = &mut self.scopes[self.scopes.len() - 1];
        scope.type_bindings.push((name, def_id));
    }

    /// Look up a value binding by name (searches from innermost scope outward)
    fn lookup_value(&self, name: &str) -> Option<&Binding> {
        let mut i = self.scopes.len();
        while i > 0 {
            i = i - 1;
            for binding in &self.scopes[i].bindings {
                if binding.name == name {
                    return Some(binding);
                }
            }
        }
        None
    }

    /// Look up a type binding by name
    fn lookup_type(&self, name: &str) -> Option<DefId> {
        let mut i = self.scopes.len();
        while i > 0 {
            i = i - 1;
            for (n, def_id) in &self.scopes[i].type_bindings {
                if n == name {
                    return Some(*def_id);
                }
            }
        }
        None
    }
}

// ============================================================
// Type Context (Main State)
// ============================================================

/// The main type checking state. Holds all type information,
/// the unifier, the resolver, and the type-checked bodies.
struct TypeContext {
    /// Unification engine
    unifier: Unifier,
    /// Name resolution
    resolver: Resolver,

    /// Function signatures
    fn_sigs: [(DefId, FnSig)],
    /// Struct definitions
    struct_defs: [(DefId, StructInfo)],
    /// Enum definitions
    enum_defs: [(DefId, EnumInfo)],
    /// Trait definitions
    trait_defs: [(DefId, TraitInfo)],
    /// Impl blocks
    impl_blocks: [ImplBlockInfo],
    /// Effect definitions
    effect_defs: [(DefId, EffectInfo)],
    /// Handler definitions
    handler_defs: [(DefId, HandlerInfo)],
    /// Type alias definitions
    type_aliases: [(DefId, Type)],

    /// Current function being checked
    current_fn: Option<DefId>,
    /// Expected return type of current function
    return_type: Option<Type>,
    /// Effect handler stack
    handled_effects: [(DefId, [Type])],

    /// Accumulated errors
    errors: [TypeError],
}

impl TypeContext {
    fn new() -> TypeContext {
        TypeContext {
            unifier: Unifier::new(),
            resolver: Resolver::new(0),
            fn_sigs: [],
            struct_defs: [],
            enum_defs: [],
            trait_defs: [],
            impl_blocks: [],
            effect_defs: [],
            handler_defs: [],
            type_aliases: [],
            current_fn: None,
            return_type: None,
            handled_effects: [],
            errors: [],
        }
    }

    /// Report a type error
    fn error(&mut self, kind: TypeErrorKind, span: Span) {
        self.errors.push(TypeError { kind, span });
    }

    /// Create the unit type `()`
    fn unit_type(&self) -> Type {
        Type { kind: TypeKind::Primitive(PrimitiveTy::Unit) }
    }

    /// Create the bool type
    fn bool_type(&self) -> Type {
        Type { kind: TypeKind::Primitive(PrimitiveTy::Bool) }
    }

    /// Create the i32 type
    fn i32_type(&self) -> Type {
        Type { kind: TypeKind::Primitive(PrimitiveTy::I32) }
    }

    /// Create the error type (for recovery)
    fn error_type(&self) -> Type {
        Type { kind: TypeKind::Error }
    }

    /// Create a fresh type variable
    fn fresh_var(&mut self) -> Type {
        self.unifier.fresh_var()
    }

    /// Look up a struct by DefId
    fn get_struct(&self, def_id: &DefId) -> Option<&StructInfo> {
        for (id, info) in &self.struct_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up an enum by DefId
    fn get_enum(&self, def_id: &DefId) -> Option<&EnumInfo> {
        for (id, info) in &self.enum_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up a function signature by DefId
    fn get_fn_sig(&self, def_id: &DefId) -> Option<&FnSig> {
        for (id, sig) in &self.fn_sigs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(sig);
            }
        }
        None
    }

    /// Look up an effect by DefId
    fn get_effect(&self, def_id: &DefId) -> Option<&EffectInfo> {
        for (id, info) in &self.effect_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up a trait by DefId
    fn get_trait(&self, def_id: &DefId) -> Option<&TraitInfo> {
        for (id, info) in &self.trait_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up a handler by DefId
    fn get_handler(&self, def_id: &DefId) -> Option<&HandlerInfo> {
        for (id, info) in &self.handler_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up a type alias by DefId
    fn get_type_alias(&self, def_id: &DefId) -> Option<&Type> {
        for (id, ty) in &self.type_aliases {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(ty);
            }
        }
        None
    }

    /// Create a fresh effect row variable
    fn fresh_effect_row_var(&mut self) -> EffectRowVarId {
        self.unifier.fresh_effect_row_var()
    }

    /// Push a handler onto the effect handling stack.
    /// This makes the effect available for `perform` expressions.
    fn push_handler(&mut self, effect_id: DefId, type_args: [Type]) {
        self.handled_effects.push((effect_id, type_args));
    }

    /// Pop a handler from the effect handling stack.
    fn pop_handler(&mut self) {
        self.handled_effects.pop();
    }

    /// Check if an effect is currently handled (on the handler stack).
    fn is_effect_handled(&self, effect_id: &DefId) -> bool {
        for (id, _) in &self.handled_effects {
            if id.module == effect_id.module && id.local == effect_id.local {
                return true;
            }
        }
        false
    }

    /// Get the type arguments for a handled effect.
    fn get_handled_type_args(&self, effect_id: &DefId) -> Option<&[Type]> {
        for (id, args) in &self.handled_effects {
            if id.module == effect_id.module && id.local == effect_id.local {
                return Some(args);
            }
        }
        None
    }

    /// Check that all effects required by a callee are satisfied at a call site.
    ///
    /// For each effect in the callee's effect row:
    /// 1. Check if it's handled by an enclosing handler block
    /// 2. Check if the current function declares the effect (propagation)
    /// 3. Check if the current function's effect row is polymorphic (can absorb)
    /// 4. Otherwise, report an unhandled effect error
    fn check_effects_at_call(
        &mut self,
        callee_effects: &EffectRow,
        caller_effects: &EffectRow,
        span: Span,
    ) {
        let resolved = self.unifier.resolve_row(callee_effects);
        let caller_resolved = self.unifier.resolve_row(caller_effects);

        let effects = resolved.effects();
        for effect_entry in effects {
            let effect_id = &effect_entry.effect_id;

            // 1. Check if handled by an enclosing handler
            if self.is_effect_handled(effect_id) {
                // Unify type arguments with the handler's type arguments
                match self.get_handled_type_args(effect_id) {
                    Some(handled_args) => {
                        if handled_args.len() == effect_entry.type_args.len() {
                            let mut i: usize = 0;
                            while i < effect_entry.type_args.len() {
                                let _ = self.unifier.unify(
                                    &effect_entry.type_args[i],
                                    &handled_args[i],
                                    span,
                                );
                                i = i + 1;
                            }
                        }
                    }
                    None => {}
                }
                continue;
            }

            // 2. Check if caller declares this effect
            if caller_resolved.contains_effect(effect_id) {
                continue;
            }

            // 3. Check if caller has a row variable (effect polymorphic)
            if caller_resolved.is_polymorphic() {
                continue;
            }

            // 4. Unhandled effect — error
            let effect_name = match self.get_effect(effect_id) {
                Some(info) => info.name.clone(),
                None => "unknown".to_string(),
            };
            self.error(TypeErrorKind::UnhandledEffect { effect: effect_name }, span);
        }
    }

    /// Check that a perform expression is valid:
    /// The effect must be handled or declared in the current function's effects.
    fn check_perform(
        &mut self,
        effect_id: &DefId,
        operation_name: &str,
        arg_types: &[Type],
        span: Span,
    ) -> Type {
        // Look up the effect definition
        match self.get_effect(effect_id) {
            Some(effect_info) => {
                // Find the operation in the effect definition
                let mut found_op: Option<&OperationInfo> = None;
                for op in &effect_info.operations {
                    if op.name == operation_name {
                        found_op = Some(op);
                        break;
                    }
                }
                match found_op {
                    Some(op) => {
                        // Check argument count
                        if op.params.len() != arg_types.len() {
                            self.error(TypeErrorKind::ArgCountMismatch {
                                expected: op.params.len() as u32,
                                found: arg_types.len() as u32,
                            }, span);
                            return self.error_type();
                        }
                        // Unify argument types with parameter types
                        let mut i: usize = 0;
                        while i < arg_types.len() {
                            let _ = self.unifier.unify(&arg_types[i], &op.params[i].ty, span);
                            i = i + 1;
                        }
                        // Check the effect is handled or declared
                        if !self.is_effect_handled(effect_id) {
                            // Check if current function declares this effect
                            match self.current_fn {
                                Some(fn_id) => {
                                    match self.get_fn_sig(&fn_id) {
                                        Some(sig) => {
                                            if !sig.effects.contains_effect(effect_id)
                                                && !sig.effects.is_polymorphic()
                                            {
                                                self.error(TypeErrorKind::UnhandledEffect {
                                                    effect: effect_info.name.clone(),
                                                }, span);
                                            }
                                        }
                                        None => {
                                            self.error(TypeErrorKind::UnhandledEffect {
                                                effect: effect_info.name.clone(),
                                            }, span);
                                        }
                                    }
                                }
                                None => {
                                    self.error(TypeErrorKind::UnhandledEffect {
                                        effect: effect_info.name.clone(),
                                    }, span);
                                }
                            }
                        }
                        // Return the operation's return type
                        op.return_type.clone()
                    }
                    None => {
                        self.error(TypeErrorKind::NoMatchingMethod {
                            ty_name: effect_info.name.clone(),
                            method: operation_name.to_string(),
                        }, span);
                        self.error_type()
                    }
                }
            }
            None => {
                self.error(TypeErrorKind::NotAnEffect {
                    name: "unknown".to_string(),
                }, span);
                self.error_type()
            }
        }
    }

    /// Infer the effect row for a function body.
    /// Collects all effects performed directly or transitively within the body.
    fn infer_fn_effect_row(&self, fn_def_id: &DefId) -> EffectRow {
        // For now, use the declared effect row from the function signature.
        // Full inference would require analyzing the function body and collecting
        // all perform operations and transitive callee effects.
        match self.get_fn_sig(fn_def_id) {
            Some(sig) => sig.effects.clone(),
            None => EffectRow::pure(),
        }
    }

    /// Check that a handler block correctly handles all declared operations.
    fn check_handler_completeness(
        &mut self,
        handler_info: &HandlerInfo,
        span: Span,
    ) {
        let effect_id = &handler_info.effect_ref.trait_id;
        match self.get_effect(effect_id) {
            Some(effect_info) => {
                // Check that every operation in the effect has a handler arm
                for op in &effect_info.operations {
                    let mut found = false;
                    for handler_op in &handler_info.operations {
                        if handler_op.name == op.name {
                            found = true;
                            break;
                        }
                    }
                    if !found {
                        self.error(TypeErrorKind::UnhandledEffect {
                            effect: format!("{}.{}", effect_info.name, op.name),
                        }, span);
                    }
                }
            }
            None => {
                self.error(TypeErrorKind::NotAnEffect {
                    name: "unknown".to_string(),
                }, span);
            }
        }
    }

    /// Convert an AST type to an internal Type.
    /// Resolves type names to DefIds via the resolver.
    fn lower_ast_type(&mut self, ast_ty: &AstType) -> Type {
        match ast_ty.kind {
            AstTypeKind::Path(path) => {
                // Single-segment path might be a primitive
                if path.segments.len() == 1 && path.type_args.is_none() {
                    let name = &path.segments[0];
                    match resolve_primitive(name) {
                        Some(prim) => return Type { kind: TypeKind::Primitive(prim) },
                        None => {}
                    }
                    // Check for "()" unit type
                    if name == "()" {
                        return self.unit_type();
                    }
                    // Check for "!" never type
                    if name == "!" {
                        return Type { kind: TypeKind::Never };
                    }
                }
                // Look up in resolver
                let full_name = path.segments.join("::");
                match self.resolver.lookup_type(&full_name) {
                    Some(def_id) => {
                        // Resolve type arguments
                        let mut args = [];
                        match path.type_args {
                            Some(type_args) => {
                                for arg in &type_args.args {
                                    args.push(self.lower_ast_type(arg));
                                }
                            }
                            None => {}
                        }
                        Type { kind: TypeKind::Adt { def_id, args } }
                    }
                    None => {
                        // Also try single-segment lookup (common for local types)
                        if path.segments.len() == 1 {
                            match self.resolver.lookup_type(&path.segments[0]) {
                                Some(def_id) => {
                                    let mut args = [];
                                    match path.type_args {
                                        Some(type_args) => {
                                            for arg in &type_args.args {
                                                args.push(self.lower_ast_type(arg));
                                            }
                                        }
                                        None => {}
                                    }
                                    Type { kind: TypeKind::Adt { def_id, args } }
                                }
                                None => {
                                    self.error(TypeErrorKind::UnknownName {
                                        name: full_name,
                                    }, ast_ty.span);
                                    self.error_type()
                                }
                            }
                        } else {
                            self.error(TypeErrorKind::UnknownName {
                                name: full_name,
                            }, ast_ty.span);
                            self.error_type()
                        }
                    }
                }
            }
            AstTypeKind::Tuple(elems) => {
                let mut types = [];
                for e in &elems {
                    types.push(self.lower_ast_type(e));
                }
                Type { kind: TypeKind::Tuple(types) }
            }
            AstTypeKind::Array { element, size } => {
                let elem_ty = self.lower_ast_type(&element);
                Type { kind: TypeKind::Array { element: Box::new(elem_ty), size } }
            }
            AstTypeKind::Slice { element } => {
                let elem_ty = self.lower_ast_type(&element);
                Type { kind: TypeKind::Slice { element: Box::new(elem_ty) } }
            }
            AstTypeKind::Reference { inner, mutable } => {
                let inner_ty = self.lower_ast_type(&inner);
                Type { kind: TypeKind::Ref { inner: Box::new(inner_ty), mutable } }
            }
            AstTypeKind::Pointer { inner, mutable } => {
                let inner_ty = self.lower_ast_type(&inner);
                Type { kind: TypeKind::Ptr { inner: Box::new(inner_ty), mutable } }
            }
            AstTypeKind::Function { params, ret, effects } => {
                let mut param_types = [];
                for p in &params {
                    param_types.push(self.lower_ast_type(p));
                }
                let ret_type = match ret {
                    Some(r) => self.lower_ast_type(&r),
                    None => self.unit_type(),
                };
                let effect_row = match effects {
                    Some(eff) => self.lower_ast_effect_row(&eff),
                    None => EffectRow::pure(),
                };
                Type { kind: TypeKind::Fn {
                    params: param_types,
                    ret: Box::new(ret_type),
                    effects: effect_row,
                }}
            }
            AstTypeKind::Never => Type { kind: TypeKind::Never },
            AstTypeKind::Infer => self.fresh_var(),
            _ => {
                self.error(TypeErrorKind::UnsupportedFeature {
                    feature: "complex type".to_string(),
                }, ast_ty.span);
                self.error_type()
            }
        }
    }

    /// Convert an AST effect row to an internal EffectRow.
    fn lower_ast_effect_row(&mut self, effects: &[AstType]) -> EffectRow {
        if effects.is_empty() {
            return EffectRow::pure();
        }
        let mut entries = [];
        let mut row_var: Option<EffectRowVarId> = None;
        for eff in effects {
            match eff.kind {
                AstTypeKind::Path(path) => {
                    // Check if this is a row variable (single lowercase identifier)
                    if path.segments.len() == 1 {
                        let name = &path.segments[0];
                        let first_char = name.chars().next();
                        match first_char {
                            Some(c) => {
                                if c.is_lowercase() && path.type_args.is_none() {
                                    // This is a row variable (e.g., `e` in `{IO | e}`)
                                    row_var = Some(self.fresh_effect_row_var());
                                    continue;
                                }
                            }
                            None => {}
                        }
                    }
                    // Otherwise it's an effect reference
                    let full_name = path.segments.join("::");
                    match self.resolver.lookup_type(&full_name) {
                        Some(def_id) => {
                            let mut type_args = [];
                            match path.type_args {
                                Some(args) => {
                                    for arg in &args.args {
                                        type_args.push(self.lower_ast_type(arg));
                                    }
                                }
                                None => {}
                            }
                            entries.push(EffectEntry { effect_id: def_id, type_args });
                        }
                        None => {
                            // Try single-segment lookup
                            if path.segments.len() == 1 {
                                match self.resolver.lookup_type(&path.segments[0]) {
                                    Some(def_id) => {
                                        let mut type_args = [];
                                        match path.type_args {
                                            Some(args) => {
                                                for arg in &args.args {
                                                    type_args.push(self.lower_ast_type(arg));
                                                }
                                            }
                                            None => {}
                                        }
                                        entries.push(EffectEntry { effect_id: def_id, type_args });
                                    }
                                    None => {
                                        self.error(TypeErrorKind::NotAnEffect {
                                            name: full_name,
                                        }, eff.span);
                                    }
                                }
                            } else {
                                self.error(TypeErrorKind::NotAnEffect {
                                    name: full_name,
                                }, eff.span);
                            }
                        }
                    }
                }
                _ => {
                    self.error(TypeErrorKind::UnsupportedFeature {
                        feature: "complex effect type".to_string(),
                    }, eff.span);
                }
            }
        }
        match row_var {
            Some(rv) => EffectRow::open(entries, rv),
            None => EffectRow::closed(entries),
        }
    }

    /// Check effect row subsumption: callee_row must be a subset of caller_row.
    /// This is used when checking that a function call's effects are permitted.
    fn check_effect_subsumption(
        &mut self,
        callee_row: &EffectRow,
        caller_row: &EffectRow,
        span: Span,
    ) -> Result<(), TypeError> {
        let callee = self.unifier.resolve_row(callee_row);
        let caller = self.unifier.resolve_row(caller_row);

        // Pure callee has no effects — always OK
        if callee.is_pure() {
            return Ok(());
        }

        // If caller is polymorphic, it can absorb any effects
        if caller.is_polymorphic() {
            // Unify the callee effects into the caller's row variable
            return self.unifier.unify_rows(&callee, &caller, span);
        }

        // Otherwise, each callee effect must appear in the caller or be handled
        let callee_effects = callee.effects();
        for entry in callee_effects {
            if !caller.contains_effect(&entry.effect_id)
                && !self.is_effect_handled(&entry.effect_id)
            {
                let effect_name = match self.get_effect(&entry.effect_id) {
                    Some(info) => info.name.clone(),
                    None => "unknown".to_string(),
                };
                return Err(TypeError {
                    kind: TypeErrorKind::UnhandledEffect { effect: effect_name },
                    span,
                });
            }
        }
        Ok(())
    }
}

// ============================================================
// Primitive Type Resolution
// ============================================================

/// Resolve a type name to a primitive type, if it is one.
fn resolve_primitive(name: &str) -> Option<PrimitiveTy> {
    match name {
        "bool" => Some(PrimitiveTy::Bool),
        "i8" => Some(PrimitiveTy::I8),
        "i16" => Some(PrimitiveTy::I16),
        "i32" => Some(PrimitiveTy::I32),
        "i64" => Some(PrimitiveTy::I64),
        "i128" => Some(PrimitiveTy::I128),
        "isize" => Some(PrimitiveTy::Isize),
        "u8" => Some(PrimitiveTy::U8),
        "u16" => Some(PrimitiveTy::U16),
        "u32" => Some(PrimitiveTy::U32),
        "u64" => Some(PrimitiveTy::U64),
        "u128" => Some(PrimitiveTy::U128),
        "usize" => Some(PrimitiveTy::Usize),
        "f32" => Some(PrimitiveTy::F32),
        "f64" => Some(PrimitiveTy::F64),
        "char" => Some(PrimitiveTy::Char),
        "str" => Some(PrimitiveTy::Str),
        _ => None,
    }
}

// ============================================================
// Trait Resolution & Method Dispatch
// ============================================================

/// A candidate method found during dispatch resolution.
struct MethodCandidate {
    def_id: DefId,
    name: String,
    param_types: [Type],
    return_type: Type,
    /// Type parameters on this method (uninstantiated)
    type_params: [TypeParamInfo],
    /// Effect row for this method
    effects: EffectRow,
    /// The trait this method belongs to (None for inherent methods)
    trait_id: Option<DefId>,
    /// Whether auto-ref is needed (method takes &self but caller has self)
    needs_auto_ref: bool,
}

/// Result of method resolution
enum MethodResolution {
    /// Exactly one matching method found
    Resolved(MethodCandidate),
    /// No matching method found
    NoMatch { ty_name: String, method_name: String },
    /// Multiple equally-specific matches (ambiguity)
    Ambiguous { method_name: String, candidates: [String] },
}

/// Result of generic type parameter instantiation
enum InstantiationResult {
    /// Successfully instantiated all type parameters
    Success { substitutions: [(TyVarId, Type)], candidate: MethodCandidate },
    /// Arity mismatch between params and args
    ArityMismatch { expected: u32, found: u32 },
    /// Type parameter bound to inconsistent types
    TypeMismatch { param_id: TyVarId, expected: Type, found: Type },
    /// A constraint on a type parameter is not satisfied
    ConstraintNotSatisfied { param_name: String, constraint: String },
}

/// Trait resolver: finds the right method/impl for a given type and method name.
struct TraitResolver<'ctx> {
    ctx: &'ctx TypeContext,
}

impl<'ctx> TraitResolver<'ctx> {
    fn new(ctx: &'ctx TypeContext) -> TraitResolver<'ctx> {
        TraitResolver { ctx }
    }

    /// Resolve a method call: find the method to invoke for `receiver.method_name(args)`.
    ///
    /// Priority order:
    /// 1. Inherent impl methods (impl Type { fn method() })
    /// 2. Trait impl methods (impl Trait for Type { fn method() })
    /// 3. Trait bounds on type parameters (where T: Trait)
    /// 4. Auto-deref: if receiver is &T, try methods on T
    fn resolve_method(
        &self,
        receiver_ty: &Type,
        method_name: &str,
        arg_types: &[Type],
    ) -> MethodResolution {
        let mut candidates = [];

        // 1. Collect inherent methods
        self.collect_inherent_methods(receiver_ty, method_name, &mut candidates);

        // 2. Collect trait impl methods
        self.collect_trait_methods(receiver_ty, method_name, &mut candidates);

        // 3. Collect methods from trait bounds (for type parameters)
        self.collect_bound_methods(receiver_ty, method_name, &mut candidates);

        // 4. Try auto-deref if no direct match
        if candidates.is_empty() {
            match receiver_ty.kind {
                TypeKind::Ref { inner, .. } => {
                    self.collect_inherent_methods(&inner, method_name, &mut candidates);
                    self.collect_trait_methods(&inner, method_name, &mut candidates);
                }
                _ => {}
            }
        }

        // 5. Select the best candidate
        if candidates.is_empty() {
            return MethodResolution::NoMatch {
                ty_name: self.type_name(receiver_ty),
                method_name: method_name.to_string(),
            };
        }

        if candidates.len() == 1 {
            return MethodResolution::Resolved(candidates.pop().unwrap());
        }

        // Multiple candidates: find the most specific
        let maximal = self.find_most_specific(&candidates, arg_types);
        if maximal.len() == 1 {
            return MethodResolution::Resolved(maximal[0].clone());
        }

        MethodResolution::Ambiguous {
            method_name: method_name.to_string(),
            candidates: maximal.iter().map(|c| c.name.clone()).collect(),
        }
    }

    /// Collect inherent methods (impl blocks without a trait) for a type.
    fn collect_inherent_methods(
        &self,
        ty: &Type,
        method_name: &str,
        candidates: &mut [MethodCandidate],
    ) {
        for impl_block in &self.ctx.impl_blocks {
            // Skip trait impls
            match impl_block.trait_ref {
                Some(_) => continue,
                None => {}
            }
            // Check if self_ty matches
            if !self.types_match(&impl_block.self_ty, ty, &impl_block.type_params) {
                continue;
            }
            // Find matching method
            for method_sig in &impl_block.methods {
                if method_sig.name == method_name {
                    // Build substitution from impl generics
                    let subst = self.extract_impl_substitution(
                        &impl_block.type_params, &impl_block.self_ty, ty,
                    );
                    let return_type = self.apply_subst_with_map(
                        &method_sig.return_type, &subst,
                    );
                    let mut param_types = [];
                    for p in &method_sig.params {
                        param_types.push(self.apply_subst_with_map(&p.ty, &subst));
                    }
                    // Check if first param is &self (auto-ref needed)
                    let needs_auto_ref = if !method_sig.params.is_empty() {
                        match method_sig.params[0].ty.kind {
                            TypeKind::Ref { .. } => {
                                match ty.kind {
                                    TypeKind::Ref { .. } => false,
                                    _ => true,
                                }
                            }
                            _ => false,
                        }
                    } else {
                        false
                    };
                    candidates.push(MethodCandidate {
                        def_id: method_sig.def_id,
                        name: method_sig.name.clone(),
                        param_types,
                        return_type,
                        type_params: method_sig.type_params.clone(),
                        effects: method_sig.effects.clone(),
                        trait_id: None,
                        needs_auto_ref,
                    });
                }
            }
        }
    }

    /// Collect methods from trait implementations for a type.
    fn collect_trait_methods(
        &self,
        ty: &Type,
        method_name: &str,
        candidates: &mut [MethodCandidate],
    ) {
        for impl_block in &self.ctx.impl_blocks {
            // Only trait impls
            let trait_ref = match impl_block.trait_ref {
                Some(ref tr) => tr,
                None => continue,
            };
            // Check if self_ty matches
            if !self.types_match(&impl_block.self_ty, ty, &impl_block.type_params) {
                continue;
            }
            // Find matching method
            for method_sig in &impl_block.methods {
                if method_sig.name == method_name {
                    let subst = self.extract_impl_substitution(
                        &impl_block.type_params, &impl_block.self_ty, ty,
                    );
                    let return_type = self.apply_subst_with_map(
                        &method_sig.return_type, &subst,
                    );
                    let mut param_types = [];
                    for p in &method_sig.params {
                        param_types.push(self.apply_subst_with_map(&p.ty, &subst));
                    }
                    let needs_auto_ref = if !method_sig.params.is_empty() {
                        match method_sig.params[0].ty.kind {
                            TypeKind::Ref { .. } => {
                                match ty.kind {
                                    TypeKind::Ref { .. } => false,
                                    _ => true,
                                }
                            }
                            _ => false,
                        }
                    } else {
                        false
                    };
                    candidates.push(MethodCandidate {
                        def_id: method_sig.def_id,
                        name: method_sig.name.clone(),
                        param_types,
                        return_type,
                        type_params: method_sig.type_params.clone(),
                        effects: method_sig.effects.clone(),
                        trait_id: Some(trait_ref.trait_id),
                        needs_auto_ref,
                    });
                }
            }
        }
    }

    /// Collect methods available through trait bounds on type parameters.
    /// When we have `fn foo<T: Display>(x: T)`, T has methods from Display.
    fn collect_bound_methods(
        &self,
        ty: &Type,
        method_name: &str,
        candidates: &mut [MethodCandidate],
    ) {
        // Only applicable for type parameters
        let param_id = match ty.kind {
            TypeKind::Param(v) => v,
            _ => return,
        };
        // Look up bounds for this type parameter in the current scope
        // (bounds are registered during function signature processing)
        // For each bound trait, look up the method in the trait definition
        for (trait_def_id, trait_info) in &self.ctx.trait_defs {
            for method_sig in &trait_info.methods {
                if method_sig.name == method_name {
                    let mut param_types = [];
                    for p in &method_sig.params {
                        param_types.push(p.ty.clone());
                    }
                    candidates.push(MethodCandidate {
                        def_id: method_sig.def_id,
                        name: method_sig.name.clone(),
                        param_types,
                        return_type: method_sig.return_type.clone(),
                        type_params: method_sig.type_params.clone(),
                        effects: method_sig.effects.clone(),
                        trait_id: Some(*trait_def_id),
                        needs_auto_ref: false,
                    });
                }
            }
        }
    }

    /// Check if a type matches an impl block's self type, considering generics.
    fn types_match(&self, impl_ty: &Type, concrete_ty: &Type, generics: &[TypeParamInfo]) -> bool {
        if generics.is_empty() {
            return self.types_equal(impl_ty, concrete_ty);
        }
        // With generics, try to extract a substitution
        let subst = self.extract_impl_substitution(generics, impl_ty, concrete_ty);
        !subst.is_empty() || self.types_equal(impl_ty, concrete_ty)
    }

    /// Extract type parameter substitutions by matching an impl type against a concrete type.
    fn extract_impl_substitution(
        &self,
        generics: &[TypeParamInfo],
        impl_ty: &Type,
        concrete_ty: &Type,
    ) -> [(TyVarId, Type)] {
        let mut subst = [];
        self.match_types(impl_ty, concrete_ty, generics, &mut subst);
        subst
    }

    /// Recursively match two types, extracting type parameter bindings.
    fn match_types(
        &self,
        param_ty: &Type,
        arg_ty: &Type,
        generics: &[TypeParamInfo],
        subst: &mut [(TyVarId, Type)],
    ) {
        match param_ty.kind {
            TypeKind::Param(v) => {
                // Check if this is one of the generic params
                let mut is_generic = false;
                for g in generics {
                    if g.var_id.id == v.id {
                        is_generic = true;
                        break;
                    }
                }
                if is_generic {
                    // Check for existing binding
                    let mut already_bound = false;
                    for (bound_var, _) in &*subst {
                        if bound_var.id == v.id {
                            already_bound = true;
                            break;
                        }
                    }
                    if !already_bound {
                        subst.push((v, arg_ty.clone()));
                    }
                }
            }
            TypeKind::Adt { def_id: p_def, args: p_args } => {
                match arg_ty.kind {
                    TypeKind::Adt { def_id: a_def, args: a_args } => {
                        if p_def.module == a_def.module && p_def.local == a_def.local
                            && p_args.len() == a_args.len()
                        {
                            let mut i: usize = 0;
                            while i < p_args.len() {
                                self.match_types(&p_args[i], &a_args[i], generics, subst);
                                i = i + 1;
                            }
                        }
                    }
                    _ => {}
                }
            }
            TypeKind::Ref { inner: p_inner, mutable: p_mut } => {
                match arg_ty.kind {
                    TypeKind::Ref { inner: a_inner, mutable: a_mut } => {
                        if p_mut == a_mut {
                            self.match_types(&p_inner, &a_inner, generics, subst);
                        }
                    }
                    _ => {}
                }
            }
            TypeKind::Tuple(p_elems) => {
                match arg_ty.kind {
                    TypeKind::Tuple(a_elems) => {
                        if p_elems.len() == a_elems.len() {
                            let mut i: usize = 0;
                            while i < p_elems.len() {
                                self.match_types(&p_elems[i], &a_elems[i], generics, subst);
                                i = i + 1;
                            }
                        }
                    }
                    _ => {}
                }
            }
            TypeKind::Array { element: p_elem, size: p_size } => {
                match arg_ty.kind {
                    TypeKind::Array { element: a_elem, size: a_size } => {
                        if p_size == a_size {
                            self.match_types(&p_elem, &a_elem, generics, subst);
                        }
                    }
                    _ => {}
                }
            }
            TypeKind::Slice { element: p_elem } => {
                match arg_ty.kind {
                    TypeKind::Slice { element: a_elem } => {
                        self.match_types(&p_elem, &a_elem, generics, subst);
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }

    /// Apply a substitution map to a type.
    fn apply_subst_with_map(&self, ty: &Type, subst: &[(TyVarId, Type)]) -> Type {
        match ty.kind {
            TypeKind::Param(v) => {
                for (from, to) in subst {
                    if from.id == v.id {
                        return to.clone();
                    }
                }
                ty.clone()
            }
            TypeKind::Adt { def_id, args } => {
                let mut new_args = [];
                for a in &args {
                    new_args.push(self.apply_subst_with_map(a, subst));
                }
                Type { kind: TypeKind::Adt { def_id, args: new_args } }
            }
            TypeKind::Fn { params, ret, effects } => {
                let mut new_params = [];
                for p in &params {
                    new_params.push(self.apply_subst_with_map(p, subst));
                }
                Type { kind: TypeKind::Fn {
                    params: new_params,
                    ret: Box::new(self.apply_subst_with_map(&ret, subst)),
                    effects,
                }}
            }
            TypeKind::Ref { inner, mutable } => {
                Type { kind: TypeKind::Ref {
                    inner: Box::new(self.apply_subst_with_map(&inner, subst)),
                    mutable,
                }}
            }
            TypeKind::Tuple(elems) => {
                let mut new_elems = [];
                for e in &elems {
                    new_elems.push(self.apply_subst_with_map(e, subst));
                }
                Type { kind: TypeKind::Tuple(new_elems) }
            }
            TypeKind::Array { element, size } => {
                Type { kind: TypeKind::Array {
                    element: Box::new(self.apply_subst_with_map(&element, subst)),
                    size,
                }}
            }
            TypeKind::Slice { element } => {
                Type { kind: TypeKind::Slice {
                    element: Box::new(self.apply_subst_with_map(&element, subst)),
                }}
            }
            TypeKind::Ptr { inner, mutable } => {
                Type { kind: TypeKind::Ptr {
                    inner: Box::new(self.apply_subst_with_map(&inner, subst)),
                    mutable,
                }}
            }
            _ => ty.clone(),
        }
    }

    /// Check if two types are structurally equal.
    fn types_equal(&self, a: &Type, b: &Type) -> bool {
        match (&a.kind, &b.kind) {
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => p1 == p2,
            (TypeKind::Param(v1), TypeKind::Param(v2)) => v1.id == v2.id,
            (TypeKind::Infer(v1), TypeKind::Infer(v2)) => v1.id == v2.id,
            (TypeKind::Adt { def_id: d1, args: a1 },
             TypeKind::Adt { def_id: d2, args: a2 }) => {
                d1.module == d2.module && d1.local == d2.local
                    && a1.len() == a2.len()
                    && {
                        let mut eq = true;
                        let mut i: usize = 0;
                        while i < a1.len() {
                            if !self.types_equal(&a1[i], &a2[i]) {
                                eq = false;
                                break;
                            }
                            i = i + 1;
                        }
                        eq
                    }
            }
            (TypeKind::Tuple(t1), TypeKind::Tuple(t2)) => {
                t1.len() == t2.len() && {
                    let mut eq = true;
                    let mut i: usize = 0;
                    while i < t1.len() {
                        if !self.types_equal(&t1[i], &t2[i]) {
                            eq = false;
                            break;
                        }
                        i = i + 1;
                    }
                    eq
                }
            }
            (TypeKind::Ref { inner: i1, mutable: m1 },
             TypeKind::Ref { inner: i2, mutable: m2 }) => {
                m1 == m2 && self.types_equal(i1, i2)
            }
            (TypeKind::Ptr { inner: i1, mutable: m1 },
             TypeKind::Ptr { inner: i2, mutable: m2 }) => {
                m1 == m2 && self.types_equal(i1, i2)
            }
            (TypeKind::Array { element: e1, size: s1 },
             TypeKind::Array { element: e2, size: s2 }) => {
                s1 == s2 && self.types_equal(e1, e2)
            }
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.types_equal(e1, e2)
            }
            (TypeKind::Never, TypeKind::Never) => true,
            (TypeKind::Error, TypeKind::Error) => true,
            _ => false,
        }
    }

    /// Find the most specific candidates from a set of applicable methods.
    /// Uses parameter subtyping and effect specificity for tiebreaking.
    fn find_most_specific(
        &self,
        candidates: &[MethodCandidate],
        arg_types: &[Type],
    ) -> [MethodCandidate] {
        let mut maximal = [];
        for candidate in candidates {
            let is_maximal = {
                let mut dominated = false;
                for other in candidates {
                    if other.def_id.module == candidate.def_id.module
                        && other.def_id.local == candidate.def_id.local
                    {
                        continue;
                    }
                    if self.is_more_specific(other, candidate) {
                        dominated = true;
                        break;
                    }
                }
                !dominated
            };
            if is_maximal {
                maximal.push(candidate.clone());
            }
        }
        maximal
    }

    /// Check if method m1 is strictly more specific than m2.
    /// m1 is more specific if all its parameters are subtypes of m2's
    /// and at least one is strictly more specific.
    fn is_more_specific(&self, m1: &MethodCandidate, m2: &MethodCandidate) -> bool {
        if m1.param_types.len() != m2.param_types.len() {
            return false;
        }
        let mut all_at_least = true;
        let mut some_strictly = false;
        let mut i: usize = 0;
        while i < m1.param_types.len() {
            let sub_12 = self.is_subtype(&m1.param_types[i], &m2.param_types[i]);
            let sub_21 = self.is_subtype(&m2.param_types[i], &m1.param_types[i]);
            if !sub_12 {
                all_at_least = false;
                break;
            }
            if sub_12 && !sub_21 {
                some_strictly = true;
            }
            i = i + 1;
        }
        all_at_least && some_strictly
    }

    /// Subtype check: is `a` a subtype of `b`?
    ///
    /// Subtyping rules:
    /// - Any type is a subtype of itself
    /// - Never is a subtype of everything (bottom type)
    /// - &mut T <: &T (mutable ref can be used where immutable is expected)
    /// - Immutable refs are covariant: &A <: &B if A <: B
    /// - Functions are contravariant in params, covariant in return
    fn is_subtype(&self, a: &Type, b: &Type) -> bool {
        // Identity
        if self.types_equal(a, b) {
            return true;
        }
        // Never is bottom
        match a.kind {
            TypeKind::Never => return true,
            _ => {}
        }
        // Type variables unify with anything
        match b.kind {
            TypeKind::Infer(_) => return true,
            TypeKind::Param(_) => return true,
            _ => {}
        }
        match (&a.kind, &b.kind) {
            // &mut T <: &T (coerce mutable to immutable)
            (TypeKind::Ref { inner: a_inner, mutable: true },
             TypeKind::Ref { inner: b_inner, mutable: false }) => {
                self.is_subtype(a_inner, b_inner)
            }
            // Covariant immutable refs
            (TypeKind::Ref { inner: a_inner, mutable: false },
             TypeKind::Ref { inner: b_inner, mutable: false }) => {
                self.is_subtype(a_inner, b_inner)
            }
            // Invariant mutable refs
            (TypeKind::Ref { inner: a_inner, mutable: true },
             TypeKind::Ref { inner: b_inner, mutable: true }) => {
                self.types_equal(a_inner, b_inner)
            }
            // Function subtyping: contravariant params, covariant return
            (TypeKind::Fn { params: a_params, ret: a_ret, .. },
             TypeKind::Fn { params: b_params, ret: b_ret, .. }) => {
                if a_params.len() != b_params.len() {
                    return false;
                }
                // Contravariant params: b <: a for each param
                let mut i: usize = 0;
                while i < a_params.len() {
                    if !self.is_subtype(&b_params[i], &a_params[i]) {
                        return false;
                    }
                    i = i + 1;
                }
                // Covariant return
                self.is_subtype(a_ret, b_ret)
            }
            _ => false,
        }
    }

    /// Get a human-readable name for a type (for error messages).
    fn type_name(&self, ty: &Type) -> String {
        match ty.kind {
            TypeKind::Primitive(prim) => {
                match prim {
                    PrimitiveTy::Bool => "bool".to_string(),
                    PrimitiveTy::I8 => "i8".to_string(),
                    PrimitiveTy::I16 => "i16".to_string(),
                    PrimitiveTy::I32 => "i32".to_string(),
                    PrimitiveTy::I64 => "i64".to_string(),
                    PrimitiveTy::I128 => "i128".to_string(),
                    PrimitiveTy::Isize => "isize".to_string(),
                    PrimitiveTy::U8 => "u8".to_string(),
                    PrimitiveTy::U16 => "u16".to_string(),
                    PrimitiveTy::U32 => "u32".to_string(),
                    PrimitiveTy::U64 => "u64".to_string(),
                    PrimitiveTy::U128 => "u128".to_string(),
                    PrimitiveTy::Usize => "usize".to_string(),
                    PrimitiveTy::F32 => "f32".to_string(),
                    PrimitiveTy::F64 => "f64".to_string(),
                    PrimitiveTy::Char => "char".to_string(),
                    PrimitiveTy::Str => "str".to_string(),
                    PrimitiveTy::Unit => "()".to_string(),
                }
            }
            TypeKind::Adt { def_id, .. } => {
                // Try to find the name
                match self.ctx.get_struct(&def_id) {
                    Some(info) => info.name.clone(),
                    None => match self.ctx.get_enum(&def_id) {
                        Some(info) => info.name.clone(),
                        None => format!("type({}:{})", def_id.module, def_id.local),
                    },
                }
            }
            TypeKind::Ref { mutable: true, .. } => "&mut _".to_string(),
            TypeKind::Ref { mutable: false, .. } => "&_".to_string(),
            TypeKind::Tuple(_) => "(...)".to_string(),
            TypeKind::Array { .. } => "[_; N]".to_string(),
            TypeKind::Slice { .. } => "[_]".to_string(),
            TypeKind::Never => "!".to_string(),
            TypeKind::Error => "<error>".to_string(),
            TypeKind::Infer(_) => "?_".to_string(),
            TypeKind::Param(v) => format!("T{}", v.id),
            _ => "<unknown>".to_string(),
        }
    }
}

// ============================================================
// Trait Bounds & Supertrait Checking
// ============================================================

impl TypeContext {
    /// Check that a type implements a given trait.
    /// Searches impl blocks for an implementation.
    fn type_implements_trait(&self, ty: &Type, trait_def_id: &DefId) -> bool {
        let resolver = TraitResolver::new(self);

        // Check explicit impl blocks
        for impl_block in &self.impl_blocks {
            match impl_block.trait_ref {
                Some(ref trait_ref) => {
                    if trait_ref.trait_id.module == trait_def_id.module
                        && trait_ref.trait_id.local == trait_def_id.local
                        && resolver.types_match(&impl_block.self_ty, ty, &impl_block.type_params)
                    {
                        return true;
                    }
                }
                None => {}
            }
        }

        // Check if the type is a type parameter with a bound for this trait
        match ty.kind {
            TypeKind::Param(v) => {
                // Look for bounds in the current scope that reference this trait
                // (This would be populated during function signature checking)
                false
            }
            _ => false,
        }
    }

    /// Check that all trait bounds in a where clause are satisfied.
    fn check_where_clause(
        &mut self,
        where_clause: &[WherePredicate],
        subst: &[(TyVarId, Type)],
        span: Span,
    ) {
        for predicate in where_clause {
            // Apply substitution to get concrete type
            let concrete_ty = self.unifier.apply_subst(&predicate.ty, subst);
            // Check each bound
            for bound in &predicate.bounds {
                let bound_ty = self.unifier.apply_subst(bound, subst);
                // Extract trait DefId from the bound type
                match bound_ty.kind {
                    TypeKind::Adt { def_id, .. } => {
                        if !self.type_implements_trait(&concrete_ty, &def_id) {
                            let trait_name = match self.get_trait(&def_id) {
                                Some(info) => info.name.clone(),
                                None => format!("trait({}:{})", def_id.module, def_id.local),
                            };
                            self.error(TypeErrorKind::UnsupportedFeature {
                                feature: format!("{} does not implement {}",
                                    TraitResolver::new(self).type_name(&concrete_ty),
                                    trait_name),
                            }, span);
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    /// Validate that a trait impl block is complete (all required methods/assoc types present).
    fn validate_trait_impl(
        &mut self,
        trait_id: &DefId,
        impl_methods: &[FnSig],
        impl_assoc_types: &[(String, Type)],
        span: Span,
    ) {
        let trait_info = match self.get_trait(trait_id) {
            Some(info) => info.clone(),
            None => return,
        };

        // Check required methods
        for trait_method in &trait_info.methods {
            let mut provided = false;
            for impl_method in impl_methods {
                if impl_method.name == trait_method.name {
                    provided = true;
                    break;
                }
            }
            if !provided {
                self.error(TypeErrorKind::MissingFields {
                    ty_name: trait_info.name.clone(),
                    fields: [trait_method.name.clone()],
                }, span);
            }
        }

        // Check required associated types
        for assoc_type in &trait_info.assoc_types {
            match assoc_type.default {
                Some(_) => continue, // Has default, not required
                None => {}
            }
            let mut provided = false;
            for (name, _) in impl_assoc_types {
                if *name == assoc_type.name {
                    provided = true;
                    break;
                }
            }
            if !provided {
                self.error(TypeErrorKind::MissingFields {
                    ty_name: trait_info.name.clone(),
                    fields: [assoc_type.name.clone()],
                }, span);
            }
        }
    }

    /// Check supertrait obligations: if type implements trait T,
    /// and T has supertraits S1, S2, then type must also implement S1 and S2.
    fn check_supertrait_obligations(
        &mut self,
        ty: &Type,
        trait_id: &DefId,
        span: Span,
    ) {
        let supertraits = match self.get_trait(trait_id) {
            Some(info) => info.supertraits.clone(),
            None => return,
        };

        for supertrait_id in &supertraits {
            if !self.type_implements_trait(ty, supertrait_id) {
                let trait_name = match self.get_trait(trait_id) {
                    Some(info) => info.name.clone(),
                    None => "?".to_string(),
                };
                let super_name = match self.get_trait(supertrait_id) {
                    Some(info) => info.name.clone(),
                    None => "?".to_string(),
                };
                self.error(TypeErrorKind::UnsupportedFeature {
                    feature: format!("{} requires supertrait {} but {} does not implement it",
                        trait_name, super_name,
                        TraitResolver::new(self).type_name(ty)),
                }, span);
            }
            // Recursively check supertraits of supertraits
            self.check_supertrait_obligations(ty, supertrait_id, span);
        }
    }

    /// Resolve a method call on a type, reporting errors.
    fn resolve_method_call(
        &mut self,
        receiver_ty: &Type,
        method_name: &str,
        arg_types: &[Type],
        span: Span,
    ) -> Option<MethodCandidate> {
        let resolver = TraitResolver::new(self);
        match resolver.resolve_method(receiver_ty, method_name, arg_types) {
            MethodResolution::Resolved(candidate) => Some(candidate),
            MethodResolution::NoMatch { ty_name, method_name } => {
                self.error(TypeErrorKind::NoMatchingMethod {
                    ty_name,
                    method: method_name,
                }, span);
                None
            }
            MethodResolution::Ambiguous { method_name, candidates } => {
                self.error(TypeErrorKind::AmbiguousMethod {
                    method: method_name,
                    candidates,
                }, span);
                None
            }
        }
    }
}

// ============================================================
// Public API
// ============================================================

/// Type-check a parsed Blood program.
///
/// Returns the TypeContext with all type information, or a list of errors.
fn check_program(program: &Program) -> Result<TypeContext, [TypeError]> {
    let mut ctx = TypeContext::new();

    // Phase 1: Collect all declarations (forward reference support)
    // TODO: implement collect_declarations(&mut ctx, program)

    // Phase 2: Check all function bodies
    // TODO: implement check_all_bodies(&mut ctx)

    // Phase 3: Linearity checking
    // TODO: implement check_linearity(&ctx)

    if ctx.errors.is_empty() {
        Ok(ctx)
    } else {
        Err(ctx.errors)
    }
}
