/// Blood Type Checker - Third step toward self-hosting
///
/// This module implements the type checking and inference engine for Blood,
/// using a bidirectional Hindley-Milner type system extended with:
/// - Effect row polymorphism (from Koka)
/// - Linear and affine types
/// - Record row polymorphism
/// - Trait-based dispatch
///
/// Part of Phase 6: Self-Hosting.

use std.compiler.parser::{
    Program, Declaration, FnDecl, StructDecl, EnumDecl, TraitDecl,
    ImplBlock, EffectDecl, HandlerDecl, TypeDecl, ConstDecl, StaticDecl,
    Expr, ExprKind, Pattern, PatternKind, Block, Statement,
    Type as AstType, TypeKind as AstTypeKind, TypePath, TypeArgs,
    BinOp, UnaryOp, Literal, LiteralKind,
    Span, Spanned, Visibility,
};

// ============================================================
// Definition IDs
// ============================================================

/// Unique identifier for any named definition (function, type, etc.)
struct DefId {
    module: u32,
    local: u32,
}

impl DefId {
    fn new(module: u32, local: u32) -> DefId {
        DefId { module, local }
    }
}

/// Unique identifier for a type variable (used during inference)
struct TyVarId {
    id: u32,
}

impl TyVarId {
    fn new(id: u32) -> TyVarId {
        TyVarId { id }
    }
}

/// Unique identifier for a record row variable (row polymorphism)
struct RecordRowVarId {
    id: u32,
}

/// Unique identifier for a type-checked body
struct BodyId {
    id: u32,
}

// ============================================================
// Type Representation
// ============================================================

/// Core type representation used throughout type checking.
/// This is the internal type, distinct from the parser's AST Type.
struct Type {
    kind: TypeKind,
}

/// Primitive types
enum PrimitiveTy {
    Bool,
    I8, I16, I32, I64, I128, Isize,
    U8, U16, U32, U64, U128, Usize,
    F32, F64,
    Char,
    Str,
    Unit,
}

/// The kind of a type
enum TypeKind {
    /// Primitive type: `i32`, `bool`, `()`, etc.
    Primitive(PrimitiveTy),
    /// Type variable for inference: `?T`
    Infer(TyVarId),
    /// Forall-bound type parameter: `T` in `fn<T>(x: T) -> T`
    Param(TyVarId),
    /// Function type: `fn(T, U) -> V / {E}`
    Fn { params: [Type], ret: Box<Type>, effects: EffectRow },
    /// Closure type (anonymous function with captures)
    Closure { def_id: DefId, params: [Type], ret: Box<Type> },
    /// Algebraic data type (struct or enum): `Vec<i32>`, `Option<T>`
    Adt { def_id: DefId, args: [Type] },
    /// Tuple type: `(T, U, V)`
    Tuple([Type]),
    /// Array type with compile-time known size: `[T; N]`
    Array { element: Box<Type>, size: u64 },
    /// Slice type: `[T]`
    Slice { element: Box<Type> },
    /// Reference type: `&T` or `&mut T`
    Ref { inner: Box<Type>, mutable: bool },
    /// Pointer type: `*const T` or `*mut T`
    Ptr { inner: Box<Type>, mutable: bool },
    /// Record type with row polymorphism: `{ x: i32, y: bool | R }`
    Record { fields: [RecordField], row_var: Option<RecordRowVarId> },
    /// Universally quantified type: `forall<T>. T -> T`
    Forall { params: [TyVarId], body: Box<Type> },
    /// Range type
    Range { element: Box<Type>, inclusive: bool },
    /// Dynamic trait object: `dyn Trait`
    DynTrait { trait_id: DefId },
    /// Ownership qualifier: `linear T` or `affine T`
    Ownership { qualifier: OwnershipQualifier, inner: Box<Type> },
    /// The never/bottom type: `!`
    Never,
    /// Error type (for error recovery — unifies with anything)
    Error,
}

struct RecordField {
    name: String,
    ty: Type,
}

enum OwnershipQualifier {
    Linear,
    Affine,
}

// ============================================================
// Effect Row Types
// ============================================================

/// Effect row for tracking computational effects
struct EffectRow {
    kind: EffectRowKind,
}

enum EffectRowKind {
    /// Pure computation (no effects)
    Pure,
    /// Closed set of effects: `{IO, Error<E>}`
    Closed { effects: [EffectEntry] },
    /// Open row with rest variable: `{IO | e}`
    Open { effects: [EffectEntry], rest: TyVarId },
    /// Row variable: `e`
    Var(TyVarId),
}

struct EffectEntry {
    effect_id: DefId,
    type_args: [Type],
}

// ============================================================
// Type Scheme (Polymorphic Types)
// ============================================================

/// A polymorphic type scheme: `forall a b. a -> b -> a`
struct TypeScheme {
    /// Bound type variables
    params: [TyVarId],
    /// The body type (may reference params)
    body: Type,
    /// Trait bounds on type variables
    bounds: [TypeBound],
}

struct TypeBound {
    var: TyVarId,
    trait_id: DefId,
    type_args: [Type],
}

// ============================================================
// Function Signatures
// ============================================================

struct FnSig {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    params: [ParamInfo],
    return_type: Type,
    effects: EffectRow,
    where_clause: [WherePredicate],
    is_unsafe: bool,
    span: Span,
}

struct TypeParamInfo {
    name: String,
    var_id: TyVarId,
    bounds: [Type],
}

struct ParamInfo {
    name: String,
    ty: Type,
    qualifier: Option<OwnershipQualifier>,
}

struct WherePredicate {
    ty: Type,
    bounds: [Type],
}

// ============================================================
// Type Definitions
// ============================================================

struct StructInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    fields: [FieldInfo],
    vis: Visibility,
    span: Span,
}

struct FieldInfo {
    name: String,
    ty: Type,
    vis: Visibility,
}

struct EnumInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    variants: [VariantInfo],
    vis: Visibility,
    span: Span,
}

struct VariantInfo {
    name: String,
    fields: [FieldInfo],
    /// Discriminant value (auto-assigned if not explicit)
    discriminant: Option<i64>,
}

// ============================================================
// Trait & Impl Definitions
// ============================================================

struct TraitInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    supertraits: [DefId],
    methods: [FnSig],
    assoc_types: [AssocTypeInfo],
    assoc_consts: [AssocConstInfo],
    span: Span,
}

struct AssocTypeInfo {
    name: String,
    bounds: [Type],
    default: Option<Type>,
}

struct AssocConstInfo {
    name: String,
    ty: Type,
    default: Option<DefId>,
}

struct ImplBlockInfo {
    def_id: DefId,
    type_params: [TypeParamInfo],
    self_ty: Type,
    trait_ref: Option<TraitRef>,
    methods: [FnSig],
    assoc_types: [(String, Type)],
    where_clause: [WherePredicate],
    span: Span,
}

struct TraitRef {
    trait_id: DefId,
    type_args: [Type],
}

// ============================================================
// Effect & Handler Definitions
// ============================================================

struct EffectInfo {
    def_id: DefId,
    name: String,
    type_params: [TypeParamInfo],
    operations: [OperationInfo],
    span: Span,
}

struct OperationInfo {
    name: String,
    params: [ParamInfo],
    return_type: Type,
}

struct HandlerInfo {
    def_id: DefId,
    name: String,
    kind: HandlerKindTy,
    type_params: [TypeParamInfo],
    effect_ref: TraitRef,
    state_vars: [StateVarInfo],
    operations: [HandlerOpInfo],
    return_clause: Option<ReturnClauseInfo>,
    span: Span,
}

enum HandlerKindTy {
    Deep,
    Shallow,
}

struct StateVarInfo {
    name: String,
    ty: Type,
    is_mut: bool,
    default: Option<DefId>,
}

struct HandlerOpInfo {
    name: String,
    params: [String],
    body_id: BodyId,
}

struct ReturnClauseInfo {
    param_name: String,
    body_id: BodyId,
}

// ============================================================
// Type Error
// ============================================================

struct TypeError {
    kind: TypeErrorKind,
    span: Span,
}

enum TypeErrorKind {
    /// Type mismatch: expected `T`, found `U`
    Mismatch { expected: Type, found: Type },
    /// Infinite type: `?T` occurs in `T`
    InfiniteType { var: TyVarId, ty: Type },
    /// Unknown name
    UnknownName { name: String },
    /// Duplicate definition
    DuplicateDefinition { name: String },
    /// Expression is not callable
    NotAFunction { ty: Type },
    /// Argument count mismatch
    ArgCountMismatch { expected: u32, found: u32 },
    /// Unknown struct/enum field
    UnknownField { ty_name: String, field: String },
    /// Missing struct fields
    MissingFields { ty_name: String, fields: [String] },
    /// Not an effect
    NotAnEffect { name: String },
    /// Effect not handled
    UnhandledEffect { effect: String },
    /// No method found
    NoMatchingMethod { ty_name: String, method: String },
    /// Ambiguous method
    AmbiguousMethod { method: String, candidates: [String] },
    /// Non-exhaustive match
    NonExhaustiveMatch { missing: [String] },
    /// Unreachable pattern
    UnreachablePattern,
    /// Linear type not consumed
    LinearNotConsumed { name: String, ty: Type },
    /// Linear type used more than once
    LinearUsedMultiple { name: String, ty: Type },
    /// Affine type used more than once
    AffineUsedMultiple { name: String, ty: Type },
    /// Feature not yet supported
    UnsupportedFeature { feature: String },
}

// ============================================================
// Unifier (Type Variable Substitutions)
// ============================================================

/// The Unifier manages type variable bindings and performs unification.
///
/// Unification determines if two types can be made equal by substituting
/// type variables, following the Hindley-Milner algorithm.
struct Unifier {
    /// Map from type variable to its binding
    substitutions: [(TyVarId, Type)],
    /// Next fresh variable ID
    next_var: u32,
    /// Row variable substitutions for record types
    row_substitutions: [(RecordRowVarId, [RecordField])],
    /// Next fresh row variable ID
    next_row_var: u32,
}

impl Unifier {
    fn new() -> Unifier {
        Unifier {
            substitutions: [],
            next_var: 0,
            row_substitutions: [],
            next_row_var: 0,
        }
    }

    /// Generate a fresh type variable
    fn fresh_var(&mut self) -> Type {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        Type { kind: TypeKind::Infer(id) }
    }

    /// Generate N fresh type variables
    fn fresh_vars(&mut self, n: u32) -> [Type] {
        let mut vars = [];
        let mut i: u32 = 0;
        while i < n {
            vars.push(self.fresh_var());
            i = i + 1;
        }
        vars
    }

    /// Generate a fresh forall-bound type parameter
    fn fresh_param(&mut self) -> TyVarId {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        id
    }

    /// Resolve a type by following substitution chains
    fn resolve(&self, ty: &Type) -> Type {
        match ty.kind {
            TypeKind::Infer(var) => {
                // Look up substitution
                for (v, bound_ty) in &self.substitutions {
                    if v.id == var.id {
                        // Recursively resolve (follow chain)
                        return self.resolve(bound_ty);
                    }
                }
                // No substitution found — return as-is
                Type { kind: TypeKind::Infer(var) }
            }
            _ => ty.clone(),
        }
    }

    /// Bind a type variable to a type (after occurs check)
    fn bind(&mut self, var: TyVarId, ty: &Type, span: Span) -> Result<(), TypeError> {
        // Occurs check: prevent infinite types like ?T = List<?T>
        if self.occurs_in(var, ty) {
            return Err(TypeError {
                kind: TypeErrorKind::InfiniteType { var, ty: ty.clone() },
                span,
            });
        }
        self.substitutions.push((var, ty.clone()));
        Ok(())
    }

    /// Check if a type variable occurs within a type (prevents infinite types)
    fn occurs_in(&self, var: TyVarId, ty: &Type) -> bool {
        let resolved = self.resolve(ty);
        match resolved.kind {
            TypeKind::Infer(other) => var.id == other.id,
            TypeKind::Param(other) => var.id == other.id,
            TypeKind::Fn { params, ret, .. } => {
                for p in &params {
                    if self.occurs_in(var, p) {
                        return true;
                    }
                }
                self.occurs_in(var, &ret)
            }
            TypeKind::Adt { args, .. } => {
                for a in &args {
                    if self.occurs_in(var, a) {
                        return true;
                    }
                }
                false
            }
            TypeKind::Tuple(elems) => {
                for e in &elems {
                    if self.occurs_in(var, e) {
                        return true;
                    }
                }
                false
            }
            TypeKind::Array { element, .. } => self.occurs_in(var, &element),
            TypeKind::Slice { element } => self.occurs_in(var, &element),
            TypeKind::Ref { inner, .. } => self.occurs_in(var, &inner),
            TypeKind::Ptr { inner, .. } => self.occurs_in(var, &inner),
            TypeKind::Forall { body, .. } => self.occurs_in(var, &body),
            TypeKind::Ownership { inner, .. } => self.occurs_in(var, &inner),
            TypeKind::Record { fields, .. } => {
                for f in &fields {
                    if self.occurs_in(var, &f.ty) {
                        return true;
                    }
                }
                false
            }
            _ => false,
        }
    }

    /// Unify two types, making them equal by binding type variables.
    /// Returns Ok(()) on success, Err(TypeError) on mismatch.
    fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        let r1 = self.resolve(t1);
        let r2 = self.resolve(t2);

        match (&r1.kind, &r2.kind) {
            // Identity: same primitive
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => {
                if p1 == p2 {
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Type variable: bind to concrete type
            (TypeKind::Infer(v), _) => self.bind(*v, &r2, span),
            (_, TypeKind::Infer(v)) => self.bind(*v, &r1, span),

            // Type parameters: must be identical
            (TypeKind::Param(p1), TypeKind::Param(p2)) => {
                if p1.id == p2.id {
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // ADT: same def + unify args
            (TypeKind::Adt { def_id: d1, args: a1 }, TypeKind::Adt { def_id: d2, args: a2 }) => {
                if d1.module == d2.module && d1.local == d2.local && a1.len() == a2.len() {
                    let mut i: usize = 0;
                    while i < a1.len() {
                        self.unify(&a1[i], &a2[i], span)?;
                        i = i + 1;
                    }
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Tuple: same length + unify elements
            (TypeKind::Tuple(ts1), TypeKind::Tuple(ts2)) => {
                if ts1.len() == ts2.len() {
                    let mut i: usize = 0;
                    while i < ts1.len() {
                        self.unify(&ts1[i], &ts2[i], span)?;
                        i = i + 1;
                    }
                    Ok(())
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Function: same arity + unify params + unify return
            (TypeKind::Fn { params: p1, ret: ret1, .. },
             TypeKind::Fn { params: p2, ret: ret2, .. }) => {
                if p1.len() == p2.len() {
                    let mut i: usize = 0;
                    while i < p1.len() {
                        self.unify(&p1[i], &p2[i], span)?;
                        i = i + 1;
                    }
                    self.unify(&ret1, &ret2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Array: same size + unify element
            (TypeKind::Array { element: e1, size: s1 },
             TypeKind::Array { element: e2, size: s2 }) => {
                if s1 == s2 {
                    self.unify(&e1, &e2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Slice: unify element
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.unify(&e1, &e2, span)
            }

            // Reference: same mutability + unify inner
            (TypeKind::Ref { inner: i1, mutable: m1 },
             TypeKind::Ref { inner: i2, mutable: m2 }) => {
                if m1 == m2 {
                    self.unify(&i1, &i2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Pointer: same mutability + unify inner
            (TypeKind::Ptr { inner: i1, mutable: m1 },
             TypeKind::Ptr { inner: i2, mutable: m2 }) => {
                if m1 == m2 {
                    self.unify(&i1, &i2, span)
                } else {
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Ownership: same qualifier + unify inner
            (TypeKind::Ownership { qualifier: q1, inner: i1 },
             TypeKind::Ownership { qualifier: q2, inner: i2 }) => {
                if q1 == q2 {
                    self.unify(&i1, &i2, span)
                } else {
                    // Affine subsumes linear
                    Err(TypeError {
                        kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                        span,
                    })
                }
            }

            // Never type unifies with anything
            (TypeKind::Never, _) => Ok(()),
            (_, TypeKind::Never) => Ok(()),

            // Error type unifies with anything (for error recovery)
            (TypeKind::Error, _) => Ok(()),
            (_, TypeKind::Error) => Ok(()),

            // Mismatch
            _ => Err(TypeError {
                kind: TypeErrorKind::Mismatch { expected: r1.clone(), found: r2.clone() },
                span,
            }),
        }
    }

    /// Apply all substitutions to resolve a type completely ("zonking")
    fn zonk(&self, ty: &Type) -> Type {
        match ty.kind {
            TypeKind::Infer(var) => {
                let resolved = self.resolve(ty);
                match resolved.kind {
                    TypeKind::Infer(_) => resolved,
                    _ => self.zonk(&resolved),
                }
            }
            TypeKind::Fn { params, ret, effects } => {
                let mut zonked_params = [];
                for p in &params {
                    zonked_params.push(self.zonk(p));
                }
                Type {
                    kind: TypeKind::Fn {
                        params: zonked_params,
                        ret: Box::new(self.zonk(&ret)),
                        effects,
                    },
                }
            }
            TypeKind::Adt { def_id, args } => {
                let mut zonked_args = [];
                for a in &args {
                    zonked_args.push(self.zonk(a));
                }
                Type { kind: TypeKind::Adt { def_id, args: zonked_args } }
            }
            TypeKind::Tuple(elems) => {
                let mut zonked = [];
                for e in &elems {
                    zonked.push(self.zonk(e));
                }
                Type { kind: TypeKind::Tuple(zonked) }
            }
            TypeKind::Array { element, size } => {
                Type { kind: TypeKind::Array { element: Box::new(self.zonk(&element)), size } }
            }
            TypeKind::Slice { element } => {
                Type { kind: TypeKind::Slice { element: Box::new(self.zonk(&element)) } }
            }
            TypeKind::Ref { inner, mutable } => {
                Type { kind: TypeKind::Ref { inner: Box::new(self.zonk(&inner)), mutable } }
            }
            TypeKind::Ptr { inner, mutable } => {
                Type { kind: TypeKind::Ptr { inner: Box::new(self.zonk(&inner)), mutable } }
            }
            TypeKind::Forall { params, body } => {
                Type { kind: TypeKind::Forall { params, body: Box::new(self.zonk(&body)) } }
            }
            TypeKind::Ownership { qualifier, inner } => {
                Type { kind: TypeKind::Ownership { qualifier, inner: Box::new(self.zonk(&inner)) } }
            }
            TypeKind::Record { fields, row_var } => {
                let mut zonked_fields = [];
                for f in &fields {
                    zonked_fields.push(RecordField { name: f.name.clone(), ty: self.zonk(&f.ty) });
                }
                Type { kind: TypeKind::Record { fields: zonked_fields, row_var } }
            }
            _ => ty.clone(),
        }
    }
}

// ============================================================
// Name Resolution Scope
// ============================================================

enum ScopeKind {
    Module,
    Function,
    Block,
    Handler,
    Loop,
}

struct Binding {
    name: String,
    def_id: DefId,
    ty: Type,
    is_mutable: bool,
}

struct Scope {
    kind: ScopeKind,
    bindings: [Binding],
    type_bindings: [(String, DefId)],
}

struct Resolver {
    scopes: [Scope],
    next_def_id: u32,
    module_id: u32,
}

impl Resolver {
    fn new(module_id: u32) -> Resolver {
        Resolver {
            scopes: [Scope { kind: ScopeKind::Module, bindings: [], type_bindings: [] }],
            next_def_id: 0,
            module_id,
        }
    }

    /// Allocate a fresh DefId
    fn fresh_def_id(&mut self) -> DefId {
        let id = DefId::new(self.module_id, self.next_def_id);
        self.next_def_id = self.next_def_id + 1;
        id
    }

    /// Push a new scope
    fn push_scope(&mut self, kind: ScopeKind) {
        self.scopes.push(Scope { kind, bindings: [], type_bindings: [] });
    }

    /// Pop the current scope
    fn pop_scope(&mut self) {
        self.scopes.pop();
    }

    /// Add a value binding to the current scope
    fn add_binding(&mut self, name: String, def_id: DefId, ty: Type, is_mutable: bool) {
        let scope = &mut self.scopes[self.scopes.len() - 1];
        scope.bindings.push(Binding { name, def_id, ty, is_mutable });
    }

    /// Add a type binding to the current scope
    fn add_type_binding(&mut self, name: String, def_id: DefId) {
        let scope = &mut self.scopes[self.scopes.len() - 1];
        scope.type_bindings.push((name, def_id));
    }

    /// Look up a value binding by name (searches from innermost scope outward)
    fn lookup_value(&self, name: &str) -> Option<&Binding> {
        let mut i = self.scopes.len();
        while i > 0 {
            i = i - 1;
            for binding in &self.scopes[i].bindings {
                if binding.name == name {
                    return Some(binding);
                }
            }
        }
        None
    }

    /// Look up a type binding by name
    fn lookup_type(&self, name: &str) -> Option<DefId> {
        let mut i = self.scopes.len();
        while i > 0 {
            i = i - 1;
            for (n, def_id) in &self.scopes[i].type_bindings {
                if n == name {
                    return Some(*def_id);
                }
            }
        }
        None
    }
}

// ============================================================
// Type Context (Main State)
// ============================================================

/// The main type checking state. Holds all type information,
/// the unifier, the resolver, and the type-checked bodies.
struct TypeContext {
    /// Unification engine
    unifier: Unifier,
    /// Name resolution
    resolver: Resolver,

    /// Function signatures
    fn_sigs: [(DefId, FnSig)],
    /// Struct definitions
    struct_defs: [(DefId, StructInfo)],
    /// Enum definitions
    enum_defs: [(DefId, EnumInfo)],
    /// Trait definitions
    trait_defs: [(DefId, TraitInfo)],
    /// Impl blocks
    impl_blocks: [ImplBlockInfo],
    /// Effect definitions
    effect_defs: [(DefId, EffectInfo)],
    /// Handler definitions
    handler_defs: [(DefId, HandlerInfo)],
    /// Type alias definitions
    type_aliases: [(DefId, Type)],

    /// Current function being checked
    current_fn: Option<DefId>,
    /// Expected return type of current function
    return_type: Option<Type>,
    /// Effect handler stack
    handled_effects: [(DefId, [Type])],

    /// Accumulated errors
    errors: [TypeError],
}

impl TypeContext {
    fn new() -> TypeContext {
        TypeContext {
            unifier: Unifier::new(),
            resolver: Resolver::new(0),
            fn_sigs: [],
            struct_defs: [],
            enum_defs: [],
            trait_defs: [],
            impl_blocks: [],
            effect_defs: [],
            handler_defs: [],
            type_aliases: [],
            current_fn: None,
            return_type: None,
            handled_effects: [],
            errors: [],
        }
    }

    /// Report a type error
    fn error(&mut self, kind: TypeErrorKind, span: Span) {
        self.errors.push(TypeError { kind, span });
    }

    /// Create the unit type `()`
    fn unit_type(&self) -> Type {
        Type { kind: TypeKind::Primitive(PrimitiveTy::Unit) }
    }

    /// Create the bool type
    fn bool_type(&self) -> Type {
        Type { kind: TypeKind::Primitive(PrimitiveTy::Bool) }
    }

    /// Create the i32 type
    fn i32_type(&self) -> Type {
        Type { kind: TypeKind::Primitive(PrimitiveTy::I32) }
    }

    /// Create the error type (for recovery)
    fn error_type(&self) -> Type {
        Type { kind: TypeKind::Error }
    }

    /// Create a fresh type variable
    fn fresh_var(&mut self) -> Type {
        self.unifier.fresh_var()
    }

    /// Look up a struct by DefId
    fn get_struct(&self, def_id: &DefId) -> Option<&StructInfo> {
        for (id, info) in &self.struct_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up an enum by DefId
    fn get_enum(&self, def_id: &DefId) -> Option<&EnumInfo> {
        for (id, info) in &self.enum_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }

    /// Look up a function signature by DefId
    fn get_fn_sig(&self, def_id: &DefId) -> Option<&FnSig> {
        for (id, sig) in &self.fn_sigs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(sig);
            }
        }
        None
    }

    /// Look up an effect by DefId
    fn get_effect(&self, def_id: &DefId) -> Option<&EffectInfo> {
        for (id, info) in &self.effect_defs {
            if id.module == def_id.module && id.local == def_id.local {
                return Some(info);
            }
        }
        None
    }
}

// ============================================================
// Primitive Type Resolution
// ============================================================

/// Resolve a type name to a primitive type, if it is one.
fn resolve_primitive(name: &str) -> Option<PrimitiveTy> {
    match name {
        "bool" => Some(PrimitiveTy::Bool),
        "i8" => Some(PrimitiveTy::I8),
        "i16" => Some(PrimitiveTy::I16),
        "i32" => Some(PrimitiveTy::I32),
        "i64" => Some(PrimitiveTy::I64),
        "i128" => Some(PrimitiveTy::I128),
        "isize" => Some(PrimitiveTy::Isize),
        "u8" => Some(PrimitiveTy::U8),
        "u16" => Some(PrimitiveTy::U16),
        "u32" => Some(PrimitiveTy::U32),
        "u64" => Some(PrimitiveTy::U64),
        "u128" => Some(PrimitiveTy::U128),
        "usize" => Some(PrimitiveTy::Usize),
        "f32" => Some(PrimitiveTy::F32),
        "f64" => Some(PrimitiveTy::F64),
        "char" => Some(PrimitiveTy::Char),
        "str" => Some(PrimitiveTy::Str),
        _ => None,
    }
}

// ============================================================
// Public API
// ============================================================

/// Type-check a parsed Blood program.
///
/// Returns the TypeContext with all type information, or a list of errors.
fn check_program(program: &Program) -> Result<TypeContext, [TypeError]> {
    let mut ctx = TypeContext::new();

    // Phase 1: Collect all declarations (forward reference support)
    // TODO: implement collect_declarations(&mut ctx, program)

    // Phase 2: Check all function bodies
    // TODO: implement check_all_bodies(&mut ctx)

    // Phase 3: Linearity checking
    // TODO: implement check_linearity(&ctx)

    if ctx.errors.is_empty() {
        Ok(ctx)
    } else {
        Err(ctx.errors)
    }
}
