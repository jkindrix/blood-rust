// Blood Standard Library - Box Type
//
// Box<T> is a heap-allocated smart pointer with unique ownership.
// Uses Blood's 128-bit generational pointer system for memory safety.

/// Heap-allocated value with unique ownership
pub struct Box<T> {
    /// Internal pointer (128-bit generational pointer)
    ptr: BloodPtr<T>,
}

impl<T> Box<T> {
    /// Allocates memory on the heap and places x into it
    pub fn new(x: T) -> Box<T> / pure {
        let ptr = mem::alloc::<T>();
        mem::write(ptr, x);
        Box { ptr }
    }

    /// Constructs a box from a raw pointer
    ///
    /// # Safety
    /// The pointer must have been allocated by Box and not freed
    pub unsafe fn from_raw(raw: BloodPtr<T>) -> Box<T> / pure {
        Box { ptr: raw }
    }

    /// Consumes the Box, returning the raw pointer
    ///
    /// After calling this function, the caller is responsible for
    /// freeing the memory
    pub fn into_raw(b: Box<T>) -> BloodPtr<T> / pure {
        let ptr = b.ptr;
        mem::forget(b);
        ptr
    }

    /// Consumes the Box, returning the wrapped value
    pub fn into_inner(self: Self) -> T / pure {
        let val = mem::read(self.ptr);
        mem::dealloc(self.ptr);
        mem::forget(self);
        val
    }

    /// Returns a reference to the contained value
    pub fn as_ref(self: &Self) -> &T / pure {
        unsafe { &*self.ptr }
    }

    /// Returns a mutable reference to the contained value
    pub fn as_mut(self: &mut Self) -> &mut T / pure {
        unsafe { &mut *self.ptr }
    }

    /// Leaks the Box, returning a mutable reference with 'static lifetime
    pub fn leak(b: Box<T>) -> &'static mut T / pure {
        let ptr = Box::into_raw(b);
        unsafe { &mut *ptr }
    }
}

impl<T: Default> Box<T> {
    /// Creates a new Box with the default value for T
    pub fn default() -> Box<T> / pure {
        Box::new(T::default())
    }
}

impl<T: Clone> Box<T> {
    /// Creates a new Box by cloning the contents
    pub fn clone(self: &Self) -> Box<T> / pure {
        Box::new((*self).clone())
    }
}

impl<T> Deref for Box<T> {
    type Target = T;

    fn deref(self: &Self) -> &T / pure {
        self.as_ref()
    }
}

impl<T> DerefMut for Box<T> {
    fn deref_mut(self: &mut Self) -> &mut T / pure {
        self.as_mut()
    }
}

impl<T> Drop for Box<T> {
    fn drop(self: &mut Self) / pure {
        unsafe {
            // Drop the contained value
            mem::drop_in_place(self.ptr);
            // Deallocate the memory
            mem::dealloc(self.ptr);
        }
    }
}

impl<T: Clone> Clone for Box<T> {
    fn clone(self: &Self) -> Self / pure {
        Box::new((**self).clone())
    }
}

impl<T: PartialEq> PartialEq for Box<T> {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        **self == **other
    }
}

impl<T: Eq> Eq for Box<T> {}

impl<T: PartialOrd> PartialOrd for Box<T> {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        (**self).partial_cmp(&**other)
    }
}

impl<T: Ord> Ord for Box<T> {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        (**self).cmp(&**other)
    }
}

impl<T: Debug> Debug for Box<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        (**self).fmt(f)
    }
}

impl<T: Display> Display for Box<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        (**self).fmt(f)
    }
}

impl<T: Default> Default for Box<T> {
    fn default() -> Self / pure {
        Box::new(T::default())
    }
}

impl<T> From<T> for Box<T> {
    fn from(val: T) -> Self / pure {
        Box::new(val)
    }
}

impl<T: Iterator> Iterator for Box<T> {
    type Item = T::Item;

    fn next(self: &mut Self) -> Option<Self::Item> / pure {
        (**self).next()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (**self).size_hint()
    }
}

/// Pinned box for self-referential structures
pub struct Pin<P> {
    pointer: P,
}

impl<T> Pin<Box<T>> {
    /// Constructs a new Pin<Box<T>>
    pub fn new(x: T) -> Pin<Box<T>> / pure {
        Pin { pointer: Box::new(x) }
    }

    /// Gets a pinned shared reference
    pub fn as_ref(self: &Self) -> Pin<&T> / pure {
        Pin { pointer: &*self.pointer }
    }

    /// Gets a pinned mutable reference
    pub fn as_mut(self: &mut Self) -> Pin<&mut T> / pure {
        Pin { pointer: &mut *self.pointer }
    }

    /// Unwraps the pinned box
    ///
    /// # Safety
    /// The caller must ensure T is Unpin or will not be moved
    pub unsafe fn into_inner(self: Self) -> Box<T> / pure {
        self.pointer
    }
}
