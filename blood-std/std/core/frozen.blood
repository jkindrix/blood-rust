// Blood Standard Library - Frozen Type
//
// Frozen<T> represents an immutable, deeply frozen value.
// Once frozen, neither the wrapper nor any interior content can be mutated.

/// Immutable wrapper that guarantees deep immutability
///
/// A Frozen<T> value cannot be mutated, and provides only shared references
/// to its contents. This is useful for values that should be treated as
/// constants after creation.
pub struct Frozen<T> {
    /// The frozen value
    value: T,
}

impl<T> Frozen<T> {
    /// Creates a new frozen value
    ///
    /// After creation, the value cannot be mutated.
    pub fn new(value: T) -> Frozen<T> / pure {
        Frozen { value }
    }

    /// Returns a reference to the frozen value
    pub fn get(self: &Self) -> &T / pure {
        &self.value
    }

    /// Consumes the Frozen, returning the inner value
    ///
    /// The returned value is no longer frozen and can be mutated.
    pub fn into_inner(self: Self) -> T / pure {
        self.value
    }

    /// Maps the frozen value to a new frozen value
    pub fn map<U, F>(self: Self, f: F) -> Frozen<U> / pure
    where
        F: FnOnce(T) -> U,
    {
        Frozen::new(f(self.value))
    }

    /// Maps the frozen value by reference
    pub fn map_ref<U, F>(self: &Self, f: F) -> Frozen<U> / pure
    where
        F: FnOnce(&T) -> U,
    {
        Frozen::new(f(&self.value))
    }
}

impl<T: Clone> Frozen<T> {
    /// Creates a clone of the inner value (not frozen)
    pub fn clone_inner(self: &Self) -> T / pure {
        self.value.clone()
    }

    /// Creates a new Frozen by cloning the inner value
    pub fn clone(self: &Self) -> Frozen<T> / pure {
        Frozen::new(self.value.clone())
    }
}

impl<T: Clone> Clone for Frozen<T> {
    fn clone(self: &Self) -> Self / pure {
        Frozen::new(self.value.clone())
    }
}

impl<T: PartialEq> PartialEq for Frozen<T> {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        self.value == other.value
    }
}

impl<T: PartialEq> PartialEq<T> for Frozen<T> {
    fn eq(self: &Self, other: &T) -> bool / pure {
        self.value == *other
    }
}

impl<T: Eq> Eq for Frozen<T> {}

impl<T: PartialOrd> PartialOrd for Frozen<T> {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        self.value.partial_cmp(&other.value)
    }
}

impl<T: Ord> Ord for Frozen<T> {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        self.value.cmp(&other.value)
    }
}

impl<T: Hash> Hash for Frozen<T> {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        self.value.hash(state);
    }
}

impl<T: Debug> Debug for Frozen<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("Frozen(")?;
        self.value.fmt(f)?;
        f.write_str(")")
    }
}

impl<T: Display> Display for Frozen<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        self.value.fmt(f)
    }
}

impl<T: Default> Default for Frozen<T> {
    fn default() -> Self / pure {
        Frozen::new(T::default())
    }
}

impl<T> From<T> for Frozen<T> {
    fn from(value: T) -> Self / pure {
        Frozen::new(value)
    }
}

impl<T> Deref for Frozen<T> {
    type Target = T;

    fn deref(self: &Self) -> &T / pure {
        &self.value
    }
}

// Note: DerefMut is intentionally NOT implemented to preserve immutability

impl<T> AsRef<T> for Frozen<T> {
    fn as_ref(self: &Self) -> &T / pure {
        &self.value
    }
}

impl<T: Borrow<U>, U: ?Sized> Borrow<U> for Frozen<T> {
    fn borrow(self: &Self) -> &U / pure {
        self.value.borrow()
    }
}

/// Extension trait for freezing values
pub trait Freeze: Sized {
    /// Wraps the value in a Frozen container
    fn freeze(self: Self) -> Frozen<Self> / pure {
        Frozen::new(self)
    }
}

// Implement Freeze for all types
impl<T> Freeze for T {}

/// Creates a Frozen value in-place
///
/// # Example
/// ```
/// let frozen_vec = frozen![1, 2, 3, 4, 5];
/// ```
#[macro_export]
macro_rules! frozen {
    ($expr:expr) => {
        Frozen::new($expr)
    };
}
