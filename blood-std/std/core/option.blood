// Blood Standard Library - Option Type
//
// The Option type represents an optional value: every Option is either
// Some and contains a value, or None, and does not.

/// Optional value type - either Some(T) or None
/// NOTE: None must be declared first (variant 0) to match the runtime's expectation
/// that tag=0 means None and tag=1 means Some.
pub enum Option<T> {
    /// No value present
    None,
    /// Contains a value
    Some(T),
}

impl<T> Option<T> {
    /// Returns true if the option is a Some value
    pub fn is_some(self: &Self) -> bool / pure {
        match self {
            Some(_) => true,
            None => false,
        }
    }

    /// Returns true if the option is a None value
    pub fn is_none(self: &Self) -> bool / pure {
        match self {
            Some(_) => false,
            None => true,
        }
    }

    /// Returns the contained Some value, consuming self
    /// Panics if the option is None with the provided message
    pub fn expect(self: Self, msg: &str) -> T / {Panic} {
        match self {
            Some(val) => val,
            None => perform panic(msg),
        }
    }

    /// Returns the contained Some value, consuming self
    /// Panics if the option is None
    pub fn unwrap(self: Self) -> T / {Panic} {
        match self {
            Some(val) => val,
            None => perform panic("called `Option::unwrap()` on a `None` value"),
        }
    }

    /// Returns the contained Some value or a provided default
    pub fn unwrap_or(self: Self, default: T) -> T / pure {
        match self {
            Some(val) => val,
            None => default,
        }
    }

    /// Returns the contained Some value or computes it from a closure
    pub fn unwrap_or_else<F>(self: Self, f: F) -> T / pure
    where
        F: FnOnce() -> T,
    {
        match self {
            Some(val) => val,
            None => f(),
        }
    }

    /// Returns the contained Some value or a default
    pub fn unwrap_or_default(self: Self) -> T / pure
    where
        T: Default,
    {
        match self {
            Some(val) => val,
            None => T::default(),
        }
    }

    /// Maps an Option<T> to Option<U> by applying a function
    pub fn map<U, F>(self: Self, f: F) -> Option<U> / pure
    where
        F: FnOnce(T) -> U,
    {
        match self {
            Some(val) => Some(f(val)),
            None => None,
        }
    }

    /// Applies a function to the contained value (if any)
    pub fn inspect<F>(self: &Self, f: F) -> &Self / pure
    where
        F: FnOnce(&T),
    {
        if let Some(ref val) = self {
            f(val);
        }
        self
    }

    /// Returns the provided default result (if None),
    /// or applies a function to the contained value (if Some)
    pub fn map_or<U, F>(self: Self, default: U, f: F) -> U / pure
    where
        F: FnOnce(T) -> U,
    {
        match self {
            Some(val) => f(val),
            None => default,
        }
    }

    /// Computes a default function result (if None),
    /// or applies a function to the contained value (if Some)
    pub fn map_or_else<U, D, F>(self: Self, default: D, f: F) -> U / pure
    where
        D: FnOnce() -> U,
        F: FnOnce(T) -> U,
    {
        match self {
            Some(val) => f(val),
            None => default(),
        }
    }

    /// Transforms the Option<T> into a Result<T, E>
    pub fn ok_or<E>(self: Self, err: E) -> Result<T, E> / pure {
        match self {
            Some(val) => Ok(val),
            None => Err(err),
        }
    }

    /// Transforms the Option<T> into a Result<T, E> with a lazy error
    pub fn ok_or_else<E, F>(self: Self, err: F) -> Result<T, E> / pure
    where
        F: FnOnce() -> E,
    {
        match self {
            Some(val) => Ok(val),
            None => Err(err()),
        }
    }

    /// Returns None if the option is None, otherwise returns other
    pub fn and<U>(self: Self, other: Option<U>) -> Option<U> / pure {
        match self {
            Some(_) => other,
            None => None,
        }
    }

    /// Returns None if the option is None, otherwise calls f with the
    /// wrapped value and returns the result
    pub fn and_then<U, F>(self: Self, f: F) -> Option<U> / pure
    where
        F: FnOnce(T) -> Option<U>,
    {
        match self {
            Some(val) => f(val),
            None => None,
        }
    }

    /// Returns None if the option is None, otherwise calls predicate
    /// with the wrapped value and returns Some(t) if predicate returns
    /// true, otherwise None
    pub fn filter<P>(self: Self, predicate: P) -> Option<T> / pure
    where
        P: FnOnce(&T) -> bool,
    {
        match self {
            Some(val) if predicate(&val) => Some(val),
            _ => None,
        }
    }

    /// Returns the option if it contains a value, otherwise returns other
    pub fn or(self: Self, other: Option<T>) -> Option<T> / pure {
        match self {
            Some(_) => self,
            None => other,
        }
    }

    /// Returns the option if it contains a value, otherwise calls f
    /// and returns the result
    pub fn or_else<F>(self: Self, f: F) -> Option<T> / pure
    where
        F: FnOnce() -> Option<T>,
    {
        match self {
            Some(_) => self,
            None => f(),
        }
    }

    /// Returns Some if exactly one of self, other is Some, otherwise
    /// returns None
    pub fn xor(self: Self, other: Option<T>) -> Option<T> / pure {
        match (self, other) {
            (Some(val), None) => Some(val),
            (None, Some(val)) => Some(val),
            _ => None,
        }
    }

    /// Converts from &Option<T> to Option<&T>
    pub fn as_ref(self: &Self) -> Option<&T> / pure {
        match self {
            Some(ref val) => Some(val),
            None => None,
        }
    }

    /// Converts from &mut Option<T> to Option<&mut T>
    pub fn as_mut(self: &mut Self) -> Option<&mut T> / pure {
        match self {
            Some(ref mut val) => Some(val),
            None => None,
        }
    }

    /// Takes the value out of the option, leaving a None in its place
    pub fn take(self: &mut Self) -> Option<T> / pure {
        mem::replace(self, None)
    }

    /// Replaces the actual value in the option by the value given
    pub fn replace(self: &mut Self, value: T) -> Option<T> / pure {
        mem::replace(self, Some(value))
    }

    /// Returns an iterator over the possibly contained value
    pub fn iter(self: &Self) -> Iter<T> / pure {
        Iter { inner: self.as_ref() }
    }

    /// Zips self with another Option
    pub fn zip<U>(self: Self, other: Option<U>) -> Option<(T, U)> / pure {
        match (self, other) {
            (Some(a), Some(b)) => Some((a, b)),
            _ => None,
        }
    }

    /// Zips self and another Option with a function
    pub fn zip_with<U, R, F>(self: Self, other: Option<U>, f: F) -> Option<R> / pure
    where
        F: FnOnce(T, U) -> R,
    {
        match (self, other) {
            (Some(a), Some(b)) => Some(f(a, b)),
            _ => None,
        }
    }

    /// Converts from Option<Option<T>> to Option<T>
    pub fn flatten(self: Self) -> Option<T> / pure
    where
        T: Option<U>,
    {
        match self {
            Some(inner) => inner,
            None => None,
        }
    }
}

impl<T: Clone> Option<T> {
    /// Maps an Option<&T> to an Option<T> by cloning
    pub fn cloned(self: &Self) -> Option<T> / pure {
        self.map(|t| t.clone())
    }
}

impl<T: Copy> Option<T> {
    /// Maps an Option<&T> to an Option<T> by copying
    pub fn copied(self: &Self) -> Option<T> / pure {
        self.map(|&t| t)
    }
}

impl<T: Default> Option<T> {
    /// Takes the value from the option and replaces with default
    pub fn take_or_default(self: &mut Self) -> T / pure {
        self.take().unwrap_or_default()
    }
}

impl<T: Clone> Clone for Option<T> {
    fn clone(self: &Self) -> Self / pure {
        match self {
            Some(val) => Some(val.clone()),
            None => None,
        }
    }
}

impl<T: Copy> Copy for Option<T> {}

impl<T: PartialEq> PartialEq for Option<T> {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        match (self, other) {
            (Some(a), Some(b)) => a == b,
            (None, None) => true,
            _ => false,
        }
    }
}

impl<T: Eq> Eq for Option<T> {}

impl<T: PartialOrd> PartialOrd for Option<T> {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        match (self, other) {
            (Some(a), Some(b)) => a.partial_cmp(b),
            (None, None) => Some(Ordering::Equal),
            (None, Some(_)) => Some(Ordering::Less),
            (Some(_), None) => Some(Ordering::Greater),
        }
    }
}

impl<T: Ord> Ord for Option<T> {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        match (self, other) {
            (Some(a), Some(b)) => a.cmp(b),
            (None, None) => Ordering::Equal,
            (None, Some(_)) => Ordering::Less,
            (Some(_), None) => Ordering::Greater,
        }
    }
}

impl<T: Debug> Debug for Option<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self {
            Some(val) => {
                f.write_str("Some(")?;
                val.fmt(f)?;
                f.write_str(")")
            }
            None => f.write_str("None"),
        }
    }
}

impl<T: Default> Default for Option<T> {
    fn default() -> Self / pure {
        None
    }
}

impl<T> From<T> for Option<T> {
    fn from(val: T) -> Self / pure {
        Some(val)
    }
}

impl<T> IntoIterator for Option<T> {
    type Item = T;
    type IntoIter = IntoIter<T>;

    fn into_iter(self: Self) -> IntoIter<T> / pure {
        IntoIter { inner: self }
    }
}

/// Iterator over Option value
pub struct Iter<'a, T> {
    inner: Option<&'a T>,
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(self: &mut Self) -> Option<&'a T> / pure {
        self.inner.take()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let n = if self.inner.is_some() { 1 } else { 0 };
        (n, Some(n))
    }
}

/// Owning iterator over Option value
pub struct IntoIter<T> {
    inner: Option<T>,
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.inner.take()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let n = if self.inner.is_some() { 1 } else { 0 };
        (n, Some(n))
    }
}
