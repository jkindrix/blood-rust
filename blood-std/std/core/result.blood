// Blood Standard Library - Result Type
//
// The Result type represents either success (Ok) containing a value,
// or failure (Err) containing an error. Used for recoverable errors.

/// Result type for operations that can fail
pub enum Result<T, E> {
    /// Contains the success value
    Ok(T),
    /// Contains the error value
    Err(E),
}

impl<T, E> Result<T, E> {
    /// Returns true if the result is Ok
    pub fn is_ok(self: &Self) -> bool / pure {
        match self {
            Ok(_) => true,
            Err(_) => false,
        }
    }

    /// Returns true if the result is Err
    pub fn is_err(self: &Self) -> bool / pure {
        match self {
            Ok(_) => false,
            Err(_) => true,
        }
    }

    /// Returns true if the result is Ok and the value matches a predicate
    pub fn is_ok_and<F>(self: &Self, f: F) -> bool / pure
    where
        F: FnOnce(&T) -> bool,
    {
        match self {
            Ok(val) => f(val),
            Err(_) => false,
        }
    }

    /// Returns true if the result is Err and the error matches a predicate
    pub fn is_err_and<F>(self: &Self, f: F) -> bool / pure
    where
        F: FnOnce(&E) -> bool,
    {
        match self {
            Ok(_) => false,
            Err(err) => f(err),
        }
    }

    /// Converts from Result<T, E> to Option<T>
    pub fn ok(self: Self) -> Option<T> / pure {
        match self {
            Ok(val) => Some(val),
            Err(_) => None,
        }
    }

    /// Converts from Result<T, E> to Option<E>
    pub fn err(self: Self) -> Option<E> / pure {
        match self {
            Ok(_) => None,
            Err(err) => Some(err),
        }
    }

    /// Converts from &Result<T, E> to Result<&T, &E>
    pub fn as_ref(self: &Self) -> Result<&T, &E> / pure {
        match self {
            Ok(ref val) => Ok(val),
            Err(ref err) => Err(err),
        }
    }

    /// Converts from &mut Result<T, E> to Result<&mut T, &mut E>
    pub fn as_mut(self: &mut Self) -> Result<&mut T, &mut E> / pure {
        match self {
            Ok(ref mut val) => Ok(val),
            Err(ref mut err) => Err(err),
        }
    }

    /// Maps a Result<T, E> to Result<U, E> by applying a function
    pub fn map<U, F>(self: Self, f: F) -> Result<U, E> / pure
    where
        F: FnOnce(T) -> U,
    {
        match self {
            Ok(val) => Ok(f(val)),
            Err(err) => Err(err),
        }
    }

    /// Returns the provided default (if Err), or applies a function
    /// to the contained value (if Ok)
    pub fn map_or<U, F>(self: Self, default: U, f: F) -> U / pure
    where
        F: FnOnce(T) -> U,
    {
        match self {
            Ok(val) => f(val),
            Err(_) => default,
        }
    }

    /// Computes a default from the error (if Err), or applies a function
    /// to the contained value (if Ok)
    pub fn map_or_else<U, D, F>(self: Self, default: D, f: F) -> U / pure
    where
        D: FnOnce(E) -> U,
        F: FnOnce(T) -> U,
    {
        match self {
            Ok(val) => f(val),
            Err(err) => default(err),
        }
    }

    /// Maps a Result<T, E> to Result<T, F> by applying a function to the error
    pub fn map_err<F, O>(self: Self, op: O) -> Result<T, F> / pure
    where
        O: FnOnce(E) -> F,
    {
        match self {
            Ok(val) => Ok(val),
            Err(err) => Err(op(err)),
        }
    }

    /// Calls a closure if Ok, passing the value
    pub fn inspect<F>(self: Self, f: F) -> Self / pure
    where
        F: FnOnce(&T),
    {
        if let Ok(ref val) = self {
            f(val);
        }
        self
    }

    /// Calls a closure if Err, passing the error
    pub fn inspect_err<F>(self: Self, f: F) -> Self / pure
    where
        F: FnOnce(&E),
    {
        if let Err(ref err) = self {
            f(err);
        }
        self
    }

    /// Returns the contained Ok value, consuming self
    /// Panics if the result is Err with the provided message
    pub fn expect(self: Self, msg: &str) -> T / {Panic} {
        match self {
            Ok(val) => val,
            Err(_) => perform panic(msg),
        }
    }

    /// Returns the contained Ok value, consuming self
    /// Panics if the result is Err
    pub fn unwrap(self: Self) -> T / {Panic}
    where
        E: Debug,
    {
        match self {
            Ok(val) => val,
            Err(err) => perform panic(format!("called `Result::unwrap()` on an `Err` value: {:?}", err)),
        }
    }

    /// Returns the contained Err value, consuming self
    /// Panics if the result is Ok with the provided message
    pub fn expect_err(self: Self, msg: &str) -> E / {Panic} {
        match self {
            Ok(_) => perform panic(msg),
            Err(err) => err,
        }
    }

    /// Returns the contained Err value, consuming self
    /// Panics if the result is Ok
    pub fn unwrap_err(self: Self) -> E / {Panic}
    where
        T: Debug,
    {
        match self {
            Ok(val) => perform panic(format!("called `Result::unwrap_err()` on an `Ok` value: {:?}", val)),
            Err(err) => err,
        }
    }

    /// Returns the contained Ok value or a provided default
    pub fn unwrap_or(self: Self, default: T) -> T / pure {
        match self {
            Ok(val) => val,
            Err(_) => default,
        }
    }

    /// Returns the contained Ok value or computes it from a closure
    pub fn unwrap_or_else<F>(self: Self, f: F) -> T / pure
    where
        F: FnOnce(E) -> T,
    {
        match self {
            Ok(val) => val,
            Err(err) => f(err),
        }
    }

    /// Returns the contained Ok value or a default
    pub fn unwrap_or_default(self: Self) -> T / pure
    where
        T: Default,
    {
        match self {
            Ok(val) => val,
            Err(_) => T::default(),
        }
    }

    /// Returns res if the result is Ok, otherwise returns the Err value
    pub fn and<U>(self: Self, res: Result<U, E>) -> Result<U, E> / pure {
        match self {
            Ok(_) => res,
            Err(err) => Err(err),
        }
    }

    /// Calls op if the result is Ok, otherwise returns the Err value
    pub fn and_then<U, F>(self: Self, op: F) -> Result<U, E> / pure
    where
        F: FnOnce(T) -> Result<U, E>,
    {
        match self {
            Ok(val) => op(val),
            Err(err) => Err(err),
        }
    }

    /// Returns res if the result is Err, otherwise returns the Ok value
    pub fn or<F>(self: Self, res: Result<T, F>) -> Result<T, F> / pure {
        match self {
            Ok(val) => Ok(val),
            Err(_) => res,
        }
    }

    /// Calls op if the result is Err, otherwise returns the Ok value
    pub fn or_else<F, O>(self: Self, op: O) -> Result<T, F> / pure
    where
        O: FnOnce(E) -> Result<T, F>,
    {
        match self {
            Ok(val) => Ok(val),
            Err(err) => op(err),
        }
    }

    /// Transposes a Result of an Option into an Option of a Result
    pub fn transpose(self: Self) -> Option<Result<T, E>> / pure
    where
        T: Option<U>,
    {
        match self {
            Ok(Some(val)) => Some(Ok(val)),
            Ok(None) => None,
            Err(err) => Some(Err(err)),
        }
    }

    /// Converts from Result<Result<T, E>, E> to Result<T, E>
    pub fn flatten(self: Self) -> Result<T, E> / pure
    where
        T: Result<U, E>,
    {
        match self {
            Ok(inner) => inner,
            Err(err) => Err(err),
        }
    }
}

impl<T: Clone, E: Clone> Clone for Result<T, E> {
    fn clone(self: &Self) -> Self / pure {
        match self {
            Ok(val) => Ok(val.clone()),
            Err(err) => Err(err.clone()),
        }
    }
}

impl<T: Copy, E: Copy> Copy for Result<T, E> {}

impl<T: PartialEq, E: PartialEq> PartialEq for Result<T, E> {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        match (self, other) {
            (Ok(a), Ok(b)) => a == b,
            (Err(a), Err(b)) => a == b,
            _ => false,
        }
    }
}

impl<T: Eq, E: Eq> Eq for Result<T, E> {}

impl<T: PartialOrd, E: PartialOrd> PartialOrd for Result<T, E> {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        match (self, other) {
            (Ok(a), Ok(b)) => a.partial_cmp(b),
            (Err(a), Err(b)) => a.partial_cmp(b),
            (Ok(_), Err(_)) => Some(Ordering::Greater),
            (Err(_), Ok(_)) => Some(Ordering::Less),
        }
    }
}

impl<T: Ord, E: Ord> Ord for Result<T, E> {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        match (self, other) {
            (Ok(a), Ok(b)) => a.cmp(b),
            (Err(a), Err(b)) => a.cmp(b),
            (Ok(_), Err(_)) => Ordering::Greater,
            (Err(_), Ok(_)) => Ordering::Less,
        }
    }
}

impl<T: Debug, E: Debug> Debug for Result<T, E> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self {
            Ok(val) => {
                f.write_str("Ok(")?;
                val.fmt(f)?;
                f.write_str(")")
            }
            Err(err) => {
                f.write_str("Err(")?;
                err.fmt(f)?;
                f.write_str(")")
            }
        }
    }
}

impl<T: Default, E> Default for Result<T, E> {
    fn default() -> Self / pure {
        Ok(T::default())
    }
}

impl<T, E> From<T> for Result<T, E> {
    fn from(val: T) -> Self / pure {
        Ok(val)
    }
}

impl<T, E> IntoIterator for Result<T, E> {
    type Item = T;
    type IntoIter = IntoIter<T>;

    fn into_iter(self: Self) -> IntoIter<T> / pure {
        IntoIter { inner: self.ok() }
    }
}

/// Owning iterator over Result's Ok value
pub struct IntoIter<T> {
    inner: Option<T>,
}

impl<T> Iterator for IntoIter<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.inner.take()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let n = if self.inner.is_some() { 1 } else { 0 };
        (n, Some(n))
    }
}
