// Blood Standard Library - String Type
//
// A UTF-8 encoded, growable string.
// This is the heap-allocated counterpart to string slices (&str).

/// A UTF-8 encoded, growable string
pub struct String {
    /// Internal byte vector
    vec: Vec<u8>,
}

impl String {
    /// Creates a new empty String
    pub fn new() -> String / pure {
        String { vec: Vec::new() }
    }

    /// Creates a new empty String with specified capacity
    pub fn with_capacity(capacity: usize) -> String / pure {
        String { vec: Vec::with_capacity(capacity) }
    }

    /// Creates a String from a string slice
    pub fn from(s: &str) -> String / pure {
        let mut vec = Vec::with_capacity(s.len());
        for byte in s.bytes() {
            vec.push(byte);
        }
        String { vec }
    }

    /// Creates a String from a byte vector
    ///
    /// Returns Err if the bytes are not valid UTF-8
    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Utf8Error> / pure {
        // Validate UTF-8
        if validate_utf8(&vec) {
            Ok(String { vec })
        } else {
            Err(Utf8Error { bytes: vec })
        }
    }

    /// Creates a String from a byte vector without checking UTF-8 validity
    ///
    /// # Safety
    /// The bytes must be valid UTF-8
    pub unsafe fn from_utf8_unchecked(vec: Vec<u8>) -> String / pure {
        String { vec }
    }

    /// Returns the length of the string in bytes
    pub fn len(self: &Self) -> usize / pure {
        self.vec.len()
    }

    /// Returns true if the string is empty
    pub fn is_empty(self: &Self) -> bool / pure {
        self.vec.is_empty()
    }

    /// Returns the capacity of the string in bytes
    pub fn capacity(self: &Self) -> usize / pure {
        self.vec.capacity()
    }

    /// Reserves capacity for at least additional more bytes
    pub fn reserve(self: &mut Self, additional: usize) / pure {
        self.vec.reserve(additional);
    }

    /// Shrinks the capacity to match the length
    pub fn shrink_to_fit(self: &mut Self) / pure {
        self.vec.shrink_to_fit();
    }

    /// Appends a character to the end of the string
    pub fn push(self: &mut Self, ch: char) / pure {
        let mut buf = [0u8; 4];
        let encoded = ch.encode_utf8(&mut buf);
        for byte in encoded.bytes() {
            self.vec.push(byte);
        }
    }

    /// Appends a string slice to the end of the string
    pub fn push_str(self: &mut Self, s: &str) / pure {
        for byte in s.bytes() {
            self.vec.push(byte);
        }
    }

    /// Removes the last character from the string and returns it
    pub fn pop(self: &mut Self) -> Option<char> / pure {
        // Find the start of the last character
        let len = self.len();
        if len == 0 {
            return None;
        }

        // UTF-8 continuation bytes start with 10xxxxxx
        let mut idx = len - 1;
        while idx > 0 && (self.vec[idx] & 0xC0) == 0x80 {
            idx -= 1;
        }

        // Extract and decode the character
        let char_bytes = &self.vec[idx..len];
        let ch = decode_utf8_char(char_bytes);

        // Truncate the vector
        self.vec.truncate(idx);

        ch
    }

    /// Truncates the string to the specified length
    ///
    /// Panics if the new length is not on a char boundary
    pub fn truncate(self: &mut Self, new_len: usize) / {Panic} {
        if new_len <= self.len() {
            assert!(self.is_char_boundary(new_len), "truncate: not on char boundary");
            self.vec.truncate(new_len);
        }
    }

    /// Clears the string, removing all contents
    pub fn clear(self: &mut Self) / pure {
        self.vec.clear();
    }

    /// Returns true if the given byte index is on a char boundary
    pub fn is_char_boundary(self: &Self, index: usize) -> bool / pure {
        if index == 0 || index == self.len() {
            true
        } else if index > self.len() {
            false
        } else {
            // Not a continuation byte
            (self.vec[index] & 0xC0) != 0x80
        }
    }

    /// Returns a string slice containing the entire string
    pub fn as_str(self: &Self) -> &str / pure {
        unsafe { str::from_utf8_unchecked(&self.vec) }
    }

    /// Returns a mutable string slice
    pub fn as_mut_str(self: &mut Self) -> &mut str / pure {
        unsafe { str::from_utf8_unchecked_mut(&mut self.vec) }
    }

    /// Returns the underlying byte vector
    pub fn into_bytes(self: Self) -> Vec<u8> / pure {
        self.vec
    }

    /// Returns a byte slice of the string contents
    pub fn as_bytes(self: &Self) -> &[u8] / pure {
        &self.vec
    }

    /// Returns an iterator over the chars of the string
    pub fn chars(self: &Self) -> Chars / pure {
        Chars { iter: self.as_str().chars() }
    }

    /// Returns an iterator over the bytes of the string
    pub fn bytes(self: &Self) -> Bytes / pure {
        Bytes { iter: self.vec.iter() }
    }

    /// Returns true if the string contains the given pattern
    pub fn contains(self: &Self, pattern: &str) -> bool / pure {
        self.as_str().contains(pattern)
    }

    /// Returns true if the string starts with the given prefix
    pub fn starts_with(self: &Self, prefix: &str) -> bool / pure {
        self.as_str().starts_with(prefix)
    }

    /// Returns true if the string ends with the given suffix
    pub fn ends_with(self: &Self, suffix: &str) -> bool / pure {
        self.as_str().ends_with(suffix)
    }

    /// Returns the byte index of the first occurrence of the pattern
    pub fn find(self: &Self, pattern: &str) -> Option<usize> / pure {
        self.as_str().find(pattern)
    }

    /// Returns the byte index of the last occurrence of the pattern
    pub fn rfind(self: &Self, pattern: &str) -> Option<usize> / pure {
        self.as_str().rfind(pattern)
    }

    /// Splits the string by the given pattern
    pub fn split(self: &Self, pattern: &str) -> Split / pure {
        Split { inner: self.as_str().split(pattern) }
    }

    /// Returns a string with leading and trailing whitespace removed
    pub fn trim(self: &Self) -> &str / pure {
        self.as_str().trim()
    }

    /// Returns a string with leading whitespace removed
    pub fn trim_start(self: &Self) -> &str / pure {
        self.as_str().trim_start()
    }

    /// Returns a string with trailing whitespace removed
    pub fn trim_end(self: &Self) -> &str / pure {
        self.as_str().trim_end()
    }

    /// Converts the string to lowercase
    pub fn to_lowercase(self: &Self) -> String / pure {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            for c in ch.to_lowercase() {
                result.push(c);
            }
        }
        result
    }

    /// Converts the string to uppercase
    pub fn to_uppercase(self: &Self) -> String / pure {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            for c in ch.to_uppercase() {
                result.push(c);
            }
        }
        result
    }

    /// Replaces all occurrences of a pattern with another string
    pub fn replace(self: &Self, from: &str, to: &str) -> String / pure {
        let mut result = String::new();
        let mut last_end = 0;

        for (start, _) in self.as_str().match_indices(from) {
            result.push_str(&self.as_str()[last_end..start]);
            result.push_str(to);
            last_end = start + from.len();
        }

        result.push_str(&self.as_str()[last_end..]);
        result
    }

    /// Repeats the string n times
    pub fn repeat(self: &Self, n: usize) -> String / pure {
        let mut result = String::with_capacity(self.len() * n);
        for _ in 0..n {
            result.push_str(self.as_str());
        }
        result
    }
}

impl Clone for String {
    fn clone(self: &Self) -> Self / pure {
        String { vec: self.vec.clone() }
    }
}

impl PartialEq for String {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        self.vec == other.vec
    }
}

impl PartialEq<str> for String {
    fn eq(self: &Self, other: &str) -> bool / pure {
        self.as_str() == other
    }
}

impl PartialEq<&str> for String {
    fn eq(self: &Self, other: &&str) -> bool / pure {
        self.as_str() == *other
    }
}

impl Eq for String {}

impl PartialOrd for String {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        self.as_str().partial_cmp(other.as_str())
    }
}

impl Ord for String {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        self.as_str().cmp(other.as_str())
    }
}

impl Debug for String {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("\"")?;
        for ch in self.chars() {
            match ch {
                '\n' => f.write_str("\\n")?,
                '\r' => f.write_str("\\r")?,
                '\t' => f.write_str("\\t")?,
                '\\' => f.write_str("\\\\")?,
                '"' => f.write_str("\\\"")?,
                c if c.is_control() => write!(f, "\\u{{{:04x}}}", c as u32)?,
                c => f.write_char(c)?,
            }
        }
        f.write_str("\"")
    }
}

impl Display for String {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str(self.as_str())
    }
}

impl Default for String {
    fn default() -> Self / pure {
        String::new()
    }
}

impl From<&str> for String {
    fn from(s: &str) -> Self / pure {
        String::from(s)
    }
}

impl From<char> for String {
    fn from(c: char) -> Self / pure {
        let mut s = String::new();
        s.push(c);
        s
    }
}

impl Add<&str> for String {
    type Output = String;

    fn add(self: Self, other: &str) -> String / pure {
        let mut result = self;
        result.push_str(other);
        result
    }
}

impl AddAssign<&str> for String {
    fn add_assign(self: &mut Self, other: &str) / pure {
        self.push_str(other);
    }
}

impl Index<Range<usize>> for String {
    type Output = str;

    fn index(self: &Self, range: Range<usize>) -> &str / pure {
        &self.as_str()[range]
    }
}

impl Deref for String {
    type Target = str;

    fn deref(self: &Self) -> &str / pure {
        self.as_str()
    }
}

impl DerefMut for String {
    fn deref_mut(self: &mut Self) -> &mut str / pure {
        self.as_mut_str()
    }
}

impl Drop for String {
    fn drop(self: &mut Self) / pure {
        // Vec handles the actual deallocation
    }
}

impl FromIterator<char> for String {
    fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> Self / pure {
        let mut s = String::new();
        for ch in iter {
            s.push(ch);
        }
        s
    }
}

impl Extend<char> for String {
    fn extend<I: IntoIterator<Item = char>>(self: &mut Self, iter: I) / pure {
        for ch in iter {
            self.push(ch);
        }
    }
}

/// UTF-8 validation error
pub struct Utf8Error {
    bytes: Vec<u8>,
}

impl Utf8Error {
    /// Returns the bytes that failed validation
    pub fn as_bytes(self: &Self) -> &[u8] / pure {
        &self.bytes
    }

    /// Consumes the error, returning the bytes
    pub fn into_bytes(self: Self) -> Vec<u8> / pure {
        self.bytes
    }
}

/// Iterator over the characters of a string
pub struct Chars<'a> {
    iter: str::Chars<'a>,
}

impl<'a> Iterator for Chars<'a> {
    type Item = char;

    fn next(self: &mut Self) -> Option<char> / pure {
        self.iter.next()
    }
}

/// Iterator over the bytes of a string
pub struct Bytes<'a> {
    iter: slice::Iter<'a, u8>,
}

impl<'a> Iterator for Bytes<'a> {
    type Item = u8;

    fn next(self: &mut Self) -> Option<u8> / pure {
        self.iter.next().copied()
    }
}

/// Iterator over split string parts
pub struct Split<'a> {
    inner: str::Split<'a, &'a str>,
}

impl<'a> Iterator for Split<'a> {
    type Item = &'a str;

    fn next(self: &mut Self) -> Option<&'a str> / pure {
        self.inner.next()
    }
}

// Helper functions
fn validate_utf8(bytes: &[u8]) -> bool / pure {
    let mut i = 0;
    while i < bytes.len() {
        let b = bytes[i];
        let len = if b < 0x80 { 1 }
            else if b < 0xE0 { 2 }
            else if b < 0xF0 { 3 }
            else { 4 };

        if i + len > bytes.len() {
            return false;
        }

        // Check continuation bytes
        for j in 1..len {
            if (bytes[i + j] & 0xC0) != 0x80 {
                return false;
            }
        }

        i += len;
    }
    true
}

fn decode_utf8_char(bytes: &[u8]) -> Option<char> / pure {
    if bytes.is_empty() {
        return None;
    }

    let b0 = bytes[0];
    let code_point = if b0 < 0x80 {
        b0 as u32
    } else if b0 < 0xE0 && bytes.len() >= 2 {
        ((b0 & 0x1F) as u32) << 6 | (bytes[1] & 0x3F) as u32
    } else if b0 < 0xF0 && bytes.len() >= 3 {
        ((b0 & 0x0F) as u32) << 12 | ((bytes[1] & 0x3F) as u32) << 6 | (bytes[2] & 0x3F) as u32
    } else if bytes.len() >= 4 {
        ((b0 & 0x07) as u32) << 18 | ((bytes[1] & 0x3F) as u32) << 12 |
        ((bytes[2] & 0x3F) as u32) << 6 | (bytes[3] & 0x3F) as u32
    } else {
        return None;
    };

    char::from_u32(code_point)
}
