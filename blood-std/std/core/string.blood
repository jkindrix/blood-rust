// Blood Standard Library - String Type
//
// A UTF-8 encoded, growable string.
// This is the heap-allocated counterpart to string slices (&str).

/// A UTF-8 encoded, growable string
pub struct String {
    /// Internal byte vector
    vec: Vec<u8>,
}

impl String {
    /// Creates a new empty String
    pub fn new() -> String / pure {
        String { vec: Vec::new() }
    }

    /// Creates a new empty String with specified capacity
    pub fn with_capacity(capacity: usize) -> String / pure {
        String { vec: Vec::with_capacity(capacity) }
    }

    /// Creates a String from a string slice
    pub fn from(s: &str) -> String / pure {
        let mut vec = Vec::with_capacity(s.len());
        for byte in s.bytes() {
            vec.push(byte);
        }
        String { vec }
    }

    /// Creates a String from a byte vector
    ///
    /// Returns Err if the bytes are not valid UTF-8
    pub fn from_utf8(vec: Vec<u8>) -> Result<String, Utf8Error> / pure {
        // Validate UTF-8
        if validate_utf8(&vec) {
            Ok(String { vec })
        } else {
            Err(Utf8Error { bytes: vec })
        }
    }

    /// Creates a String from a byte vector without checking UTF-8 validity
    ///
    /// # Safety
    /// The bytes must be valid UTF-8
    pub unsafe fn from_utf8_unchecked(vec: Vec<u8>) -> String / pure {
        String { vec }
    }

    /// Returns the length of the string in bytes
    pub fn len(self: &Self) -> usize / pure {
        self.vec.len()
    }

    /// Returns true if the string is empty
    pub fn is_empty(self: &Self) -> bool / pure {
        self.vec.is_empty()
    }

    /// Returns the capacity of the string in bytes
    pub fn capacity(self: &Self) -> usize / pure {
        self.vec.capacity()
    }

    /// Reserves capacity for at least additional more bytes
    pub fn reserve(self: &mut Self, additional: usize) / pure {
        self.vec.reserve(additional);
    }

    /// Shrinks the capacity to match the length
    pub fn shrink_to_fit(self: &mut Self) / pure {
        self.vec.shrink_to_fit();
    }

    /// Appends a character to the end of the string
    pub fn push(self: &mut Self, ch: char) / pure {
        let mut buf = [0u8; 4];
        let encoded = ch.encode_utf8(&mut buf);
        for byte in encoded.bytes() {
            self.vec.push(byte);
        }
    }

    /// Appends a string slice to the end of the string
    pub fn push_str(self: &mut Self, s: &str) / pure {
        for byte in s.bytes() {
            self.vec.push(byte);
        }
    }

    /// Removes the last character from the string and returns it
    pub fn pop(self: &mut Self) -> Option<char> / pure {
        // Find the start of the last character
        let len = self.len();
        if len == 0 {
            return None;
        }

        // UTF-8 continuation bytes start with 10xxxxxx
        let mut idx = len - 1;
        while idx > 0 && (self.vec[idx] & 0xC0) == 0x80 {
            idx -= 1;
        }

        // Extract and decode the character
        let char_bytes = &self.vec[idx..len];
        let ch = decode_utf8_char(char_bytes);

        // Truncate the vector
        self.vec.truncate(idx);

        ch
    }

    /// Truncates the string to the specified length
    ///
    /// Panics if the new length is not on a char boundary
    pub fn truncate(self: &mut Self, new_len: usize) / {Panic} {
        if new_len <= self.len() {
            assert!(self.is_char_boundary(new_len), "truncate: not on char boundary");
            self.vec.truncate(new_len);
        }
    }

    /// Clears the string, removing all contents
    pub fn clear(self: &mut Self) / pure {
        self.vec.clear();
    }

    /// Returns true if the given byte index is on a char boundary
    pub fn is_char_boundary(self: &Self, index: usize) -> bool / pure {
        if index == 0 || index == self.len() {
            true
        } else if index > self.len() {
            false
        } else {
            // Not a continuation byte
            (self.vec[index] & 0xC0) != 0x80
        }
    }

    /// Returns a string slice containing the entire string
    pub fn as_str(self: &Self) -> &str / pure {
        unsafe { str::from_utf8_unchecked(&self.vec) }
    }

    /// Returns a mutable string slice
    pub fn as_mut_str(self: &mut Self) -> &mut str / pure {
        unsafe { str::from_utf8_unchecked_mut(&mut self.vec) }
    }

    /// Returns the underlying byte vector
    pub fn into_bytes(self: Self) -> Vec<u8> / pure {
        self.vec
    }

    /// Returns a byte slice of the string contents
    pub fn as_bytes(self: &Self) -> &[u8] / pure {
        &self.vec
    }

    /// Returns an iterator over the chars of the string
    pub fn chars(self: &Self) -> Chars / pure {
        Chars { iter: self.as_str().chars() }
    }

    /// Returns an iterator over the bytes of the string
    pub fn bytes(self: &Self) -> Bytes / pure {
        Bytes { iter: self.vec.iter() }
    }

    /// Returns true if the string contains the given pattern
    pub fn contains(self: &Self, pattern: &str) -> bool / pure {
        self.as_str().contains(pattern)
    }

    /// Returns true if the string starts with the given prefix
    pub fn starts_with(self: &Self, prefix: &str) -> bool / pure {
        self.as_str().starts_with(prefix)
    }

    /// Returns true if the string ends with the given suffix
    pub fn ends_with(self: &Self, suffix: &str) -> bool / pure {
        self.as_str().ends_with(suffix)
    }

    /// Returns the byte index of the first occurrence of the pattern
    pub fn find(self: &Self, pattern: &str) -> Option<usize> / pure {
        self.as_str().find(pattern)
    }

    /// Returns the byte index of the last occurrence of the pattern
    pub fn rfind(self: &Self, pattern: &str) -> Option<usize> / pure {
        self.as_str().rfind(pattern)
    }

    /// Splits the string by the given pattern
    pub fn split(self: &Self, pattern: &str) -> Split / pure {
        Split { inner: self.as_str().split(pattern) }
    }

    /// Returns a string with leading and trailing whitespace removed
    pub fn trim(self: &Self) -> &str / pure {
        self.as_str().trim()
    }

    /// Returns a string with leading whitespace removed
    pub fn trim_start(self: &Self) -> &str / pure {
        self.as_str().trim_start()
    }

    /// Returns a string with trailing whitespace removed
    pub fn trim_end(self: &Self) -> &str / pure {
        self.as_str().trim_end()
    }

    /// Converts the string to lowercase
    pub fn to_lowercase(self: &Self) -> String / pure {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            for c in ch.to_lowercase() {
                result.push(c);
            }
        }
        result
    }

    /// Converts the string to uppercase
    pub fn to_uppercase(self: &Self) -> String / pure {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            for c in ch.to_uppercase() {
                result.push(c);
            }
        }
        result
    }

    /// Replaces all occurrences of a pattern with another string
    pub fn replace(self: &Self, from: &str, to: &str) -> String / pure {
        let mut result = String::new();
        let mut last_end = 0;

        for (start, _) in self.as_str().match_indices(from) {
            result.push_str(&self.as_str()[last_end..start]);
            result.push_str(to);
            last_end = start + from.len();
        }

        result.push_str(&self.as_str()[last_end..]);
        result
    }

    /// Repeats the string n times
    pub fn repeat(self: &Self, n: usize) -> String / pure {
        let mut result = String::with_capacity(self.len() * n);
        for _ in 0..n {
            result.push_str(self.as_str());
        }
        result
    }

    /// Inserts a character at a byte position
    ///
    /// Panics if the position is not on a char boundary
    pub fn insert(self: &mut Self, idx: usize, ch: char) / {Panic} {
        assert!(self.is_char_boundary(idx), "insert: not on char boundary");
        let mut buf = [0u8; 4];
        let encoded = ch.encode_utf8(&mut buf);
        let len = encoded.len();

        // Reserve space and shift bytes
        self.vec.reserve(len);
        let old_len = self.vec.len();

        // Extend vec to new size
        for _ in 0..len {
            self.vec.push(0);
        }

        // Shift existing bytes to the right
        for i in (idx..old_len).rev() {
            self.vec[i + len] = self.vec[i];
        }

        // Insert new bytes
        for i in 0..len {
            self.vec[idx + i] = buf[i];
        }
    }

    /// Inserts a string slice at a byte position
    ///
    /// Panics if the position is not on a char boundary
    pub fn insert_str(self: &mut Self, idx: usize, s: &str) / {Panic} {
        assert!(self.is_char_boundary(idx), "insert_str: not on char boundary");
        let len = s.len();

        // Reserve space and shift bytes
        self.vec.reserve(len);
        let old_len = self.vec.len();

        // Extend vec to new size
        for _ in 0..len {
            self.vec.push(0);
        }

        // Shift existing bytes to the right
        for i in (idx..old_len).rev() {
            self.vec[i + len] = self.vec[i];
        }

        // Insert new bytes
        for (i, byte) in s.bytes().enumerate() {
            self.vec[idx + i] = byte;
        }
    }

    /// Removes a character at a byte position and returns it
    ///
    /// Panics if the position is not on a char boundary
    pub fn remove(self: &mut Self, idx: usize) -> char / {Panic} {
        assert!(self.is_char_boundary(idx), "remove: not on char boundary");

        // Find the length of the character
        let ch = self.as_str()[idx..].chars().next().unwrap();
        let len = ch.len_utf8();

        // Shift bytes to the left
        let old_len = self.vec.len();
        for i in idx..(old_len - len) {
            self.vec[i] = self.vec[i + len];
        }
        self.vec.truncate(old_len - len);

        ch
    }

    /// Returns an iterator over the lines of the string
    pub fn lines(self: &Self) -> Lines / pure {
        Lines { inner: self.as_str().lines() }
    }

    /// Splits the string by whitespace
    pub fn split_whitespace(self: &Self) -> SplitWhitespace / pure {
        SplitWhitespace { inner: self.as_str().split_whitespace() }
    }

    /// Returns an iterator over the characters with their byte indices
    pub fn char_indices(self: &Self) -> CharIndices / pure {
        CharIndices { inner: self.as_str().char_indices() }
    }

    /// Splits the string into two at the given byte index
    ///
    /// Panics if the index is not on a char boundary
    pub fn split_at(self: &Self, mid: usize) -> (&str, &str) / {Panic} {
        assert!(self.is_char_boundary(mid), "split_at: not on char boundary");
        self.as_str().split_at(mid)
    }

    /// Creates a draining iterator that removes and returns characters in the given range
    pub fn drain(self: &mut Self, range: Range<usize>) -> Drain / {Panic} {
        assert!(self.is_char_boundary(range.start), "drain: start not on char boundary");
        assert!(self.is_char_boundary(range.end), "drain: end not on char boundary");

        let drained = self.as_str()[range.clone()].to_string();

        // Remove the drained bytes
        let len = range.end - range.start;
        let old_len = self.vec.len();
        for i in range.start..(old_len - len) {
            self.vec[i] = self.vec[i + len];
        }
        self.vec.truncate(old_len - len);

        Drain { inner: drained.chars() }
    }

    /// Retains only the characters that satisfy the predicate
    pub fn retain<F: FnMut(char) -> bool>(self: &mut Self, mut f: F) / pure {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            if f(ch) {
                result.push(ch);
            }
        }
        *self = result;
    }

    /// Returns true if all characters are ASCII
    pub fn is_ascii(self: &Self) -> bool / pure {
        self.vec.iter().all(|&b| b < 128)
    }

    /// Converts to ASCII lowercase in-place
    pub fn make_ascii_lowercase(self: &mut Self) / pure {
        for byte in &mut self.vec {
            if *byte >= b'A' && *byte <= b'Z' {
                *byte = *byte - b'A' + b'a';
            }
        }
    }

    /// Converts to ASCII uppercase in-place
    pub fn make_ascii_uppercase(self: &mut Self) / pure {
        for byte in &mut self.vec {
            if *byte >= b'a' && *byte <= b'z' {
                *byte = *byte - b'a' + b'A';
            }
        }
    }

    /// Returns an ASCII lowercase version of the string
    pub fn to_ascii_lowercase(self: &Self) -> String / pure {
        let mut result = self.clone();
        result.make_ascii_lowercase();
        result
    }

    /// Returns an ASCII uppercase version of the string
    pub fn to_ascii_uppercase(self: &Self) -> String / pure {
        let mut result = self.clone();
        result.make_ascii_uppercase();
        result
    }

    /// Consumes the String and returns the owned string
    pub fn into_str(self: Self) -> str / pure {
        unsafe { str::from_utf8_unchecked(self.vec.into_boxed_slice()) }
    }
}

impl Clone for String {
    fn clone(self: &Self) -> Self / pure {
        String { vec: self.vec.clone() }
    }
}

impl PartialEq for String {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        self.vec == other.vec
    }
}

impl PartialEq<str> for String {
    fn eq(self: &Self, other: &str) -> bool / pure {
        self.as_str() == other
    }
}

impl PartialEq<&str> for String {
    fn eq(self: &Self, other: &&str) -> bool / pure {
        self.as_str() == *other
    }
}

impl Eq for String {}

impl PartialOrd for String {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        self.as_str().partial_cmp(other.as_str())
    }
}

impl Ord for String {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        self.as_str().cmp(other.as_str())
    }
}

impl Debug for String {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("\"")?;
        for ch in self.chars() {
            match ch {
                '\n' => f.write_str("\\n")?,
                '\r' => f.write_str("\\r")?,
                '\t' => f.write_str("\\t")?,
                '\\' => f.write_str("\\\\")?,
                '"' => f.write_str("\\\"")?,
                c if c.is_control() => write!(f, "\\u{{{:04x}}}", c as u32)?,
                c => f.write_char(c)?,
            }
        }
        f.write_str("\"")
    }
}

impl Display for String {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str(self.as_str())
    }
}

impl Default for String {
    fn default() -> Self / pure {
        String::new()
    }
}

impl From<&str> for String {
    fn from(s: &str) -> Self / pure {
        String::from(s)
    }
}

impl From<char> for String {
    fn from(c: char) -> Self / pure {
        let mut s = String::new();
        s.push(c);
        s
    }
}

impl Add<&str> for String {
    type Output = String;

    fn add(self: Self, other: &str) -> String / pure {
        let mut result = self;
        result.push_str(other);
        result
    }
}

impl AddAssign<&str> for String {
    fn add_assign(self: &mut Self, other: &str) / pure {
        self.push_str(other);
    }
}

impl Index<Range<usize>> for String {
    type Output = str;

    fn index(self: &Self, range: Range<usize>) -> &str / pure {
        &self.as_str()[range]
    }
}

impl Deref for String {
    type Target = str;

    fn deref(self: &Self) -> &str / pure {
        self.as_str()
    }
}

impl DerefMut for String {
    fn deref_mut(self: &mut Self) -> &mut str / pure {
        self.as_mut_str()
    }
}

impl Drop for String {
    fn drop(self: &mut Self) / pure {
        // Vec handles the actual deallocation
    }
}

impl FromIterator<char> for String {
    fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> Self / pure {
        let mut s = String::new();
        for ch in iter {
            s.push(ch);
        }
        s
    }
}

impl Extend<char> for String {
    fn extend<I: IntoIterator<Item = char>>(self: &mut Self, iter: I) / pure {
        for ch in iter {
            self.push(ch);
        }
    }
}

/// UTF-8 validation error
pub struct Utf8Error {
    bytes: Vec<u8>,
}

impl Utf8Error {
    /// Returns the bytes that failed validation
    pub fn as_bytes(self: &Self) -> &[u8] / pure {
        &self.bytes
    }

    /// Consumes the error, returning the bytes
    pub fn into_bytes(self: Self) -> Vec<u8> / pure {
        self.bytes
    }
}

/// Iterator over the characters of a string
pub struct Chars<'a> {
    iter: str::Chars<'a>,
}

impl<'a> Iterator for Chars<'a> {
    type Item = char;

    fn next(self: &mut Self) -> Option<char> / pure {
        self.iter.next()
    }
}

/// Iterator over the bytes of a string
pub struct Bytes<'a> {
    iter: slice::Iter<'a, u8>,
}

impl<'a> Iterator for Bytes<'a> {
    type Item = u8;

    fn next(self: &mut Self) -> Option<u8> / pure {
        self.iter.next().copied()
    }
}

/// Iterator over split string parts
pub struct Split<'a> {
    inner: str::Split<'a, &'a str>,
}

impl<'a> Iterator for Split<'a> {
    type Item = &'a str;

    fn next(self: &mut Self) -> Option<&'a str> / pure {
        self.inner.next()
    }
}

/// Iterator over the lines of a string
pub struct Lines<'a> {
    inner: str::Lines<'a>,
}

impl<'a> Iterator for Lines<'a> {
    type Item = &'a str;

    fn next(self: &mut Self) -> Option<&'a str> / pure {
        self.inner.next()
    }
}

/// Iterator over whitespace-separated parts of a string
pub struct SplitWhitespace<'a> {
    inner: str::SplitWhitespace<'a>,
}

impl<'a> Iterator for SplitWhitespace<'a> {
    type Item = &'a str;

    fn next(self: &mut Self) -> Option<&'a str> / pure {
        self.inner.next()
    }
}

/// Iterator over characters with their byte indices
pub struct CharIndices<'a> {
    inner: str::CharIndices<'a>,
}

impl<'a> Iterator for CharIndices<'a> {
    type Item = (usize, char);

    fn next(self: &mut Self) -> Option<(usize, char)> / pure {
        self.inner.next()
    }
}

/// Draining iterator over characters
pub struct Drain<'a> {
    inner: Chars<'a>,
}

impl<'a> Iterator for Drain<'a> {
    type Item = char;

    fn next(self: &mut Self) -> Option<char> / pure {
        self.inner.next()
    }
}

// Helper functions
fn validate_utf8(bytes: &[u8]) -> bool / pure {
    let mut i = 0;
    while i < bytes.len() {
        let b = bytes[i];
        let len = if b < 0x80 { 1 }
            else if b < 0xE0 { 2 }
            else if b < 0xF0 { 3 }
            else { 4 };

        if i + len > bytes.len() {
            return false;
        }

        // Check continuation bytes
        for j in 1..len {
            if (bytes[i + j] & 0xC0) != 0x80 {
                return false;
            }
        }

        i += len;
    }
    true
}

fn decode_utf8_char(bytes: &[u8]) -> Option<char> / pure {
    if bytes.is_empty() {
        return None;
    }

    let b0 = bytes[0];
    let code_point = if b0 < 0x80 {
        b0 as u32
    } else if b0 < 0xE0 && bytes.len() >= 2 {
        ((b0 & 0x1F) as u32) << 6 | (bytes[1] & 0x3F) as u32
    } else if b0 < 0xF0 && bytes.len() >= 3 {
        ((b0 & 0x0F) as u32) << 12 | ((bytes[1] & 0x3F) as u32) << 6 | (bytes[2] & 0x3F) as u32
    } else if bytes.len() >= 4 {
        ((b0 & 0x07) as u32) << 18 | ((bytes[1] & 0x3F) as u32) << 12 |
        ((bytes[2] & 0x3F) as u32) << 6 | (bytes[3] & 0x3F) as u32
    } else {
        return None;
    };

    char::from_u32(code_point)
}
