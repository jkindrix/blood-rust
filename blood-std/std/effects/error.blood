// Blood Standard Library - Error Effect
//
// The Error<E> effect provides recoverable error handling through
// algebraic effects rather than exceptions.

/// Error effect for recoverable failures
///
/// This effect is similar to Result<T, E> but operates at the effect level,
/// allowing errors to propagate through effect handlers.
///
/// # Example
/// ```blood
/// fn may_fail(x: i32) -> i32 / {Error<String>} {
///     if x < 0 {
///         perform raise("negative input")
///     } else {
///         x * 2
///     }
/// }
///
/// fn main() {
///     handle may_fail(-1) {
///         return(v) { Ok(v) }
///         raise(e) { Err(e) }
///     }
/// }
/// ```
pub effect Error<E> {
    /// Raises an error value
    ///
    /// This operation typically does not resume, causing the computation
    /// to fail with the provided error.
    op raise(error: E) -> !;
}

/// Raises an error in the Error<E> effect
pub fn raise<E>(error: E) -> ! / {Error<E>} {
    perform raise(error)
}

/// Catches errors from a computation
///
/// Transforms a computation that may fail into one that returns a Result.
pub fn catch<T, E, F>(f: F) -> Result<T, E> / pure
where
    F: FnOnce() -> T / {Error<E>},
{
    handle f() {
        return(v) { Ok(v) }
        raise(e) { Err(e) }
    }
}

/// Converts a Result to the Error effect
pub fn from_result<T, E>(result: Result<T, E>) -> T / {Error<E>} {
    match result {
        Ok(v) => v,
        Err(e) => perform raise(e),
    }
}

/// Maps the error type of a computation
pub fn map_err<T, E, F, M>(f: F, mapper: M) -> T / {Error<F>}
where
    F: FnOnce() -> T / {Error<E>},
    M: Fn(E) -> F,
{
    handle f() {
        return(v) { v }
        raise(e) { perform raise(mapper(e)) }
    }
}

/// Provides a default value on error
pub fn unwrap_or<T, E, F>(f: F, default: T) -> T / pure
where
    F: FnOnce() -> T / {Error<E>},
{
    handle f() {
        return(v) { v }
        raise(_) { default }
    }
}

/// Provides a default value computed from the error
pub fn unwrap_or_else<T, E, F, D>(f: F, default: D) -> T / pure
where
    F: FnOnce() -> T / {Error<E>},
    D: FnOnce(E) -> T,
{
    handle f() {
        return(v) { v }
        raise(e) { default(e) }
    }
}

/// Retries a computation up to n times on failure
pub fn retry<T, E, F>(n: usize, f: F) -> T / {Error<E>}
where
    F: Fn() -> T / {Error<E>},
{
    let mut attempts = 0;
    let mut last_error: Option<E> = None;

    while attempts < n {
        match catch(|| f()) {
            Ok(v) => return v,
            Err(e) => {
                last_error = Some(e);
                attempts += 1;
            }
        }
    }

    perform raise(last_error.unwrap())
}

/// Standard handler that converts Error effect to Result
pub deep handler ErrorToResult<T, E> for Error<E> {
    type Output = Result<T, E>;

    return(x: T) { Ok(x) }

    op raise(e: E) { Err(e) }
}

/// Handler that collects all errors while continuing execution
pub deep handler CollectErrors<T, E> for Error<E>
where
    T: Default,
{
    let mut errors: Vec<E> = Vec::new();

    type Output = (T, Vec<E>);

    return(x: T) { (x, errors) }

    op raise(e: E) {
        errors.push(e);
        resume(T::default())
    }
}

/// Handler that logs errors and continues with a default
pub deep handler LogErrors<T, E> for Error<E>
where
    T: Default,
    E: Display,
{
    type Output = T;

    return(x: T) { x }

    op raise(e: E) {
        eprintln!("Error: {}", e);
        resume(T::default())
    }
}
