// Blood Standard Library - IO Effect
//
// The IO effect marks operations that perform input/output.

/// IO effect for input/output operations
///
/// This effect marks functions that interact with the outside world
/// through file I/O, network operations, console output, etc.
///
/// # Example
/// ```blood
/// fn greet(name: &str) / {IO} {
///     perform print("Hello, ");
///     perform println(name);
/// }
/// ```
pub effect IO {
    /// Prints a string without newline
    op print(s: &str) -> unit;

    /// Prints a string with newline
    op println(s: &str) -> unit;

    /// Prints to stderr without newline
    op eprint(s: &str) -> unit;

    /// Prints to stderr with newline
    op eprintln(s: &str) -> unit;

    /// Reads a line from stdin
    op read_line() -> String;

    /// Reads entire stdin to string
    op read_to_string() -> String;

    /// Flushes stdout
    op flush() -> unit;
}

/// Prints a string to stdout without newline
pub fn print(s: &str) / {IO} {
    perform print(s)
}

/// Prints a string to stdout with newline
pub fn println(s: &str) / {IO} {
    perform println(s)
}

/// Prints a value that implements Display
pub fn print_val<T: Display>(val: &T) / {IO} {
    perform print(&format!("{}", val))
}

/// Prints a value with newline
pub fn println_val<T: Display>(val: &T) / {IO} {
    perform println(&format!("{}", val))
}

/// Prints a formatted string (like format! macro)
pub fn printf(fmt: &str, args: &[&dyn Display]) / {IO} {
    // Simple implementation - proper format string parsing would be more complex
    let mut result = String::new();
    let mut arg_idx = 0;
    let mut chars = fmt.chars();

    while let Some(c) = chars.next() {
        if c == '{' {
            if let Some(next) = chars.next() {
                if next == '}' && arg_idx < args.len() {
                    result.push_str(&format!("{}", args[arg_idx]));
                    arg_idx += 1;
                } else if next == '{' {
                    result.push('{');
                } else {
                    result.push(c);
                    result.push(next);
                }
            }
        } else if c == '}' {
            if let Some(next) = chars.next() {
                if next == '}' {
                    result.push('}');
                } else {
                    result.push(c);
                    result.push(next);
                }
            }
        } else {
            result.push(c);
        }
    }

    perform print(&result)
}

/// Prints to stderr without newline
pub fn eprint(s: &str) / {IO} {
    perform eprint(s)
}

/// Prints to stderr with newline
pub fn eprintln(s: &str) / {IO} {
    perform eprintln(s)
}

/// Reads a line from stdin (without trailing newline)
pub fn read_line() -> String / {IO} {
    let mut line = perform read_line();
    // Remove trailing newline
    if line.ends_with('\n') {
        line.pop();
        if line.ends_with('\r') {
            line.pop();
        }
    }
    line
}

/// Reads a line and parses it
pub fn read<T: FromStr>() -> Result<T, T::Err> / {IO} {
    read_line().parse()
}

/// Reads entire stdin to string
pub fn read_to_string() -> String / {IO} {
    perform read_to_string()
}

/// Flushes stdout
pub fn flush() / {IO} {
    perform flush()
}

/// Prompts for input and reads a line
pub fn prompt(message: &str) -> String / {IO} {
    print(message);
    flush();
    read_line()
}

/// Standard IO handler using system stdio
pub deep handler StdIO for IO {
    return(x) { x }

    op print(s) {
        // Implementation provided by runtime
        __builtin_print(s);
        resume(())
    }

    op println(s) {
        __builtin_println(s);
        resume(())
    }

    op eprint(s) {
        __builtin_eprint(s);
        resume(())
    }

    op eprintln(s) {
        __builtin_eprintln(s);
        resume(())
    }

    op read_line() {
        let line = __builtin_read_line();
        resume(line)
    }

    op read_to_string() {
        let content = __builtin_read_to_string();
        resume(content)
    }

    op flush() {
        __builtin_flush();
        resume(())
    }
}

/// Mock IO handler for testing
pub deep handler MockIO for IO {
    let mut output: Vec<String> = Vec::new();
    let mut input: Vec<String>;
    let mut input_idx: usize = 0;

    fn new(input_lines: Vec<String>) -> Self {
        MockIO {
            output: Vec::new(),
            input: input_lines,
            input_idx: 0,
        }
    }

    fn get_output(self: &Self) -> &[String] {
        &self.output
    }

    return(x) { x }

    op print(s) {
        if let Some(last) = self.output.last_mut() {
            last.push_str(s);
        } else {
            self.output.push(String::from(s));
        }
        resume(())
    }

    op println(s) {
        self.output.push(String::from(s));
        resume(())
    }

    op eprint(s) {
        // For mock, treat stderr same as stdout
        if let Some(last) = self.output.last_mut() {
            last.push_str(s);
        } else {
            self.output.push(String::from(s));
        }
        resume(())
    }

    op eprintln(s) {
        self.output.push(String::from(s));
        resume(())
    }

    op read_line() {
        let line = if self.input_idx < self.input.len() {
            let l = self.input[self.input_idx].clone();
            self.input_idx += 1;
            l
        } else {
            String::new()
        };
        resume(line)
    }

    op read_to_string() {
        let content = self.input[self.input_idx..].join("\n");
        self.input_idx = self.input.len();
        resume(content)
    }

    op flush() {
        resume(())
    }
}

/// Captures IO output as a string
pub fn capture_output<T, F>(f: F) -> (T, Vec<String>) / pure
where
    F: FnOnce() -> T / {IO},
{
    let mock = MockIO::new(Vec::new());
    let result = handle f() with mock {
        return(v) { v }
        // Operations handled by MockIO
    };
    (result, mock.get_output().to_vec())
}

/// Runs IO with provided input lines
pub fn with_input<T, F>(input: Vec<String>, f: F) -> T / pure
where
    F: FnOnce() -> T / {IO},
{
    let mock = MockIO::new(input);
    handle f() with mock {
        return(v) { v }
    }
}
