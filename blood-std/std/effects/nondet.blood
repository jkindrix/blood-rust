// Blood Standard Library - NonDet Effect
//
// The NonDet effect provides non-deterministic choice for backtracking search.

/// Non-deterministic choice effect
///
/// This effect allows exploring multiple possibilities and backtracking
/// when a path fails. Useful for search algorithms, constraint solving, etc.
pub effect NonDet {
    /// Chooses non-deterministically from a list of options
    op choose<T>(options: Vec<T>) -> T;

    /// Signals that the current path has failed
    op fail() -> !;
}

/// Chooses from a list of options
pub fn choose<T>(options: Vec<T>) -> T / {NonDet} {
    perform choose(options)
}

/// Signals failure, triggering backtracking
pub fn fail() -> ! / {NonDet} {
    perform fail()
}

/// Guard that fails if condition is false
pub fn guard(condition: bool) / {NonDet} {
    if !condition {
        perform fail()
    }
}

/// Chooses a boolean value
pub fn flip() -> bool / {NonDet} {
    perform choose(vec![true, false])
}

/// Chooses from a range of integers
pub fn choose_range(start: i32, end: i32) -> i32 / {NonDet} {
    let options: Vec<i32> = (start..end).collect();
    perform choose(options)
}

/// Collects all solutions
pub fn all_solutions<T, F>(f: F) -> Vec<T> / pure
where
    F: Fn() -> T / {NonDet},
{
    let mut solutions = Vec::new();

    // Use continuation-based handler to explore all paths
    handle f() {
        return(v) {
            solutions.push(v);
        }
        choose(options) {
            for option in options {
                resume(option);
            }
        }
        fail() {
            // Don't add to solutions, just continue exploring
        }
    }

    solutions
}

/// Returns the first solution or None
pub fn first_solution<T, F>(f: F) -> Option<T> / pure
where
    F: Fn() -> T / {NonDet},
{
    handle f() {
        return(v) { Some(v) }
        choose(options) {
            for option in options {
                if let Some(result) = resume(option) {
                    return Some(result);
                }
            }
            None
        }
        fail() { None }
    }
}

/// Counts the number of solutions
pub fn count_solutions<T, F>(f: F) -> usize / pure
where
    F: Fn() -> T / {NonDet},
{
    all_solutions(f).len()
}

/// Standard handler that explores all choices depth-first
pub deep handler DepthFirstSearch<T> for NonDet {
    type Output = Vec<T>;

    return(v: T) { vec![v] }

    op choose(options) {
        let mut all_results = Vec::new();
        for option in options {
            let results = resume(option);
            all_results.extend(results);
        }
        all_results
    }

    op fail() { Vec::new() }
}

/// Handler that returns only the first solution
pub deep handler FirstSolution<T> for NonDet {
    type Output = Option<T>;

    return(v: T) { Some(v) }

    op choose(options) {
        for option in options {
            if let Some(result) = resume(option) {
                return Some(result);
            }
        }
        None
    }

    op fail() { None }
}

/// Handler that uses random selection instead of exhaustive search
pub deep handler RandomChoice<T> for NonDet {
    return(v: T) { Some(v) }

    op choose(options) {
        if options.is_empty() {
            None
        } else {
            let idx = __builtin_random_usize() % options.len();
            resume(options[idx])
        }
    }

    op fail() { None }
}

/// Example: N-Queens problem using NonDet
pub fn n_queens(n: usize) -> Vec<usize> / {NonDet} {
    let mut queens = Vec::with_capacity(n);

    for row in 0..n {
        let col = choose_range(0, n as i32) as usize;

        // Check if placement is valid
        for (prev_row, &prev_col) in queens.iter().enumerate() {
            // Same column
            guard(col != prev_col);
            // Same diagonal
            let row_diff = row - prev_row;
            guard(col != prev_col + row_diff);
            if prev_col >= row_diff {
                guard(col != prev_col - row_diff);
            }
        }

        queens.push(col);
    }

    queens
}

/// Example: SAT-like boolean satisfiability
pub fn satisfy<F>(vars: usize, constraint: F) -> Vec<bool> / {NonDet}
where
    F: Fn(&[bool]) -> bool,
{
    let mut assignment = Vec::with_capacity(vars);

    for _ in 0..vars {
        let value = flip();
        assignment.push(value);
    }

    guard(constraint(&assignment));
    assignment
}
