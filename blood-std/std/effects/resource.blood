// Blood Standard Library - Resource Effect
//
// The Resource effect provides RAII-style resource management through effects.

/// Resource effect for managing external resources
///
/// This effect provides acquire/release semantics for resources like
/// file handles, network connections, locks, etc.
pub effect Resource<R> {
    /// Acquires a resource
    op acquire(spec: R::Spec) -> R;

    /// Releases a resource
    op release(resource: R) -> unit;
}

/// Trait for resources managed by the Resource effect
pub trait ManagedResource {
    /// Specification for creating the resource
    type Spec;

    /// Creates the resource from its spec
    fn create(spec: Self::Spec) -> Result<Self, ResourceError>;

    /// Releases the resource
    fn release(self: Self) -> Result<(), ResourceError>;
}

/// Error type for resource operations
pub struct ResourceError {
    message: String,
}

impl ResourceError {
    pub fn new(message: String) -> Self {
        ResourceError { message }
    }
}

impl Display for ResourceError {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        write!(f, "ResourceError: {}", self.message)
    }
}

/// Acquires a resource
pub fn acquire<R: ManagedResource>(spec: R::Spec) -> R / {Resource<R>} {
    perform acquire(spec)
}

/// Releases a resource
pub fn release<R: ManagedResource>(resource: R) / {Resource<R>} {
    perform release(resource)
}

/// Uses a resource with automatic cleanup
pub fn with_resource<R, T, F>(spec: R::Spec, f: F) -> T / {Resource<R>}
where
    R: ManagedResource,
    F: FnOnce(&R) -> T,
{
    let resource = perform acquire(spec);
    let result = f(&resource);
    perform release(resource);
    result
}

/// Uses a mutable resource with automatic cleanup
pub fn with_resource_mut<R, T, F>(spec: R::Spec, f: F) -> T / {Resource<R>}
where
    R: ManagedResource,
    F: FnOnce(&mut R) -> T,
{
    let mut resource = perform acquire(spec);
    let result = f(&mut resource);
    perform release(resource);
    result
}

/// Standard handler that manages resources with automatic cleanup
pub deep handler ResourceManager<R> for Resource<R>
where
    R: ManagedResource,
{
    let mut acquired: Vec<R> = Vec::new();

    return(x) {
        // Release all resources on normal return
        for resource in acquired.drain(..).rev() {
            let _ = resource.release();
        }
        x
    }

    op acquire(spec) {
        match R::create(spec) {
            Ok(resource) => {
                acquired.push(resource);
                resume(resource)
            }
            Err(e) => {
                // Cleanup and propagate error
                for resource in acquired.drain(..).rev() {
                    let _ = resource.release();
                }
                perform raise(e)
            }
        }
    }

    op release(resource) {
        // Remove from tracked resources
        if let Some(pos) = acquired.iter().position(|r| r == &resource) {
            acquired.remove(pos);
        }
        let _ = resource.release();
        resume(())
    }
}

/// Handler that provides pooled resources
pub deep handler ResourcePool<R> for Resource<R>
where
    R: ManagedResource + Clone,
{
    let mut pool: Vec<R>;
    let max_size: usize;
    let mut in_use: usize;

    fn new(initial: Vec<R>, max_size: usize) -> Self {
        ResourcePool {
            pool: initial,
            max_size,
            in_use: 0,
        }
    }

    return(x) { x }

    op acquire(spec) {
        let resource = if let Some(r) = pool.pop() {
            r
        } else if in_use < max_size {
            match R::create(spec) {
                Ok(r) => r,
                Err(e) => return perform raise(e),
            }
        } else {
            // Pool exhausted
            return perform raise(ResourceError::new("resource pool exhausted".to_string()))
        };
        in_use += 1;
        resume(resource)
    }

    op release(resource) {
        in_use -= 1;
        if pool.len() < max_size {
            pool.push(resource);
        } else {
            let _ = resource.release();
        }
        resume(())
    }
}

/// File handle as a managed resource
pub struct FileHandle {
    fd: i32,
    path: String,
}

pub struct FileSpec {
    pub path: String,
    pub mode: FileMode,
}

pub enum FileMode {
    Read,
    Write,
    Append,
    ReadWrite,
}

impl ManagedResource for FileHandle {
    type Spec = FileSpec;

    fn create(spec: Self::Spec) -> Result<Self, ResourceError> {
        let fd = __builtin_open_file(&spec.path, spec.mode)?;
        Ok(FileHandle { fd, path: spec.path })
    }

    fn release(self: Self) -> Result<(), ResourceError> {
        __builtin_close_file(self.fd)
    }
}

impl FileHandle {
    pub fn read(self: &Self, buf: &mut [u8]) -> Result<usize, ResourceError> {
        __builtin_read_file(self.fd, buf)
    }

    pub fn write(self: &Self, buf: &[u8]) -> Result<usize, ResourceError> {
        __builtin_write_file(self.fd, buf)
    }

    pub fn read_to_string(self: &Self) -> Result<String, ResourceError> {
        let mut content = String::new();
        let mut buf = [0u8; 4096];
        loop {
            let n = self.read(&mut buf)?;
            if n == 0 {
                break;
            }
            content.push_str(str::from_utf8(&buf[..n])?);
        }
        Ok(content)
    }
}

/// Convenience function to read a file
pub fn read_file(path: &str) -> String / {Resource<FileHandle>, Error<ResourceError>} {
    with_resource(
        FileSpec { path: path.to_string(), mode: FileMode::Read },
        |file| file.read_to_string().map_err(|e| perform raise(e))
    )
}

/// Convenience function to write a file
pub fn write_file(path: &str, content: &str) / {Resource<FileHandle>, Error<ResourceError>} {
    with_resource_mut(
        FileSpec { path: path.to_string(), mode: FileMode::Write },
        |file| {
            file.write(content.as_bytes()).map_err(|e| perform raise(e));
        }
    )
}
