// Blood Standard Library - State Effect
//
// The State<S> effect provides mutable state through algebraic effects.

/// State effect for mutable state operations
///
/// This effect provides get and put operations for managing state
/// without explicit mutation or references.
///
/// # Example
/// ```blood
/// fn counter() -> i32 / {State<i32>} {
///     let x = perform get();
///     perform put(x + 1);
///     x
/// }
///
/// fn main() {
///     let result = with_state(0, || {
///         counter();
///         counter();
///         counter()
///     });
///     println(result); // prints 2
/// }
/// ```
pub effect State<S> {
    /// Gets the current state value
    op get() -> S;

    /// Sets the state to a new value
    op put(s: S) -> unit;
}

/// Gets the current state value
pub fn get<S>() -> S / {State<S>} {
    perform get()
}

/// Sets the state to a new value
pub fn put<S>(s: S) / {State<S>} {
    perform put(s)
}

/// Modifies the state using a function
pub fn modify<S, F>(f: F) / {State<S>}
where
    F: FnOnce(S) -> S,
{
    let s = perform get();
    perform put(f(s))
}

/// Runs a computation with initial state, returning the final value
pub fn with_state<T, S, F>(initial: S, f: F) -> T / pure
where
    F: FnOnce() -> T / {State<S>},
{
    let state_handler = LocalState::new(initial);
    handle f() with state_handler {
        return(v) { v }
        get() { resume(state_handler.state) }
        put(s) { state_handler.state = s; resume(()) }
    }
}

/// Runs a computation with initial state, returning both value and final state
pub fn run_state<T, S, F>(initial: S, f: F) -> (T, S) / pure
where
    F: FnOnce() -> T / {State<S>},
{
    let state_handler = LocalState::new(initial);
    handle f() with state_handler {
        return(v) { (v, state_handler.state) }
        get() { resume(state_handler.state) }
        put(s) { state_handler.state = s; resume(()) }
    }
}

/// Executes a computation for its state effects only, discarding the value
pub fn exec_state<T, S, F>(initial: S, f: F) -> S / pure
where
    F: FnOnce() -> T / {State<S>},
{
    run_state(initial, f).1
}

/// Standard deep handler for State effect
pub deep handler LocalState<S> for State<S> {
    let mut state: S;

    fn new(initial: S) -> Self {
        LocalState { state: initial }
    }

    return(x) { x }

    op get() { resume(state) }
    op put(s) { state = s; resume(()) }
}

/// Read-only state handler (ignores put operations)
pub deep handler ReadOnlyState<S> for State<S>
where
    S: Clone,
{
    let state: S;

    fn new(value: S) -> Self {
        ReadOnlyState { state: value }
    }

    return(x) { x }

    op get() { resume(state.clone()) }
    op put(_) { resume(()) }  // Ignore writes
}

/// State handler that tracks history of all states
pub deep handler HistoryState<S> for State<S>
where
    S: Clone,
{
    let mut states: Vec<S>;
    let mut current: usize;

    fn new(initial: S) -> Self {
        HistoryState {
            states: vec![initial],
            current: 0,
        }
    }

    fn history(self: &Self) -> &[S] {
        &self.states
    }

    fn undo(self: &mut Self) -> Option<S>
    where
        S: Clone,
    {
        if self.current > 0 {
            self.current -= 1;
            Some(self.states[self.current].clone())
        } else {
            None
        }
    }

    fn redo(self: &mut Self) -> Option<S>
    where
        S: Clone,
    {
        if self.current < self.states.len() - 1 {
            self.current += 1;
            Some(self.states[self.current].clone())
        } else {
            None
        }
    }

    return(x) { x }

    op get() {
        resume(self.states[self.current].clone())
    }

    op put(s) {
        // Remove any redo history
        self.states.truncate(self.current + 1);
        self.states.push(s);
        self.current += 1;
        resume(())
    }
}

/// Lens-based state access for nested state
pub struct Lens<S, A> {
    get: fn(&S) -> A,
    set: fn(S, A) -> S,
}

impl<S, A> Lens<S, A> {
    pub fn new(get: fn(&S) -> A, set: fn(S, A) -> S) -> Self {
        Lens { get, set }
    }

    pub fn view(self: &Self, s: &S) -> A / pure {
        (self.get)(s)
    }

    pub fn set(self: &Self, s: S, a: A) -> S / pure {
        (self.set)(s, a)
    }

    pub fn modify<F>(self: &Self, s: S, f: F) -> S / pure
    where
        F: FnOnce(A) -> A,
    {
        let a = (self.get)(&s);
        (self.set)(s, f(a))
    }
}

/// Zooms into a portion of state using a lens
pub fn zoom<T, S, A, F>(lens: &Lens<S, A>, f: F) -> T / {State<S>}
where
    F: FnOnce() -> T / {State<A>},
{
    handle f() {
        return(v) { v }
        get() {
            let s: S = perform get();
            resume(lens.view(&s))
        }
        put(a) {
            let s: S = perform get();
            perform put(lens.set(s, a));
            resume(())
        }
    }
}
