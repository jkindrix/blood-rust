// Blood Standard Library - I/O Effect Handlers
//
// Handlers for the IO effect.

use crate::effects::io::IO;
use crate::io::{Read, Write, BufRead, Error, ErrorKind, Result};

/// Handler that captures all I/O operations to a buffer
pub deep handler CaptureIO for IO {
    let mut stdout_buffer: Vec<u8>;
    let mut stderr_buffer: Vec<u8>;
    let mut stdin_data: Vec<u8>;
    let mut stdin_pos: usize;

    fn new() -> Self {
        CaptureIO {
            stdout_buffer: Vec::new(),
            stderr_buffer: Vec::new(),
            stdin_data: Vec::new(),
            stdin_pos: 0,
        }
    }

    fn with_stdin(input: Vec<u8>) -> Self {
        CaptureIO {
            stdout_buffer: Vec::new(),
            stderr_buffer: Vec::new(),
            stdin_data: input,
            stdin_pos: 0,
        }
    }

    fn stdout(self: &Self) -> &[u8] {
        &self.stdout_buffer
    }

    fn stderr(self: &Self) -> &[u8] {
        &self.stderr_buffer
    }

    fn stdout_str(self: &Self) -> Result<&str> / pure {
        core::str::from_utf8(&self.stdout_buffer)
            .map_err(|_| Error::from_kind(ErrorKind::InvalidData))
    }

    fn stderr_str(self: &Self) -> Result<&str> / pure {
        core::str::from_utf8(&self.stderr_buffer)
            .map_err(|_| Error::from_kind(ErrorKind::InvalidData))
    }

    return(x) { (x, self.stdout_buffer, self.stderr_buffer) }

    op print(s: &str) {
        self.stdout_buffer.extend_from_slice(s.as_bytes());
        resume(())
    }

    op println(s: &str) {
        self.stdout_buffer.extend_from_slice(s.as_bytes());
        self.stdout_buffer.push(b'\n');
        resume(())
    }

    op eprint(s: &str) {
        self.stderr_buffer.extend_from_slice(s.as_bytes());
        resume(())
    }

    op eprintln(s: &str) {
        self.stderr_buffer.extend_from_slice(s.as_bytes());
        self.stderr_buffer.push(b'\n');
        resume(())
    }

    op read_line() {
        let start = self.stdin_pos;
        while self.stdin_pos < self.stdin_data.len() {
            if self.stdin_data[self.stdin_pos] == b'\n' {
                self.stdin_pos += 1;
                break;
            }
            self.stdin_pos += 1;
        }
        let line = String::from_utf8_lossy(&self.stdin_data[start..self.stdin_pos]).into_owned();
        resume(line)
    }
}

/// Handler that discards all I/O (null device)
pub deep handler NullIO for IO {
    return(x) { x }

    op print(_s: &str) {
        resume(())
    }

    op println(_s: &str) {
        resume(())
    }

    op eprint(_s: &str) {
        resume(())
    }

    op eprintln(_s: &str) {
        resume(())
    }

    op read_line() {
        resume(String::new())
    }
}

/// Handler that logs all I/O operations
pub deep handler LoggingIO for IO {
    let mut operations: Vec<IOOperation>;

    fn new() -> Self {
        LoggingIO { operations: Vec::new() }
    }

    fn into_operations(self: Self) -> Vec<IOOperation> {
        self.operations
    }

    return(x) { (x, self.operations) }

    op print(s: &str) {
        self.operations.push(IOOperation::Print(s.to_string()));
        __builtin_print(s);
        resume(())
    }

    op println(s: &str) {
        self.operations.push(IOOperation::Println(s.to_string()));
        __builtin_println(s);
        resume(())
    }

    op eprint(s: &str) {
        self.operations.push(IOOperation::Eprint(s.to_string()));
        __builtin_eprint(s);
        resume(())
    }

    op eprintln(s: &str) {
        self.operations.push(IOOperation::Eprintln(s.to_string()));
        __builtin_eprintln(s);
        resume(())
    }

    op read_line() {
        let line = __builtin_read_line();
        self.operations.push(IOOperation::ReadLine(line.clone()));
        resume(line)
    }
}

/// A recorded I/O operation
#[derive(Clone, Debug)]
pub enum IOOperation {
    Print(String),
    Println(String),
    Eprint(String),
    Eprintln(String),
    ReadLine(String),
}

/// Handler that prefixes all output
pub deep handler PrefixedIO for IO {
    let prefix: String;

    fn new(prefix: impl Into<String>) -> Self {
        PrefixedIO { prefix: prefix.into() }
    }

    return(x) { x }

    op print(s: &str) {
        __builtin_print(&self.prefix);
        __builtin_print(s);
        resume(())
    }

    op println(s: &str) {
        __builtin_print(&self.prefix);
        __builtin_println(s);
        resume(())
    }

    op eprint(s: &str) {
        __builtin_eprint(&self.prefix);
        __builtin_eprint(s);
        resume(())
    }

    op eprintln(s: &str) {
        __builtin_eprint(&self.prefix);
        __builtin_eprintln(s);
        resume(())
    }

    op read_line() {
        resume(__builtin_read_line())
    }
}

/// Handler that colorizes output
pub deep handler ColorizedIO for IO {
    let stdout_color: Option<Color>;
    let stderr_color: Option<Color>;

    fn new(stdout_color: Option<Color>, stderr_color: Option<Color>) -> Self {
        ColorizedIO { stdout_color, stderr_color }
    }

    return(x) { x }

    op print(s: &str) {
        if let Some(color) = &self.stdout_color {
            __builtin_print(&color.ansi_code());
            __builtin_print(s);
            __builtin_print("\x1b[0m");
        } else {
            __builtin_print(s);
        }
        resume(())
    }

    op println(s: &str) {
        if let Some(color) = &self.stdout_color {
            __builtin_print(&color.ansi_code());
            __builtin_print(s);
            __builtin_println("\x1b[0m");
        } else {
            __builtin_println(s);
        }
        resume(())
    }

    op eprint(s: &str) {
        if let Some(color) = &self.stderr_color {
            __builtin_eprint(&color.ansi_code());
            __builtin_eprint(s);
            __builtin_eprint("\x1b[0m");
        } else {
            __builtin_eprint(s);
        }
        resume(())
    }

    op eprintln(s: &str) {
        if let Some(color) = &self.stderr_color {
            __builtin_eprint(&color.ansi_code());
            __builtin_eprint(s);
            __builtin_eprintln("\x1b[0m");
        } else {
            __builtin_eprintln(s);
        }
        resume(())
    }

    op read_line() {
        resume(__builtin_read_line())
    }
}

/// Terminal colors
#[derive(Clone, Copy, Debug)]
pub enum Color {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,
    Rgb(u8, u8, u8),
}

impl Color {
    pub fn ansi_code(self: &Self) -> String / pure {
        match self {
            Color::Black => "\x1b[30m".to_string(),
            Color::Red => "\x1b[31m".to_string(),
            Color::Green => "\x1b[32m".to_string(),
            Color::Yellow => "\x1b[33m".to_string(),
            Color::Blue => "\x1b[34m".to_string(),
            Color::Magenta => "\x1b[35m".to_string(),
            Color::Cyan => "\x1b[36m".to_string(),
            Color::White => "\x1b[37m".to_string(),
            Color::BrightBlack => "\x1b[90m".to_string(),
            Color::BrightRed => "\x1b[91m".to_string(),
            Color::BrightGreen => "\x1b[92m".to_string(),
            Color::BrightYellow => "\x1b[93m".to_string(),
            Color::BrightBlue => "\x1b[94m".to_string(),
            Color::BrightMagenta => "\x1b[95m".to_string(),
            Color::BrightCyan => "\x1b[96m".to_string(),
            Color::BrightWhite => "\x1b[97m".to_string(),
            Color::Rgb(r, g, b) => format!("\x1b[38;2;{};{};{}m", r, g, b),
        }
    }
}

/// Handler for file I/O operations
pub deep handler FileIO for IO {
    return(x) { x }

    // Standard IO operations pass through to actual I/O
    op print(s: &str) {
        __builtin_print(s);
        resume(())
    }

    op println(s: &str) {
        __builtin_println(s);
        resume(())
    }

    op eprint(s: &str) {
        __builtin_eprint(s);
        resume(())
    }

    op eprintln(s: &str) {
        __builtin_eprintln(s);
        resume(())
    }

    op read_line() {
        resume(__builtin_read_line())
    }
}

/// Runs a computation with captured I/O
pub fn with_captured_io<T, F>(f: F) -> (T, Vec<u8>, Vec<u8>) / pure
where
    F: FnOnce() -> T / {IO},
{
    let handler = CaptureIO::new();
    handle f() with handler {
        return(v) { (v, handler.stdout_buffer, handler.stderr_buffer) }
    }
}

/// Runs a computation with mock stdin input
pub fn with_mock_stdin<T, F>(input: &str, f: F) -> T / pure
where
    F: FnOnce() -> T / {IO},
{
    let handler = CaptureIO::with_stdin(input.as_bytes().to_vec());
    handle f() with handler {
        return(v) { v }
    }
}

/// Runs a computation with all I/O discarded
pub fn with_null_io<T, F>(f: F) -> T / pure
where
    F: FnOnce() -> T / {IO},
{
    handle f() with NullIO {
        return(v) { v }
    }
}

/// Runs a computation and collects I/O operations
pub fn with_logged_io<T, F>(f: F) -> (T, Vec<IOOperation>) / {IO}
where
    F: FnOnce() -> T / {IO},
{
    let handler = LoggingIO::new();
    handle f() with handler {
        return(v) { (v, handler.operations) }
    }
}

/// Buffered output handler that batches writes
pub deep handler BufferedOutput for IO {
    let mut buffer: Vec<u8>;
    let flush_threshold: usize;

    fn new(flush_threshold: usize) -> Self {
        BufferedOutput {
            buffer: Vec::new(),
            flush_threshold,
        }
    }

    fn flush(self: &mut Self) / {IO} {
        if !self.buffer.is_empty() {
            let s = String::from_utf8_lossy(&self.buffer);
            __builtin_print(&s);
            self.buffer.clear();
        }
    }

    return(x) {
        self.flush();
        x
    }

    op print(s: &str) {
        self.buffer.extend_from_slice(s.as_bytes());
        if self.buffer.len() >= self.flush_threshold {
            self.flush();
        }
        resume(())
    }

    op println(s: &str) {
        self.buffer.extend_from_slice(s.as_bytes());
        self.buffer.push(b'\n');
        if self.buffer.len() >= self.flush_threshold {
            self.flush();
        }
        resume(())
    }

    op eprint(s: &str) {
        // stderr is not buffered
        __builtin_eprint(s);
        resume(())
    }

    op eprintln(s: &str) {
        // stderr is not buffered
        __builtin_eprintln(s);
        resume(())
    }

    op read_line() {
        // Flush before reading
        self.flush();
        resume(__builtin_read_line())
    }
}

/// Tee handler that duplicates output to multiple destinations
pub deep handler TeeIO<W: Write> for IO {
    let mut secondary: W;

    fn new(secondary: W) -> Self {
        TeeIO { secondary }
    }

    return(x) { x }

    op print(s: &str) {
        __builtin_print(s);
        let _ = self.secondary.write_all(s.as_bytes());
        resume(())
    }

    op println(s: &str) {
        __builtin_println(s);
        let _ = self.secondary.write_all(s.as_bytes());
        let _ = self.secondary.write_all(b"\n");
        resume(())
    }

    op eprint(s: &str) {
        __builtin_eprint(s);
        resume(())
    }

    op eprintln(s: &str) {
        __builtin_eprintln(s);
        resume(())
    }

    op read_line() {
        resume(__builtin_read_line())
    }
}
