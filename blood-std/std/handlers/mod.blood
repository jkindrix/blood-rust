// Blood Standard Library - Standard Effect Handlers
//
// Pre-built handlers for common effect patterns.

pub mod error_handlers;
pub mod state_handlers;
pub mod io_handlers;
pub mod async_handlers;
pub mod resource_handlers;

pub use error_handlers::*;
pub use state_handlers::*;
pub use io_handlers::*;
pub use async_handlers::*;
pub use resource_handlers::*;

// =============================================================================
// Effect Composition Utilities
// =============================================================================

/// Composes two handlers in sequence
///
/// When handling `do f() with handler1 { ... } with handler2 { ... }`,
/// handler1 is the inner handler and handler2 is the outer handler.
pub macro compose_handlers {
    ($inner:ty, $outer:ty) => {
        ComposedHandler<$inner, $outer>
    };
}

/// A composed handler that applies two handlers in sequence
pub struct ComposedHandler<Inner, Outer> {
    inner: Inner,
    outer: Outer,
}

impl<Inner, Outer> ComposedHandler<Inner, Outer> {
    pub fn new(inner: Inner, outer: Outer) -> Self / pure {
        ComposedHandler { inner, outer }
    }
}

// =============================================================================
// Identity Handler
// =============================================================================

/// A handler that does nothing, passing effects through
pub deep handler Identity for * {
    return(x) { x }
    // No effect handlers - all effects pass through
}

// =============================================================================
// Common Combinators
// =============================================================================

/// Runs a computation, catching any panics
pub fn catch_panic<T, F: FnOnce() -> T / {Panic}>(f: F) -> Result<T, String> / pure {
    handle f() with CatchPanic {
        return(v) { Ok(v) }
    }
}

/// Runs a computation with a timeout
pub fn with_timeout<T, F>(duration: Duration, f: F) -> Result<T, TimeoutError> / {Async}
where
    F: FnOnce() -> T / {Async},
{
    handle f() with Timeout::new(duration) {
        return(v) { Ok(v) }
    }
}

/// Timeout error
pub struct TimeoutError;

impl Debug for TimeoutError {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("operation timed out")
    }
}

impl Display for TimeoutError {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("operation timed out")
    }
}

/// Timeout handler
pub deep handler Timeout for Async {
    let deadline: Instant;

    fn new(duration: Duration) -> Self {
        Timeout {
            deadline: Instant::now() + duration,
        }
    }

    return(x) { Ok(x) }

    op yield_() {
        if Instant::now() >= self.deadline {
            Err(TimeoutError)
        } else {
            resume(())
        }
    }

    op sleep(duration: Duration) {
        if Instant::now() + duration >= self.deadline {
            Err(TimeoutError)
        } else {
            __builtin_sleep(duration);
            resume(())
        }
    }
}

// =============================================================================
// Retry Handler
// =============================================================================

/// Configuration for retry behavior
pub struct RetryConfig {
    pub max_attempts: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub multiplier: f64,
}

impl Default for RetryConfig {
    fn default() -> Self / pure {
        RetryConfig {
            max_attempts: 3,
            initial_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(10),
            multiplier: 2.0,
        }
    }
}

/// Runs a computation with automatic retries on failure
pub fn with_retry<T, E, F>(config: RetryConfig, f: F) -> Result<T, E> / {Error<E>, IO}
where
    F: Fn() -> T / {Error<E>},
{
    let mut attempts = 0;
    let mut delay = config.initial_delay;

    loop {
        attempts += 1;

        let result = handle f() with ErrorToResult {
            return(v) { Ok(v) }
        };

        match result {
            Ok(v) => return Ok(v),
            Err(e) if attempts >= config.max_attempts => return Err(e),
            Err(_) => {
                __builtin_sleep(delay);
                delay = Duration::from_millis(
                    ((delay.as_millis() as f64) * config.multiplier) as u64
                ).min(config.max_delay);
            }
        }
    }
}

// =============================================================================
// Transaction Handler
// =============================================================================

/// A transaction effect for rollback semantics
pub effect Transaction<S> {
    /// Gets the current state
    op get() -> S;
    /// Sets the state
    op put(s: S) -> unit;
    /// Commits the transaction
    op commit() -> unit;
    /// Aborts and rolls back
    op abort() -> !;
}

/// Handler for transaction semantics with rollback
pub deep handler TransactionHandler<S: Clone> for Transaction<S> {
    let mut current: S;
    let checkpoint: S;

    fn new(initial: S) -> Self {
        TransactionHandler {
            current: initial.clone(),
            checkpoint: initial,
        }
    }

    fn result(self: Self) -> S {
        self.current
    }

    return(x) { (x, self.current) }

    op get() {
        resume(self.current.clone())
    }

    op put(s: S) {
        self.current = s;
        resume(())
    }

    op commit() {
        self.checkpoint = self.current.clone();
        resume(())
    }

    op abort() {
        self.current = self.checkpoint.clone();
        // Don't resume - transaction aborted
    }
}

/// Runs a computation in a transaction
pub fn transact<S: Clone, T, F>(initial: S, f: F) -> (T, S) / pure
where
    F: FnOnce() -> T / {Transaction<S>},
{
    let handler = TransactionHandler::new(initial);
    handle f() with handler {
        return(v) { handler.result(); (v, handler.current) }
    }
}

// =============================================================================
// Logging Handler
// =============================================================================

/// Log level
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub enum LogLevel {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
}

/// Logging effect
pub effect Log {
    op log(level: LogLevel, message: &str) -> unit;
}

/// Simple console logging handler
pub deep handler ConsoleLogger for Log {
    let min_level: LogLevel;

    fn new(min_level: LogLevel) -> Self {
        ConsoleLogger { min_level }
    }

    return(x) { x }

    op log(level: LogLevel, message: &str) {
        if level >= self.min_level {
            let prefix = match level {
                LogLevel::Trace => "[TRACE]",
                LogLevel::Debug => "[DEBUG]",
                LogLevel::Info => "[INFO]",
                LogLevel::Warn => "[WARN]",
                LogLevel::Error => "[ERROR]",
            };
            eprintln!("{} {}", prefix, message);
        }
        resume(())
    }
}

/// Buffered logging handler that collects logs
pub deep handler BufferedLogger for Log {
    let mut logs: Vec<(LogLevel, String)>;

    fn new() -> Self {
        BufferedLogger { logs: Vec::new() }
    }

    fn into_logs(self: Self) -> Vec<(LogLevel, String)> {
        self.logs
    }

    return(x) { (x, self.logs) }

    op log(level: LogLevel, message: &str) {
        self.logs.push((level, message.to_string()));
        resume(())
    }
}

/// Silent logging handler that discards all logs
pub deep handler SilentLogger for Log {
    return(x) { x }

    op log(_level: LogLevel, _message: &str) {
        resume(())
    }
}

// =============================================================================
// Telemetry Handler
// =============================================================================

/// Telemetry effect for tracing
pub effect Telemetry {
    /// Starts a span
    op start_span(name: &str) -> SpanId;
    /// Ends a span
    op end_span(id: SpanId) -> unit;
    /// Records an event
    op record_event(name: &str) -> unit;
}

/// Span identifier
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct SpanId(u64);

/// Handler that collects telemetry data
pub deep handler TelemetryCollector for Telemetry {
    let mut next_id: u64;
    let mut spans: Vec<SpanData>;
    let mut events: Vec<EventData>;

    fn new() -> Self {
        TelemetryCollector {
            next_id: 0,
            spans: Vec::new(),
            events: Vec::new(),
        }
    }

    return(x) { x }

    op start_span(name: &str) {
        let id = SpanId(self.next_id);
        self.next_id += 1;
        self.spans.push(SpanData {
            id,
            name: name.to_string(),
            start: Instant::now(),
            end: None,
        });
        resume(id)
    }

    op end_span(id: SpanId) {
        for span in &mut self.spans {
            if span.id == id {
                span.end = Some(Instant::now());
                break;
            }
        }
        resume(())
    }

    op record_event(name: &str) {
        self.events.push(EventData {
            name: name.to_string(),
            time: Instant::now(),
        });
        resume(())
    }
}

/// Span data
pub struct SpanData {
    pub id: SpanId,
    pub name: String,
    pub start: Instant,
    pub end: Option<Instant>,
}

/// Event data
pub struct EventData {
    pub name: String,
    pub time: Instant,
}

/// Handler that discards telemetry
pub deep handler NullTelemetry for Telemetry {
    let mut next_id: u64 = 0;

    return(x) { x }

    op start_span(_name: &str) {
        let id = SpanId(self.next_id);
        self.next_id += 1;
        resume(id)
    }

    op end_span(_id: SpanId) {
        resume(())
    }

    op record_event(_name: &str) {
        resume(())
    }
}

// =============================================================================
// Resource Pool Handler
// =============================================================================

/// A pool of reusable resources
pub struct Pool<T> {
    items: Vec<Option<T>>,
    available: Vec<usize>,
}

impl<T> Pool<T> {
    pub fn new() -> Self / pure {
        Pool {
            items: Vec::new(),
            available: Vec::new(),
        }
    }

    pub fn with_capacity(capacity: usize) -> Self / pure {
        Pool {
            items: Vec::with_capacity(capacity),
            available: Vec::new(),
        }
    }

    pub fn add(self: &mut Self, item: T) -> usize / pure {
        let idx = self.items.len();
        self.items.push(Some(item));
        idx
    }

    pub fn acquire(self: &mut Self) -> Option<(usize, &mut T)> / pure {
        let idx = self.available.pop()?;
        self.items[idx].as_mut().map(|item| (idx, item))
    }

    pub fn release(self: &mut Self, idx: usize) / pure {
        if idx < self.items.len() && self.items[idx].is_some() {
            self.available.push(idx);
        }
    }
}
