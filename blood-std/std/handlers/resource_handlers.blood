// Blood Standard Library - Resource Effect Handlers
//
// Handlers for resource management effects (RAII, bracketing, etc.)

use crate::effects::error::Error;

/// Resource management effect
pub effect Resource<R> {
    /// Acquires a resource
    op acquire() -> R;
    /// Releases a resource
    op release(r: R) -> unit;
    /// Uses a resource
    op use_resource<T>(r: &R, f: fn(&R) -> T) -> T;
}

/// Basic resource handler that manages resource lifecycle
pub deep handler ResourceHandler<R, Acquire, Release> for Resource<R>
where
    Acquire: FnOnce() -> R,
    Release: FnOnce(R),
{
    let acquire_fn: Acquire;
    let release_fn: Release;
    let mut resource: Option<R>;

    fn new(acquire: Acquire, release: Release) -> Self {
        ResourceHandler {
            acquire_fn: acquire,
            release_fn: release,
            resource: None,
        }
    }

    return(x) {
        // Ensure resource is released on normal return
        if let Some(r) = self.resource.take() {
            (self.release_fn)(r);
        }
        x
    }

    op acquire() {
        let r = (self.acquire_fn)();
        self.resource = Some(r.clone());
        resume(r)
    }

    op release(r: R) {
        (self.release_fn)(r);
        self.resource = None;
        resume(())
    }

    op use_resource<T>(r: &R, f: fn(&R) -> T) {
        resume(f(r))
    }
}

/// Bracket pattern for resource management
pub fn bracket<R, T, Acquire, Use, Release>(
    acquire: Acquire,
    use_fn: Use,
    release: Release,
) -> T / pure
where
    Acquire: FnOnce() -> R,
    Use: FnOnce(&R) -> T,
    Release: FnOnce(R),
{
    let resource = acquire();
    let result = use_fn(&resource);
    release(resource);
    result
}

/// Bracket pattern with error handling
pub fn bracket_with_error<R, T, E, Acquire, Use, Release>(
    acquire: Acquire,
    use_fn: Use,
    release: Release,
) -> T / {Error<E>}
where
    Acquire: FnOnce() -> R / {Error<E>},
    Use: FnOnce(&R) -> T / {Error<E>},
    Release: FnOnce(R),
{
    let resource = acquire();
    // Use defer to ensure release happens even on error
    defer { release(resource.clone()) };
    use_fn(&resource)
}

/// Pool effect for pooled resources
pub effect Pool<R> {
    /// Acquires a resource from the pool
    op acquire() -> PooledResource<R>;
    /// Returns a resource to the pool
    op release(r: PooledResource<R>) -> unit;
}

/// A resource acquired from a pool
pub struct PooledResource<R> {
    inner: R,
    pool_id: usize,
}

impl<R> PooledResource<R> {
    pub fn get(self: &Self) -> &R / pure {
        &self.inner
    }

    pub fn get_mut(self: &mut Self) -> &mut R / pure {
        &mut self.inner
    }

    pub fn into_inner(self: Self) -> R / pure {
        self.inner
    }
}

impl<R> core::ops::Deref for PooledResource<R> {
    type Target = R;

    fn deref(self: &Self) -> &Self::Target / pure {
        &self.inner
    }
}

impl<R> core::ops::DerefMut for PooledResource<R> {
    fn deref_mut(self: &mut Self) -> &mut Self::Target / pure {
        &mut self.inner
    }
}

/// Handler for a resource pool
pub deep handler PoolHandler<R, Create> for Pool<R>
where
    Create: Fn() -> R,
{
    let create_fn: Create;
    let mut available: Vec<R>;
    let mut next_id: usize;
    let max_size: usize;

    fn new(create: Create, initial_size: usize, max_size: usize) -> Self {
        let mut available = Vec::with_capacity(initial_size);
        for _ in 0..initial_size {
            available.push(create());
        }
        PoolHandler {
            create_fn: create,
            available,
            next_id: 0,
            max_size,
        }
    }

    fn available_count(self: &Self) -> usize {
        self.available.len()
    }

    return(x) { x }

    op acquire() {
        let resource = if let Some(r) = self.available.pop() {
            r
        } else if self.available.len() < self.max_size {
            (self.create_fn)()
        } else {
            // Pool exhausted - could block or error
            // For now, create anyway
            (self.create_fn)()
        };

        let id = self.next_id;
        self.next_id += 1;

        resume(PooledResource {
            inner: resource,
            pool_id: id,
        })
    }

    op release(r: PooledResource<R>) {
        if self.available.len() < self.max_size {
            self.available.push(r.into_inner());
        }
        // If over max, just drop it
        resume(())
    }
}

/// Scoped resource that is automatically released
pub struct Scoped<R, Release>
where
    Release: FnOnce(R),
{
    resource: Option<R>,
    release: Option<Release>,
}

impl<R, Release> Scoped<R, Release>
where
    Release: FnOnce(R),
{
    pub fn new(resource: R, release: Release) -> Self / pure {
        Scoped {
            resource: Some(resource),
            release: Some(release),
        }
    }

    pub fn get(self: &Self) -> &R / pure {
        self.resource.as_ref().unwrap()
    }

    pub fn get_mut(self: &mut Self) -> &mut R / pure {
        self.resource.as_mut().unwrap()
    }

    pub fn into_inner(self: Self) -> R / pure {
        // Don't run release
        let r = self.resource.unwrap();
        core::mem::forget(self.release);
        r
    }
}

impl<R, Release> Drop for Scoped<R, Release>
where
    Release: FnOnce(R),
{
    fn drop(self: &mut Self) / pure {
        if let (Some(r), Some(release)) = (self.resource.take(), self.release.take()) {
            release(r);
        }
    }
}

impl<R, Release> core::ops::Deref for Scoped<R, Release>
where
    Release: FnOnce(R),
{
    type Target = R;

    fn deref(self: &Self) -> &Self::Target / pure {
        self.get()
    }
}

impl<R, Release> core::ops::DerefMut for Scoped<R, Release>
where
    Release: FnOnce(R),
{
    fn deref_mut(self: &mut Self) -> &mut Self::Target / pure {
        self.get_mut()
    }
}

/// Creates a scoped resource
pub fn scoped<R, Release>(resource: R, release: Release) -> Scoped<R, Release> / pure
where
    Release: FnOnce(R),
{
    Scoped::new(resource, release)
}

/// Finalizer effect for cleanup actions
pub effect Finalizer {
    /// Registers a finalizer to run on scope exit
    op register(f: Box<dyn FnOnce()>) -> FinalizerId;
    /// Cancels a finalizer
    op cancel(id: FinalizerId) -> bool;
}

/// ID for a registered finalizer
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct FinalizerId(u64);

/// Handler that collects and runs finalizers
pub deep handler FinalizerHandler for Finalizer {
    let mut finalizers: Vec<Option<Box<dyn FnOnce()>>>;
    let mut next_id: u64;

    fn new() -> Self {
        FinalizerHandler {
            finalizers: Vec::new(),
            next_id: 0,
        }
    }

    return(x) {
        // Run all finalizers in reverse order
        while let Some(opt_f) = self.finalizers.pop() {
            if let Some(f) = opt_f {
                f();
            }
        }
        x
    }

    op register(f: Box<dyn FnOnce()>) {
        let id = FinalizerId(self.next_id);
        self.next_id += 1;
        self.finalizers.push(Some(f));
        resume(id)
    }

    op cancel(id: FinalizerId) {
        let idx = id.0 as usize;
        if idx < self.finalizers.len() && self.finalizers[idx].is_some() {
            self.finalizers[idx] = None;
            resume(true)
        } else {
            resume(false)
        }
    }
}

/// Runs a computation with finalizer support
pub fn with_finalizers<T, F>(f: F) -> T / pure
where
    F: FnOnce() -> T / {Finalizer},
{
    let handler = FinalizerHandler::new();
    handle f() with handler {
        return(v) { v }
    }
}

/// Registers a finalizer
pub fn defer_fn<F: FnOnce() + 'static>(f: F) -> FinalizerId / {Finalizer} {
    perform register(Box::new(f))
}

/// Cancels a finalizer
pub fn cancel_defer(id: FinalizerId) -> bool / {Finalizer} {
    perform cancel(id)
}

/// Leak detection effect
pub effect LeakDetector<R> {
    /// Tracks a resource allocation
    op track(r: &R) -> TrackingId;
    /// Marks a resource as released
    op untrack(id: TrackingId) -> unit;
    /// Reports unreleased resources
    op report() -> Vec<TrackingId>;
}

/// ID for tracked resources
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub struct TrackingId(u64);

/// Handler for leak detection
pub deep handler LeakDetectorHandler<R> for LeakDetector<R> {
    let mut tracked: Vec<(TrackingId, bool)>; // (id, still_alive)
    let mut next_id: u64;

    fn new() -> Self {
        LeakDetectorHandler {
            tracked: Vec::new(),
            next_id: 0,
        }
    }

    fn leaked_count(self: &Self) -> usize {
        self.tracked.iter().filter(|(_, alive)| *alive).count()
    }

    return(x) {
        let leaked: Vec<_> = self.tracked
            .iter()
            .filter(|(_, alive)| *alive)
            .map(|(id, _)| *id)
            .collect();
        if !leaked.is_empty() {
            eprintln!("Warning: {} resources were not released", leaked.len());
        }
        x
    }

    op track(_r: &R) {
        let id = TrackingId(self.next_id);
        self.next_id += 1;
        self.tracked.push((id, true));
        resume(id)
    }

    op untrack(id: TrackingId) {
        for (tracked_id, alive) in &mut self.tracked {
            if *tracked_id == id {
                *alive = false;
                break;
            }
        }
        resume(())
    }

    op report() {
        let leaked: Vec<_> = self.tracked
            .iter()
            .filter(|(_, alive)| *alive)
            .map(|(id, _)| *id)
            .collect();
        resume(leaked)
    }
}

/// Reference counting effect
pub effect RefCounted<R> {
    /// Increments reference count
    op inc_ref(r: &R) -> unit;
    /// Decrements reference count, returns true if resource should be freed
    op dec_ref(r: &R) -> bool;
    /// Gets current reference count
    op ref_count(r: &R) -> usize;
}

/// Simple reference counting handler
pub deep handler RefCountHandler for RefCounted<*const ()> {
    let mut counts: Vec<(*const (), usize)>;

    fn new() -> Self {
        RefCountHandler { counts: Vec::new() }
    }

    return(x) { x }

    op inc_ref(r: &*const ()) {
        let ptr = *r;
        for (p, count) in &mut self.counts {
            if *p == ptr {
                *count += 1;
                resume(());
                return;
            }
        }
        // New resource
        self.counts.push((ptr, 1));
        resume(())
    }

    op dec_ref(r: &*const ()) {
        let ptr = *r;
        for (p, count) in &mut self.counts {
            if *p == ptr {
                *count -= 1;
                let should_free = *count == 0;
                resume(should_free);
                return;
            }
        }
        resume(false)
    }

    op ref_count(r: &*const ()) {
        let ptr = *r;
        for (p, count) in &self.counts {
            if *p == ptr {
                resume(*count);
                return;
            }
        }
        resume(0)
    }
}

/// RAII guard that runs a function on drop
pub struct Guard<F: FnOnce()> {
    f: Option<F>,
}

impl<F: FnOnce()> Guard<F> {
    pub fn new(f: F) -> Self / pure {
        Guard { f: Some(f) }
    }

    /// Disarms the guard, preventing the function from running
    pub fn disarm(self: &mut Self) / pure {
        self.f = None;
    }

    /// Takes the function without running it
    pub fn into_inner(self: Self) -> Option<F> / pure {
        let mut this = self;
        this.f.take()
    }
}

impl<F: FnOnce()> Drop for Guard<F> {
    fn drop(self: &mut Self) / pure {
        if let Some(f) = self.f.take() {
            f();
        }
    }
}

/// Creates a guard that runs a function on scope exit
pub fn guard<F: FnOnce()>(f: F) -> Guard<F> / pure {
    Guard::new(f)
}

/// Disposable resource trait
pub trait Disposable {
    /// Disposes of the resource
    fn dispose(self: Self) / pure;
}

/// Handler that automatically disposes resources
pub deep handler AutoDispose<R: Disposable> for Resource<R> {
    let mut resources: Vec<R>;

    fn new() -> Self {
        AutoDispose { resources: Vec::new() }
    }

    return(x) {
        // Dispose all resources
        for r in self.resources.drain(..) {
            r.dispose();
        }
        x
    }

    op acquire() {
        // This handler doesn't know how to acquire, so it must be composed
        // with something that provides the actual acquisition
        panic!("AutoDispose must be composed with an acquisition handler")
    }

    op release(r: R) {
        r.dispose();
        resume(())
    }

    op use_resource<T>(r: &R, f: fn(&R) -> T) {
        resume(f(r))
    }
}

/// Using block for automatic resource management
pub macro using {
    ($binding:ident = $acquire:expr => $release:expr; $body:expr) => {{
        let $binding = $acquire;
        let _guard = guard(|| $release);
        $body
    }};
}

/// Multiple resource using block
pub macro using_all {
    ($(let $binding:ident = $acquire:expr => $release:expr);+ ; $body:expr) => {{
        $(
            let $binding = $acquire;
            let _guard = guard(|| $release);
        )+
        $body
    }};
}
