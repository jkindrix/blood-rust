// Blood Standard Library - State Effect Handlers
//
// Handlers for the State<S> effect.

use crate::effects::state::State;

/// Basic state handler that maintains mutable state
pub deep handler StateHandler<S> for State<S> {
    let mut state: S;

    fn new(initial: S) -> Self {
        StateHandler { state: initial }
    }

    fn into_state(self: Self) -> S {
        self.state
    }

    return(x) { (x, self.state) }

    op get() {
        resume(self.state.clone())
    }

    op put(s: S) {
        self.state = s;
        resume(())
    }
}

/// State handler that tracks modification history
pub deep handler HistoryState<S: Clone> for State<S> {
    let mut current: S;
    let mut history: Vec<S>;
    let max_history: usize;

    fn new(initial: S, max_history: usize) -> Self {
        HistoryState {
            current: initial.clone(),
            history: vec![initial],
            max_history,
        }
    }

    fn undo(self: &mut Self) -> bool {
        if self.history.len() > 1 {
            self.history.pop();
            self.current = self.history.last().unwrap().clone();
            true
        } else {
            false
        }
    }

    fn history(self: &Self) -> &[S] {
        &self.history
    }

    return(x) { (x, self.current, self.history) }

    op get() {
        resume(self.current.clone())
    }

    op put(s: S) {
        self.current = s.clone();
        self.history.push(s);
        if self.history.len() > self.max_history {
            self.history.remove(0);
        }
        resume(())
    }
}

/// Read-only state handler (ignores put operations)
pub deep handler ReadOnlyState<S: Clone> for State<S> {
    let state: S;

    fn new(state: S) -> Self {
        ReadOnlyState { state }
    }

    return(x) { x }

    op get() {
        resume(self.state.clone())
    }

    op put(_s: S) {
        // Ignore write attempts
        resume(())
    }
}

/// State handler that logs all changes
pub deep handler LoggingState<S: Clone + Debug> for State<S> {
    let mut state: S;
    let mut log: Vec<StateChange<S>>;

    fn new(initial: S) -> Self {
        LoggingState {
            state: initial,
            log: Vec::new(),
        }
    }

    fn into_log(self: Self) -> Vec<StateChange<S>> {
        self.log
    }

    return(x) { (x, self.state, self.log) }

    op get() {
        self.log.push(StateChange::Read(self.state.clone()));
        resume(self.state.clone())
    }

    op put(s: S) {
        self.log.push(StateChange::Write {
            old: self.state.clone(),
            new: s.clone(),
        });
        self.state = s;
        resume(())
    }
}

/// A state change record
pub enum StateChange<S> {
    Read(S),
    Write { old: S, new: S },
}

/// State handler with validation
pub deep handler ValidatedState<S, F> for State<S>
where
    F: Fn(&S) -> bool,
{
    let mut state: S;
    let validator: F;

    fn new(initial: S, validator: F) -> Self {
        assert!(validator(&initial), "initial state is invalid");
        ValidatedState { state: initial, validator }
    }

    return(x) { (x, self.state) }

    op get() {
        resume(self.state.clone())
    }

    op put(s: S) {
        if (self.validator)(&s) {
            self.state = s;
            resume(())
        } else {
            perform raise(ValidationError)
        }
    }
}

/// Validation error for state updates
pub struct ValidationError;

impl Debug for ValidationError {
    fn fmt(self: &Self, f: &mut Formatter) -> fmt::Result / {IO} {
        f.write_str("state validation failed")
    }
}

/// State handler that notifies on changes
pub deep handler ObservableState<S: Clone + PartialEq, F> for State<S>
where
    F: FnMut(&S, &S),
{
    let mut state: S;
    let mut on_change: F;

    fn new(initial: S, on_change: F) -> Self {
        ObservableState { state: initial, on_change }
    }

    return(x) { (x, self.state) }

    op get() {
        resume(self.state.clone())
    }

    op put(s: S) {
        if self.state != s {
            let old = mem::replace(&mut self.state, s);
            (self.on_change)(&old, &self.state);
        }
        resume(())
    }
}

/// State handler that batches updates
pub deep handler BatchedState<S: Clone> for State<S> {
    let mut state: S;
    let mut pending: Option<S>;

    fn new(initial: S) -> Self {
        BatchedState { state: initial, pending: None }
    }

    fn commit(self: &mut Self) {
        if let Some(s) = self.pending.take() {
            self.state = s;
        }
    }

    fn rollback(self: &mut Self) {
        self.pending = None;
    }

    return(x) {
        self.commit();
        (x, self.state)
    }

    op get() {
        resume(self.pending.clone().unwrap_or_else(|| self.state.clone()))
    }

    op put(s: S) {
        self.pending = Some(s);
        resume(())
    }
}

/// State handler for thread-local state
pub deep handler ThreadLocalState<S: Clone> for State<S> {
    // Uses thread-local storage
    return(x) { x }

    op get() {
        let state = __builtin_thread_local_get::<S>();
        resume(state)
    }

    op put(s: S) {
        __builtin_thread_local_set(s);
        resume(())
    }
}

/// Runs a stateful computation
pub fn run_state<S, T, F>(initial: S, f: F) -> (T, S) / pure
where
    F: FnOnce() -> T / {State<S>},
{
    let handler = StateHandler::new(initial);
    handle f() with handler {
        return(v) { (v, handler.state) }
    }
}

/// Evaluates a stateful computation, discarding final state
pub fn eval_state<S, T, F>(initial: S, f: F) -> T / pure
where
    F: FnOnce() -> T / {State<S>},
{
    run_state(initial, f).0
}

/// Executes a stateful computation, returning only final state
pub fn exec_state<S, T, F>(initial: S, f: F) -> S / pure
where
    F: FnOnce() -> T / {State<S>},
{
    run_state(initial, f).1
}

/// Modifies state using a function
pub fn modify<S, F: FnOnce(S) -> S>(f: F) / {State<S>} {
    let s = perform get();
    perform put(f(s));
}

/// Gets a value derived from state
pub fn gets<S, T, F: FnOnce(&S) -> T>(f: F) -> T / {State<S>} {
    let s = perform get();
    f(&s)
}
