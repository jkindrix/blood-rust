// Blood Standard Library - I/O Errors
//
// Error types for I/O operations.

/// The result type for I/O operations
pub type Result<T> = core::result::Result<T, Error>;

/// An I/O error
pub struct Error {
    repr: Repr,
}

enum Repr {
    Simple(ErrorKind),
    Custom(Box<Custom>),
}

struct Custom {
    kind: ErrorKind,
    error: Box<dyn error::Error + Send + Sync>,
}

/// A list of general categories of I/O error
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ErrorKind {
    /// An entity was not found
    NotFound,
    /// Permission denied
    PermissionDenied,
    /// The connection was refused
    ConnectionRefused,
    /// The connection was reset
    ConnectionReset,
    /// The connection was aborted
    ConnectionAborted,
    /// Not connected
    NotConnected,
    /// Address already in use
    AddrInUse,
    /// Address not available
    AddrNotAvailable,
    /// Broken pipe
    BrokenPipe,
    /// Entity already exists
    AlreadyExists,
    /// Operation would block
    WouldBlock,
    /// Invalid input parameter
    InvalidInput,
    /// Invalid data encountered
    InvalidData,
    /// Timed out
    TimedOut,
    /// Write of zero bytes
    WriteZero,
    /// Interrupted
    Interrupted,
    /// Unexpected end of file
    UnexpectedEof,
    /// Unsupported operation
    Unsupported,
    /// Out of memory
    OutOfMemory,
    /// Other error
    Other,
    /// Uncategorized error
    Uncategorized,
}

impl Error {
    /// Creates a new error from a kind and message
    pub fn new<E>(kind: ErrorKind, error: E) -> Self / pure
    where
        E: Into<Box<dyn error::Error + Send + Sync>>,
    {
        Error {
            repr: Repr::Custom(Box::new(Custom {
                kind,
                error: error.into(),
            })),
        }
    }

    /// Creates a simple error from a kind
    pub const fn from_kind(kind: ErrorKind) -> Self / pure {
        Error {
            repr: Repr::Simple(kind),
        }
    }

    /// Returns the kind of error
    pub fn kind(self: &Self) -> ErrorKind / pure {
        match &self.repr {
            Repr::Simple(kind) => *kind,
            Repr::Custom(c) => c.kind,
        }
    }

    /// Returns the underlying error if any
    pub fn get_ref(self: &Self) -> Option<&(dyn error::Error + Send + Sync + 'static)> / pure {
        match &self.repr {
            Repr::Simple(_) => None,
            Repr::Custom(c) => Some(&*c.error),
        }
    }

    /// Returns a mutable reference to the underlying error if any
    pub fn get_mut(self: &mut Self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> / pure {
        match &mut self.repr {
            Repr::Simple(_) => None,
            Repr::Custom(c) => Some(&mut *c.error),
        }
    }

    /// Consumes and returns the underlying error if any
    pub fn into_inner(self: Self) -> Option<Box<dyn error::Error + Send + Sync>> / pure {
        match self.repr {
            Repr::Simple(_) => None,
            Repr::Custom(c) => Some(c.error),
        }
    }

    /// Returns the OS error code if this was created from a raw OS error
    pub fn raw_os_error(self: &Self) -> Option<i32> / pure {
        // This would be set by from_raw_os_error
        None
    }

    /// Creates an error from a raw OS error code
    pub fn from_raw_os_error(code: i32) -> Self / pure {
        // Map OS error codes to ErrorKind
        let kind = match code {
            2 => ErrorKind::NotFound,         // ENOENT
            13 => ErrorKind::PermissionDenied, // EACCES
            17 => ErrorKind::AlreadyExists,    // EEXIST
            32 => ErrorKind::BrokenPipe,       // EPIPE
            _ => ErrorKind::Other,
        };
        Error::from_kind(kind)
    }

    /// Returns the last OS error
    pub fn last_os_error() -> Self / pure {
        Error::from_raw_os_error(__builtin_errno())
    }
}

impl Debug for Error {
    fn fmt(self: &Self, f: &mut Formatter) -> fmt::Result / {IO} {
        let kind = self.kind();
        match &self.repr {
            Repr::Simple(_) => {
                f.debug_struct("Error")
                    .field("kind", &kind)
                    .finish()
            }
            Repr::Custom(c) => {
                f.debug_struct("Error")
                    .field("kind", &kind)
                    .field("message", &c.error)
                    .finish()
            }
        }
    }
}

impl Display for Error {
    fn fmt(self: &Self, f: &mut Formatter) -> fmt::Result / {IO} {
        match &self.repr {
            Repr::Simple(kind) => write!(f, "{}", kind.as_str()),
            Repr::Custom(c) => Display::fmt(&c.error, f),
        }
    }
}

impl error::Error for Error {
    fn source(self: &Self) -> Option<&(dyn error::Error + 'static)> / pure {
        match &self.repr {
            Repr::Simple(_) => None,
            Repr::Custom(c) => c.error.source(),
        }
    }
}

impl From<ErrorKind> for Error {
    fn from(kind: ErrorKind) -> Self / pure {
        Error::from_kind(kind)
    }
}

impl ErrorKind {
    /// Returns a string description of the error kind
    pub fn as_str(self: Self) -> &'static str / pure {
        match self {
            ErrorKind::NotFound => "entity not found",
            ErrorKind::PermissionDenied => "permission denied",
            ErrorKind::ConnectionRefused => "connection refused",
            ErrorKind::ConnectionReset => "connection reset",
            ErrorKind::ConnectionAborted => "connection aborted",
            ErrorKind::NotConnected => "not connected",
            ErrorKind::AddrInUse => "address in use",
            ErrorKind::AddrNotAvailable => "address not available",
            ErrorKind::BrokenPipe => "broken pipe",
            ErrorKind::AlreadyExists => "entity already exists",
            ErrorKind::WouldBlock => "operation would block",
            ErrorKind::InvalidInput => "invalid input parameter",
            ErrorKind::InvalidData => "invalid data",
            ErrorKind::TimedOut => "timed out",
            ErrorKind::WriteZero => "write zero",
            ErrorKind::Interrupted => "operation interrupted",
            ErrorKind::UnexpectedEof => "unexpected end of file",
            ErrorKind::Unsupported => "unsupported",
            ErrorKind::OutOfMemory => "out of memory",
            ErrorKind::Other => "other error",
            ErrorKind::Uncategorized => "uncategorized error",
        }
    }
}

impl Display for ErrorKind {
    fn fmt(self: &Self, f: &mut Formatter) -> fmt::Result / {IO} {
        f.write_str(self.as_str())
    }
}
