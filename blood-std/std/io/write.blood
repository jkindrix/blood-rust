// Blood Standard Library - Write Trait
//
// Trait for writing bytes to a destination.

use super::{Result, Error, ErrorKind};
use crate::fmt;

/// Trait for writing bytes to a destination
pub trait Write {
    /// Writes bytes from the buffer
    ///
    /// Returns the number of bytes written.
    fn write(self: &mut Self, buf: &[u8]) -> Result<usize> / {IO};

    /// Flushes any buffered data
    fn flush(self: &mut Self) -> Result<()> / {IO};

    /// Writes all bytes from the buffer
    fn write_all(self: &mut Self, buf: &[u8]) -> Result<()> / {IO} {
        let mut total = 0;
        while total < buf.len() {
            match self.write(&buf[total..]) {
                Ok(0) => {
                    return Err(Error::new(
                        ErrorKind::WriteZero,
                        "failed to write whole buffer",
                    ));
                }
                Ok(n) => total += n,
                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,
                Err(e) => return Err(e),
            }
        }
        Ok(())
    }

    /// Writes formatted arguments
    fn write_fmt(self: &mut Self, args: fmt::Arguments<'_>) -> Result<()> / {IO} {
        // Create a shim that implements fmt::Write
        struct Adaptor<'a, W: Write + ?Sized> {
            inner: &'a mut W,
            error: Option<Error>,
        }

        impl<'a, W: Write + ?Sized> fmt::Write for Adaptor<'a, W> {
            fn write_str(self: &mut Self, s: &str) -> fmt::Result / {IO} {
                match self.inner.write_all(s.as_bytes()) {
                    Ok(()) => Ok(()),
                    Err(e) => {
                        self.error = Some(e);
                        Err(fmt::Error)
                    }
                }
            }
        }

        let mut adaptor = Adaptor {
            inner: self,
            error: None,
        };

        match fmt::write(&mut adaptor, args) {
            Ok(()) => Ok(()),
            Err(_) => {
                if let Some(e) = adaptor.error {
                    Err(e)
                } else {
                    Err(Error::new(ErrorKind::Other, "formatter error"))
                }
            }
        }
    }

    /// Creates a writer by reference
    fn by_ref(self: &mut Self) -> &mut Self / pure {
        self
    }
}

// Implement Write for references
impl<W: Write + ?Sized> Write for &mut W {
    fn write(self: &mut Self, buf: &[u8]) -> Result<usize> / {IO} {
        (*self).write(buf)
    }

    fn flush(self: &mut Self) -> Result<()> / {IO} {
        (*self).flush()
    }

    fn write_all(self: &mut Self, buf: &[u8]) -> Result<()> / {IO} {
        (*self).write_all(buf)
    }

    fn write_fmt(self: &mut Self, args: fmt::Arguments<'_>) -> Result<()> / {IO} {
        (*self).write_fmt(args)
    }
}

// Implement Write for Vec<u8>
impl Write for Vec<u8> {
    fn write(self: &mut Self, buf: &[u8]) -> Result<usize> / {IO} {
        self.extend_from_slice(buf);
        Ok(buf.len())
    }

    fn flush(self: &mut Self) -> Result<()> / {IO} {
        Ok(())
    }

    fn write_all(self: &mut Self, buf: &[u8]) -> Result<()> / {IO} {
        self.extend_from_slice(buf);
        Ok(())
    }
}

/// Writes formatted data to a writer
#[macro]
pub macro write {
    ($dst:expr, $($arg:tt)*) => {
        $dst.write_fmt(format_args!($($arg)*))
    };
}

/// Writes formatted data with a newline to a writer
#[macro]
pub macro writeln {
    ($dst:expr) => { write!($dst, "\n") };
    ($dst:expr, $($arg:tt)*) => {
        $dst.write_fmt(format_args!("{}\n", format_args!($($arg)*)))
    };
}
