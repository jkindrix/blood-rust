// Blood Standard Library - Iterator Traits and Adapters
//
// Core iterator infrastructure for lazy sequence processing.

/// The core iterator trait
///
/// Iterator provides lazy sequence processing with composable adapters.
pub trait Iterator {
    /// The type of elements produced
    type Item;

    /// Advances the iterator and returns the next value
    fn next(self: &mut Self) -> Option<Self::Item> / pure;

    /// Returns the bounds on remaining length
    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (0, None)
    }

    /// Counts the number of elements
    fn count(self: Self) -> usize / pure
    where
        Self: Sized,
    {
        self.fold(0, |count, _| count + 1)
    }

    /// Returns the last element
    fn last(self: Self) -> Option<Self::Item> / pure
    where
        Self: Sized,
    {
        self.fold(None, |_, x| Some(x))
    }

    /// Returns the nth element
    fn nth(self: &mut Self, n: usize) -> Option<Self::Item> / pure {
        for _ in 0..n {
            self.next()?;
        }
        self.next()
    }

    /// Creates an iterator that skips the first n elements
    fn skip(self: Self, n: usize) -> Skip<Self> / pure
    where
        Self: Sized,
    {
        Skip { iter: self, n }
    }

    /// Creates an iterator that yields only the first n elements
    fn take(self: Self, n: usize) -> Take<Self> / pure
    where
        Self: Sized,
    {
        Take { iter: self, n }
    }

    /// Creates an iterator that yields elements while predicate is true
    fn take_while<P: FnMut(&Self::Item) -> bool>(self: Self, predicate: P) -> TakeWhile<Self, P> / pure
    where
        Self: Sized,
    {
        TakeWhile { iter: self, predicate, done: false }
    }

    /// Creates an iterator that skips elements while predicate is true
    fn skip_while<P: FnMut(&Self::Item) -> bool>(self: Self, predicate: P) -> SkipWhile<Self, P> / pure
    where
        Self: Sized,
    {
        SkipWhile { iter: self, predicate, done: false }
    }

    /// Creates an iterator that yields elements by stepping
    fn step_by(self: Self, step: usize) -> StepBy<Self> / pure
    where
        Self: Sized,
    {
        assert!(step > 0, "step must be positive");
        StepBy { iter: self, step, first: true }
    }

    /// Maps elements through a function
    fn map<B, F: FnMut(Self::Item) -> B>(self: Self, f: F) -> Map<Self, F> / pure
    where
        Self: Sized,
    {
        Map { iter: self, f }
    }

    /// Filters elements by a predicate
    fn filter<P: FnMut(&Self::Item) -> bool>(self: Self, predicate: P) -> Filter<Self, P> / pure
    where
        Self: Sized,
    {
        Filter { iter: self, predicate }
    }

    /// Maps and filters in one step
    fn filter_map<B, F: FnMut(Self::Item) -> Option<B>>(self: Self, f: F) -> FilterMap<Self, F> / pure
    where
        Self: Sized,
    {
        FilterMap { iter: self, f }
    }

    /// Flattens an iterator of iterators
    fn flatten(self: Self) -> Flatten<Self> / pure
    where
        Self: Sized,
        Self::Item: IntoIterator,
    {
        Flatten { outer: self, inner: None }
    }

    /// Maps then flattens
    fn flat_map<U, F>(self: Self, f: F) -> FlatMap<Self, U, F> / pure
    where
        Self: Sized,
        U: IntoIterator,
        F: FnMut(Self::Item) -> U,
    {
        FlatMap { outer: self, inner: None, f }
    }

    /// Chains two iterators
    fn chain<U: IntoIterator<Item = Self::Item>>(self: Self, other: U) -> Chain<Self, U::IntoIter> / pure
    where
        Self: Sized,
    {
        Chain { a: Some(self), b: other.into_iter() }
    }

    /// Zips two iterators into pairs
    fn zip<U: IntoIterator>(self: Self, other: U) -> Zip<Self, U::IntoIter> / pure
    where
        Self: Sized,
    {
        Zip { a: self, b: other.into_iter() }
    }

    /// Attaches an index to each element
    fn enumerate(self: Self) -> Enumerate<Self> / pure
    where
        Self: Sized,
    {
        Enumerate { iter: self, count: 0 }
    }

    /// Creates an iterator that peeks at the next element
    fn peekable(self: Self) -> Peekable<Self> / pure
    where
        Self: Sized,
    {
        Peekable { iter: self, peeked: None }
    }

    /// Calls a closure on each element
    fn inspect<F: FnMut(&Self::Item)>(self: Self, f: F) -> Inspect<Self, F> / pure
    where
        Self: Sized,
    {
        Inspect { iter: self, f }
    }

    /// Creates an iterator that clones elements
    fn cloned<'a, T: Clone + 'a>(self: Self) -> Cloned<Self> / pure
    where
        Self: Sized + Iterator<Item = &'a T>,
    {
        Cloned { iter: self }
    }

    /// Creates an iterator that copies elements
    fn copied<'a, T: Copy + 'a>(self: Self) -> Copied<Self> / pure
    where
        Self: Sized + Iterator<Item = &'a T>,
    {
        Copied { iter: self }
    }

    /// Folds elements using an accumulator
    fn fold<B, F: FnMut(B, Self::Item) -> B>(self: Self, init: B, f: F) -> B / pure
    where
        Self: Sized,
    {
        let mut accum = init;
        for item in self {
            accum = f(accum, item);
        }
        accum
    }

    /// Reduces elements using a function
    fn reduce<F: FnMut(Self::Item, Self::Item) -> Self::Item>(self: Self, f: F) -> Option<Self::Item> / pure
    where
        Self: Sized,
    {
        let first = self.next()?;
        Some(self.fold(first, f))
    }

    /// Calls a closure on each element
    fn for_each<F: FnMut(Self::Item)>(self: Self, f: F) / pure
    where
        Self: Sized,
    {
        self.fold((), |(), item| f(item))
    }

    /// Tests if any element matches a predicate
    fn any<F: FnMut(Self::Item) -> bool>(self: &mut Self, f: F) -> bool / pure {
        for item in self {
            if f(item) {
                return true;
            }
        }
        false
    }

    /// Tests if all elements match a predicate
    fn all<F: FnMut(Self::Item) -> bool>(self: &mut Self, f: F) -> bool / pure {
        for item in self {
            if !f(item) {
                return false;
            }
        }
        true
    }

    /// Finds the first element matching a predicate
    fn find<P: FnMut(&Self::Item) -> bool>(self: &mut Self, predicate: P) -> Option<Self::Item> / pure {
        for item in self {
            if predicate(&item) {
                return Some(item);
            }
        }
        None
    }

    /// Finds the first element and maps it
    fn find_map<B, F: FnMut(Self::Item) -> Option<B>>(self: &mut Self, f: F) -> Option<B> / pure {
        for item in self {
            if let Some(result) = f(item) {
                return Some(result);
            }
        }
        None
    }

    /// Returns the position of the first matching element
    fn position<P: FnMut(Self::Item) -> bool>(self: &mut Self, predicate: P) -> Option<usize> / pure {
        let mut i = 0;
        for item in self {
            if predicate(item) {
                return Some(i);
            }
            i += 1;
        }
        None
    }

    /// Returns the maximum element
    fn max(self: Self) -> Option<Self::Item> / pure
    where
        Self: Sized,
        Self::Item: Ord,
    {
        self.reduce(|a, b| if a >= b { a } else { b })
    }

    /// Returns the minimum element
    fn min(self: Self) -> Option<Self::Item> / pure
    where
        Self: Sized,
        Self::Item: Ord,
    {
        self.reduce(|a, b| if a <= b { a } else { b })
    }

    /// Returns the maximum element by a key function
    fn max_by_key<B: Ord, F: FnMut(&Self::Item) -> B>(self: Self, f: F) -> Option<Self::Item> / pure
    where
        Self: Sized,
    {
        self.reduce(|a, b| if f(&a) >= f(&b) { a } else { b })
    }

    /// Returns the minimum element by a key function
    fn min_by_key<B: Ord, F: FnMut(&Self::Item) -> B>(self: Self, f: F) -> Option<Self::Item> / pure
    where
        Self: Sized,
    {
        self.reduce(|a, b| if f(&a) <= f(&b) { a } else { b })
    }

    /// Sums the elements
    fn sum<S: Sum<Self::Item>>(self: Self) -> S / pure
    where
        Self: Sized,
    {
        S::sum(self)
    }

    /// Multiplies the elements
    fn product<P: Product<Self::Item>>(self: Self) -> P / pure
    where
        Self: Sized,
    {
        P::product(self)
    }

    /// Collects elements into a collection
    fn collect<B: FromIterator<Self::Item>>(self: Self) -> B / pure
    where
        Self: Sized,
    {
        B::from_iter(self)
    }

    /// Partitions elements into two collections
    fn partition<B, F>(self: Self, f: F) -> (B, B) / pure
    where
        Self: Sized,
        B: Default + Extend<Self::Item>,
        F: FnMut(&Self::Item) -> bool,
    {
        let mut left = B::default();
        let mut right = B::default();

        for item in self {
            if f(&item) {
                left.extend(once(item));
            } else {
                right.extend(once(item));
            }
        }

        (left, right)
    }

    /// Reverses the iterator
    fn rev(self: Self) -> Rev<Self> / pure
    where
        Self: Sized + DoubleEndedIterator,
    {
        Rev { iter: self }
    }

    /// Creates an iterator that yields references
    fn by_ref(self: &mut Self) -> &mut Self / pure {
        self
    }

    /// Lexicographically compares two iterators
    fn cmp<I: IntoIterator<Item = Self::Item>>(self: Self, other: I) -> Ordering / pure
    where
        Self: Sized,
        Self::Item: Ord,
    {
        let mut other = other.into_iter();

        loop {
            match (self.next(), other.next()) {
                (Some(a), Some(b)) => {
                    match a.cmp(&b) {
                        Ordering::Equal => continue,
                        ord => return ord,
                    }
                }
                (Some(_), None) => return Ordering::Greater,
                (None, Some(_)) => return Ordering::Less,
                (None, None) => return Ordering::Equal,
            }
        }
    }

    /// Tests if two iterators are equal
    fn eq<I: IntoIterator<Item = Self::Item>>(self: Self, other: I) -> bool / pure
    where
        Self: Sized,
        Self::Item: PartialEq,
    {
        let mut other = other.into_iter();

        loop {
            match (self.next(), other.next()) {
                (Some(a), Some(b)) => {
                    if a != b {
                        return false;
                    }
                }
                (None, None) => return true,
                _ => return false,
            }
        }
    }
}

/// Iterator that can be traversed from both ends
pub trait DoubleEndedIterator: Iterator {
    /// Removes and returns an element from the back
    fn next_back(self: &mut Self) -> Option<Self::Item> / pure;

    /// Folds from the back
    fn rfold<B, F: FnMut(B, Self::Item) -> B>(self: Self, init: B, f: F) -> B / pure
    where
        Self: Sized,
    {
        let mut accum = init;
        while let Some(item) = self.next_back() {
            accum = f(accum, item);
        }
        accum
    }

    /// Finds from the back
    fn rfind<P: FnMut(&Self::Item) -> bool>(self: &mut Self, predicate: P) -> Option<Self::Item> / pure {
        while let Some(item) = self.next_back() {
            if predicate(&item) {
                return Some(item);
            }
        }
        None
    }
}

/// Iterator with a known exact size
pub trait ExactSizeIterator: Iterator {
    /// Returns the exact remaining length
    fn len(self: &Self) -> usize / pure {
        let (lower, upper) = self.size_hint();
        debug_assert!(upper == Some(lower));
        lower
    }

    /// Returns true if the iterator is empty
    fn is_empty(self: &Self) -> bool / pure {
        self.len() == 0
    }
}

/// Iterator that supports fused iteration
pub trait FusedIterator: Iterator {}

/// Conversion into an iterator
pub trait IntoIterator {
    /// The type of elements
    type Item;

    /// The iterator type
    type IntoIter: Iterator<Item = Self::Item>;

    /// Creates an iterator from a value
    fn into_iter(self: Self) -> Self::IntoIter / pure;
}

impl<I: Iterator> IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    fn into_iter(self: Self) -> I / pure {
        self
    }
}

/// Trait for types that can be summed
pub trait Sum<A = Self>: Sized {
    fn sum<I: Iterator<Item = A>>(iter: I) -> Self / pure;
}

/// Trait for types that can be multiplied
pub trait Product<A = Self>: Sized {
    fn product<I: Iterator<Item = A>>(iter: I) -> Self / pure;
}

// Sum implementations for numeric types
macro_rules! impl_sum {
    ($($t:ty)*) => {
        $(impl Sum for $t {
            fn sum<I: Iterator<Item = $t>>(iter: I) -> $t / pure {
                iter.fold(0 as $t, |a, b| a + b)
            }
        })*
    };
}

impl_sum! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize f32 f64 }

// Product implementations for numeric types
macro_rules! impl_product {
    ($($t:ty)*) => {
        $(impl Product for $t {
            fn product<I: Iterator<Item = $t>>(iter: I) -> $t / pure {
                iter.fold(1 as $t, |a, b| a * b)
            }
        })*
    };
}

impl_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize f32 f64 }

// =============================================================================
// Iterator Adapters
// =============================================================================

/// Iterator that maps elements
pub struct Map<I, F> {
    iter: I,
    f: F,
}

impl<B, I: Iterator, F: FnMut(I::Item) -> B> Iterator for Map<I, F> {
    type Item = B;

    fn next(self: &mut Self) -> Option<B> / pure {
        self.iter.next().map(&mut self.f)
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        self.iter.size_hint()
    }
}

impl<B, I: DoubleEndedIterator, F: FnMut(I::Item) -> B> DoubleEndedIterator for Map<I, F> {
    fn next_back(self: &mut Self) -> Option<B> / pure {
        self.iter.next_back().map(&mut self.f)
    }
}

impl<B, I: ExactSizeIterator, F: FnMut(I::Item) -> B> ExactSizeIterator for Map<I, F> {}

/// Iterator that filters elements
pub struct Filter<I, P> {
    iter: I,
    predicate: P,
}

impl<I: Iterator, P: FnMut(&I::Item) -> bool> Iterator for Filter<I, P> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        loop {
            let item = self.iter.next()?;
            if (self.predicate)(&item) {
                return Some(item);
            }
        }
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (0, self.iter.size_hint().1)
    }
}

impl<I: DoubleEndedIterator, P: FnMut(&I::Item) -> bool> DoubleEndedIterator for Filter<I, P> {
    fn next_back(self: &mut Self) -> Option<I::Item> / pure {
        loop {
            let item = self.iter.next_back()?;
            if (self.predicate)(&item) {
                return Some(item);
            }
        }
    }
}

/// Iterator that maps and filters
pub struct FilterMap<I, F> {
    iter: I,
    f: F,
}

impl<B, I: Iterator, F: FnMut(I::Item) -> Option<B>> Iterator for FilterMap<I, F> {
    type Item = B;

    fn next(self: &mut Self) -> Option<B> / pure {
        loop {
            let item = self.iter.next()?;
            if let Some(result) = (self.f)(item) {
                return Some(result);
            }
        }
    }
}

/// Iterator that takes elements while predicate is true
pub struct TakeWhile<I, P> {
    iter: I,
    predicate: P,
    done: bool,
}

impl<I: Iterator, P: FnMut(&I::Item) -> bool> Iterator for TakeWhile<I, P> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        if self.done {
            return None;
        }
        let item = self.iter.next()?;
        if (self.predicate)(&item) {
            Some(item)
        } else {
            self.done = true;
            None
        }
    }
}

/// Iterator that skips elements while predicate is true
pub struct SkipWhile<I, P> {
    iter: I,
    predicate: P,
    done: bool,
}

impl<I: Iterator, P: FnMut(&I::Item) -> bool> Iterator for SkipWhile<I, P> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        if self.done {
            return self.iter.next();
        }
        loop {
            let item = self.iter.next()?;
            if !(self.predicate)(&item) {
                self.done = true;
                return Some(item);
            }
        }
    }
}

/// Iterator that takes first n elements
pub struct Take<I> {
    iter: I,
    n: usize,
}

impl<I: Iterator> Iterator for Take<I> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        if self.n == 0 {
            None
        } else {
            self.n -= 1;
            self.iter.next()
        }
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let (lower, upper) = self.iter.size_hint();
        (lower.min(self.n), upper.map(|u| u.min(self.n)))
    }
}

impl<I: ExactSizeIterator> ExactSizeIterator for Take<I> {}

/// Iterator that skips first n elements
pub struct Skip<I> {
    iter: I,
    n: usize,
}

impl<I: Iterator> Iterator for Skip<I> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        while self.n > 0 {
            self.n -= 1;
            self.iter.next()?;
        }
        self.iter.next()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let (lower, upper) = self.iter.size_hint();
        (lower.saturating_sub(self.n), upper.map(|u| u.saturating_sub(self.n)))
    }
}

/// Iterator that steps by n
pub struct StepBy<I> {
    iter: I,
    step: usize,
    first: bool,
}

impl<I: Iterator> Iterator for StepBy<I> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        if self.first {
            self.first = false;
            return self.iter.next();
        }
        self.iter.nth(self.step - 1)
    }
}

/// Iterator that chains two iterators
pub struct Chain<A, B> {
    a: Option<A>,
    b: B,
}

impl<T, A: Iterator<Item = T>, B: Iterator<Item = T>> Iterator for Chain<A, B> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        if let Some(ref mut a) = self.a {
            if let Some(item) = a.next() {
                return Some(item);
            }
            self.a = None;
        }
        self.b.next()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let (a_lower, a_upper) = self.a.as_ref().map_or((0, Some(0)), |a| a.size_hint());
        let (b_lower, b_upper) = self.b.size_hint();
        let lower = a_lower.saturating_add(b_lower);
        let upper = match (a_upper, b_upper) {
            (Some(a), Some(b)) => a.checked_add(b),
            _ => None,
        };
        (lower, upper)
    }
}

/// Iterator that zips two iterators
pub struct Zip<A, B> {
    a: A,
    b: B,
}

impl<A: Iterator, B: Iterator> Iterator for Zip<A, B> {
    type Item = (A::Item, B::Item);

    fn next(self: &mut Self) -> Option<(A::Item, B::Item)> / pure {
        Some((self.a.next()?, self.b.next()?))
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let (a_lower, a_upper) = self.a.size_hint();
        let (b_lower, b_upper) = self.b.size_hint();
        let lower = a_lower.min(b_lower);
        let upper = match (a_upper, b_upper) {
            (Some(a), Some(b)) => Some(a.min(b)),
            (Some(a), None) => Some(a),
            (None, Some(b)) => Some(b),
            (None, None) => None,
        };
        (lower, upper)
    }
}

/// Iterator that enumerates elements
pub struct Enumerate<I> {
    iter: I,
    count: usize,
}

impl<I: Iterator> Iterator for Enumerate<I> {
    type Item = (usize, I::Item);

    fn next(self: &mut Self) -> Option<(usize, I::Item)> / pure {
        let item = self.iter.next()?;
        let idx = self.count;
        self.count += 1;
        Some((idx, item))
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        self.iter.size_hint()
    }
}

impl<I: ExactSizeIterator> ExactSizeIterator for Enumerate<I> {}

/// Iterator that can peek at the next element
pub struct Peekable<I: Iterator> {
    iter: I,
    peeked: Option<Option<I::Item>>,
}

impl<I: Iterator> Peekable<I> {
    /// Peeks at the next element without consuming it
    pub fn peek(self: &mut Self) -> Option<&I::Item> / pure {
        if self.peeked.is_none() {
            self.peeked = Some(self.iter.next());
        }
        self.peeked.as_ref().and_then(|opt| opt.as_ref())
    }

    /// Peeks at the next element with mutable access
    pub fn peek_mut(self: &mut Self) -> Option<&mut I::Item> / pure {
        if self.peeked.is_none() {
            self.peeked = Some(self.iter.next());
        }
        self.peeked.as_mut().and_then(|opt| opt.as_mut())
    }

    /// Consumes the next element if it matches the predicate
    pub fn next_if<F: FnOnce(&I::Item) -> bool>(self: &mut Self, func: F) -> Option<I::Item> / pure {
        match self.peek() {
            Some(item) if func(item) => self.next(),
            _ => None,
        }
    }
}

impl<I: Iterator> Iterator for Peekable<I> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        match self.peeked.take() {
            Some(peeked) => peeked,
            None => self.iter.next(),
        }
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let (lower, upper) = self.iter.size_hint();
        let peek_len = if self.peeked.is_some() { 1 } else { 0 };
        (lower + peek_len, upper.map(|u| u + peek_len))
    }
}

/// Iterator that calls a closure on each element
pub struct Inspect<I, F> {
    iter: I,
    f: F,
}

impl<I: Iterator, F: FnMut(&I::Item)> Iterator for Inspect<I, F> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        let item = self.iter.next()?;
        (self.f)(&item);
        Some(item)
    }
}

/// Iterator that flattens nested iterators
pub struct Flatten<I: Iterator>
where
    I::Item: IntoIterator,
{
    outer: I,
    inner: Option<<I::Item as IntoIterator>::IntoIter>,
}

impl<I: Iterator> Iterator for Flatten<I>
where
    I::Item: IntoIterator,
{
    type Item = <I::Item as IntoIterator>::Item;

    fn next(self: &mut Self) -> Option<Self::Item> / pure {
        loop {
            if let Some(ref mut inner) = self.inner {
                if let Some(item) = inner.next() {
                    return Some(item);
                }
            }
            self.inner = Some(self.outer.next()?.into_iter());
        }
    }
}

/// Iterator that maps then flattens
pub struct FlatMap<I, U: IntoIterator, F> {
    outer: I,
    inner: Option<U::IntoIter>,
    f: F,
}

impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> Iterator for FlatMap<I, U, F> {
    type Item = U::Item;

    fn next(self: &mut Self) -> Option<Self::Item> / pure {
        loop {
            if let Some(ref mut inner) = self.inner {
                if let Some(item) = inner.next() {
                    return Some(item);
                }
            }
            self.inner = Some((self.f)(self.outer.next()?).into_iter());
        }
    }
}

/// Iterator that clones elements
pub struct Cloned<I> {
    iter: I,
}

impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> Iterator for Cloned<I> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.iter.next().cloned()
    }
}

/// Iterator that copies elements
pub struct Copied<I> {
    iter: I,
}

impl<'a, T: Copy + 'a, I: Iterator<Item = &'a T>> Iterator for Copied<I> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.iter.next().copied()
    }
}

/// Reversed iterator
pub struct Rev<I> {
    iter: I,
}

impl<I: DoubleEndedIterator> Iterator for Rev<I> {
    type Item = I::Item;

    fn next(self: &mut Self) -> Option<I::Item> / pure {
        self.iter.next_back()
    }
}

impl<I: DoubleEndedIterator> DoubleEndedIterator for Rev<I> {
    fn next_back(self: &mut Self) -> Option<I::Item> / pure {
        self.iter.next()
    }
}

// =============================================================================
// Iterator Constructors
// =============================================================================

/// Creates an iterator that yields nothing
pub fn empty<T>() -> Empty<T> / pure {
    Empty { _marker: PhantomData }
}

/// Iterator that yields nothing
pub struct Empty<T> {
    _marker: PhantomData<T>,
}

impl<T> Iterator for Empty<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        None
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (0, Some(0))
    }
}

impl<T> DoubleEndedIterator for Empty<T> {
    fn next_back(self: &mut Self) -> Option<T> / pure {
        None
    }
}

impl<T> ExactSizeIterator for Empty<T> {}

impl<T> FusedIterator for Empty<T> {}

/// Creates an iterator that yields a single element
pub fn once<T>(value: T) -> Once<T> / pure {
    Once { value: Some(value) }
}

/// Iterator that yields exactly one element
pub struct Once<T> {
    value: Option<T>,
}

impl<T> Iterator for Once<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        self.value.take()
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        let len = if self.value.is_some() { 1 } else { 0 };
        (len, Some(len))
    }
}

impl<T> DoubleEndedIterator for Once<T> {
    fn next_back(self: &mut Self) -> Option<T> / pure {
        self.value.take()
    }
}

impl<T> ExactSizeIterator for Once<T> {}

impl<T> FusedIterator for Once<T> {}

/// Creates an iterator that repeats an element indefinitely
pub fn repeat<T: Clone>(value: T) -> Repeat<T> / pure {
    Repeat { value }
}

/// Iterator that repeats an element
pub struct Repeat<T> {
    value: T,
}

impl<T: Clone> Iterator for Repeat<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        Some(self.value.clone())
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (usize::MAX, None)
    }
}

/// Creates an iterator that repeats an element n times
pub fn repeat_n<T: Clone>(value: T, n: usize) -> RepeatN<T> / pure {
    RepeatN { value, count: n }
}

/// Iterator that repeats an element n times
pub struct RepeatN<T> {
    value: T,
    count: usize,
}

impl<T: Clone> Iterator for RepeatN<T> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        if self.count == 0 {
            None
        } else {
            self.count -= 1;
            Some(self.value.clone())
        }
    }

    fn size_hint(self: &Self) -> (usize, Option<usize>) / pure {
        (self.count, Some(self.count))
    }
}

impl<T: Clone> ExactSizeIterator for RepeatN<T> {}

/// Creates an iterator from a closure
pub fn from_fn<T, F: FnMut() -> Option<T>>(f: F) -> FromFn<F> / pure {
    FromFn { f }
}

/// Iterator from a closure
pub struct FromFn<F> {
    f: F,
}

impl<T, F: FnMut() -> Option<T>> Iterator for FromFn<F> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        (self.f)()
    }
}

/// Creates an iterator by successively applying a function
pub fn successors<T, F: FnMut(&T) -> Option<T>>(first: Option<T>, f: F) -> Successors<T, F> / pure {
    Successors { current: first, f }
}

/// Iterator that generates successors
pub struct Successors<T, F> {
    current: Option<T>,
    f: F,
}

impl<T, F: FnMut(&T) -> Option<T>> Iterator for Successors<T, F> {
    type Item = T;

    fn next(self: &mut Self) -> Option<T> / pure {
        let current = self.current.take()?;
        self.current = (self.f)(&current);
        Some(current)
    }
}
