// Blood Standard Library
//
// The standard library provides the foundational types, traits, effects,
// and handlers for Blood programs.
//
// # Prelude
//
// The prelude module is automatically imported into every Blood program.
// It contains the most commonly used items from the standard library.
//
// # Effect System
//
// Blood is built around algebraic effects. The standard effects are:
//
// - `Error<E>`: Recoverable error handling with typed errors
// - `State<S>`: Mutable state threading
// - `IO`: Input/output operations (console, files, network)
// - `Async`: Asynchronous computation and concurrency
// - `Yield<T>`: Generator/coroutine/iterator effects
// - `Panic`: Unrecoverable errors
// - `StaleReference`: Runtime detection of use-after-free
// - `NonDet`: Non-deterministic choice
// - `Resource`: Resource acquisition and release
// - `Random`: Random number generation
//
// # Memory Model
//
// Blood uses 128-bit generational pointers (BloodPtr<T>) that provide:
// - 64-bit address space
// - 32-bit generation counter for use-after-free detection
// - 32-bit metadata for type info and flags
//
// Combined with compile-time linearity checking, this provides memory
// safety without garbage collection.
//
// # Module Overview
//
// - `prelude`: Automatically imported items
// - `core`: Fundamental types (Option, Result, Box, String, Frozen)
// - `primitive`: Primitive type methods (integers, floats, bool, char)
// - `collections`: Data structures (Vec, HashMap, BTreeMap, etc.)
// - `traits`: Core trait definitions (Clone, Eq, Ord, Hash, etc.)
// - `effects`: Effect definitions
// - `handlers`: Standard effect handlers
// - `io`: I/O traits and types
// - `mem`: Memory operations
// - `sync`: Synchronization primitives (Arc, Mutex, atomics)
// - `iter`: Iterator infrastructure
// - `ops`: Operator traits
// - `fs`: File system operations
// - `net`: Networking primitives (TCP, UDP, DNS)

#![no_std]

// Module declarations
pub mod prelude;
pub mod core;
pub mod primitive;
pub mod collections;
pub mod traits;
pub mod effects;
pub mod handlers;
pub mod io;
pub mod mem;
pub mod sync;
pub mod iter;
pub mod ops;
pub mod fs;
pub mod net;

// Re-export prelude at the crate root for convenience
pub use prelude::*;

// =============================================================================
// Standard Library Version
// =============================================================================

/// The version of the Blood standard library
pub const VERSION: &str = "0.1.0";

/// The minimum Blood language version required
pub const MIN_LANG_VERSION: &str = "0.1.0";

// =============================================================================
// Standard Macros
// =============================================================================

/// Standard macros available in the prelude
pub mod macros {
    /// Asserts that a boolean expression is true
    pub macro assert {
        ($cond:expr) => {
            if !$cond {
                perform panic(concat!("assertion failed: ", stringify!($cond)))
            }
        };
        ($cond:expr, $($arg:tt)+) => {
            if !$cond {
                perform panic(format!($($arg)+))
            }
        };
    }

    /// Asserts that two expressions are equal
    pub macro assert_eq {
        ($left:expr, $right:expr) => {
            match (&$left, &$right) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        perform panic(format!(
                            "assertion failed: `(left == right)`\n  left: `{:?}`\n right: `{:?}`",
                            left_val, right_val
                        ))
                    }
                }
            }
        };
        ($left:expr, $right:expr, $($arg:tt)+) => {
            match (&$left, &$right) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        perform panic(format!($($arg)+))
                    }
                }
            }
        };
    }

    /// Asserts that two expressions are not equal
    pub macro assert_ne {
        ($left:expr, $right:expr) => {
            match (&$left, &$right) {
                (left_val, right_val) => {
                    if *left_val == *right_val {
                        perform panic(format!(
                            "assertion failed: `(left != right)`\n  left: `{:?}`\n right: `{:?}`",
                            left_val, right_val
                        ))
                    }
                }
            }
        };
        ($left:expr, $right:expr, $($arg:tt)+) => {
            match (&$left, &$right) {
                (left_val, right_val) => {
                    if *left_val == *right_val {
                        perform panic(format!($($arg)+))
                    }
                }
            }
        };
    }

    /// Debug-only assertion (removed in release builds)
    pub macro debug_assert {
        ($($arg:tt)*) => {
            #[cfg(debug_assertions)]
            assert!($($arg)*)
        };
    }

    /// Debug-only equality assertion
    pub macro debug_assert_eq {
        ($($arg:tt)*) => {
            #[cfg(debug_assertions)]
            assert_eq!($($arg)*)
        };
    }

    /// Debug-only inequality assertion
    pub macro debug_assert_ne {
        ($($arg:tt)*) => {
            #[cfg(debug_assertions)]
            assert_ne!($($arg)*)
        };
    }

    /// Indicates unfinished code
    pub macro todo {
        () => {
            perform panic("not yet implemented")
        };
        ($($arg:tt)+) => {
            perform panic(format!("not yet implemented: {}", format!($($arg)+)))
        };
    }

    /// Indicates deliberately unimplemented code
    pub macro unimplemented {
        () => {
            perform panic("not implemented")
        };
        ($($arg:tt)+) => {
            perform panic(format!("not implemented: {}", format!($($arg)+)))
        };
    }

    /// Indicates unreachable code
    pub macro unreachable {
        () => {
            perform panic("internal error: entered unreachable code")
        };
        ($($arg:tt)+) => {
            perform panic(format!("internal error: entered unreachable code: {}", format!($($arg)+)))
        };
    }

    /// Panics with a message
    pub macro panic {
        () => {
            perform panic("explicit panic")
        };
        ($msg:expr) => {
            perform panic($msg)
        };
        ($fmt:expr, $($arg:tt)+) => {
            perform panic(format!($fmt, $($arg)+))
        };
    }

    /// Creates a formatted string
    pub macro format {
        ($($arg:tt)*) => {
            __builtin_format!($($arg)*)
        };
    }

    /// Prints to standard output
    pub macro print {
        ($($arg:tt)*) => {
            perform io::print(format!($($arg)*))
        };
    }

    /// Prints to standard output with a newline
    pub macro println {
        () => {
            perform io::println("")
        };
        ($($arg:tt)*) => {
            perform io::println(format!($($arg)*))
        };
    }

    /// Prints to standard error
    pub macro eprint {
        ($($arg:tt)*) => {
            perform io::eprint(format!($($arg)*))
        };
    }

    /// Prints to standard error with a newline
    pub macro eprintln {
        () => {
            perform io::eprintln("")
        };
        ($($arg:tt)*) => {
            perform io::eprintln(format!($($arg)*))
        };
    }

    /// Debug formatting macro
    pub macro dbg {
        () => {
            eprintln!("[{}:{}]", file!(), line!())
        };
        ($val:expr $(,)?) => {
            match $val {
                tmp => {
                    eprintln!("[{}:{}] {} = {:?}", file!(), line!(), stringify!($val), &tmp);
                    tmp
                }
            }
        };
        ($($val:expr),+ $(,)?) => {
            ($(dbg!($val)),+,)
        };
    }

    /// Creates a Vec from a list of elements
    pub macro vec {
        () => {
            Vec::new()
        };
        ($elem:expr; $n:expr) => {
            Vec::from_elem($elem, $n)
        };
        ($($x:expr),+ $(,)?) => {
            {
                let mut v = Vec::new();
                $(v.push($x);)+
                v
            }
        };
    }

    /// Creates a HashMap from key-value pairs
    pub macro hashmap {
        () => {
            HashMap::new()
        };
        ($($key:expr => $value:expr),+ $(,)?) => {
            {
                let mut m = HashMap::new();
                $(m.insert($key, $value);)+
                m
            }
        };
    }

    /// Creates a HashSet from elements
    pub macro hashset {
        () => {
            HashSet::new()
        };
        ($($x:expr),+ $(,)?) => {
            {
                let mut s = HashSet::new();
                $(s.insert($x);)+
                s
            }
        };
    }

    /// Pattern matching with fallthrough
    pub macro matches {
        ($expression:expr, $pattern:pat $(if $guard:expr)? $(,)?) => {
            match $expression {
                $pattern $(if $guard)? => true,
                _ => false,
            }
        };
    }

    /// Writes formatted data to a buffer
    pub macro write {
        ($dst:expr, $($arg:tt)*) => {
            $dst.write_fmt(format_args!($($arg)*))
        };
    }

    /// Writes formatted data to a buffer with a newline
    pub macro writeln {
        ($dst:expr $(,)?) => {
            write!($dst, "\n")
        };
        ($dst:expr, $($arg:tt)*) => {
            {
                write!($dst, $($arg)*)?;
                write!($dst, "\n")
            }
        };
    }

    /// Includes a file as a string at compile time
    pub macro include_str {
        ($file:expr) => {
            __builtin_include_str!($file)
        };
    }

    /// Includes a file as bytes at compile time
    pub macro include_bytes {
        ($file:expr) => {
            __builtin_include_bytes!($file)
        };
    }

    /// Stringifies a token stream
    pub macro stringify {
        ($($t:tt)*) => {
            __builtin_stringify!($($t)*)
        };
    }

    /// Concatenates string literals
    pub macro concat {
        ($($e:expr),* $(,)?) => {
            __builtin_concat!($($e),*)
        };
    }

    /// Gets the current file name
    pub macro file {
        () => {
            __builtin_file!()
        };
    }

    /// Gets the current line number
    pub macro line {
        () => {
            __builtin_line!()
        };
    }

    /// Gets the current column number
    pub macro column {
        () => {
            __builtin_column!()
        };
    }

    /// Gets the current module path
    pub macro module_path {
        () => {
            __builtin_module_path!()
        };
    }

    /// Conditionally compiles code
    pub macro cfg {
        ($($cfg:tt)*) => {
            __builtin_cfg!($($cfg)*)
        };
    }

    /// Compile-time environment variable
    pub macro env {
        ($name:expr) => {
            __builtin_env!($name)
        };
        ($name:expr, $default:expr) => {
            __builtin_env!($name, $default)
        };
    }

    /// Optional compile-time environment variable
    pub macro option_env {
        ($name:expr) => {
            __builtin_option_env!($name)
        };
    }
}
