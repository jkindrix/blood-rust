// Blood Standard Library - Primitive Types
//
// Methods on primitive types.

pub mod bool_;
pub mod char_;
pub mod int;
pub mod float;
pub mod slice;
pub mod str_;
pub mod ptr;
pub mod tuple;
pub mod array;
pub mod unit;
pub mod never;

pub use ptr::NonNull;

// Re-export primitive extension traits
pub use bool_::BoolExt;
pub use char_::CharExt;
pub use int::{IntExt, UintExt};
pub use float::FloatExt;
pub use slice::SliceExt;
pub use str_::StrExt;

/// Integer constants and methods for i8
impl i8 {
    pub const MIN: i8 = -128;
    pub const MAX: i8 = 127;
    pub const BITS: u32 = 8;
}

/// Integer constants and methods for i16
impl i16 {
    pub const MIN: i16 = -32768;
    pub const MAX: i16 = 32767;
    pub const BITS: u32 = 16;
}

/// Integer constants and methods for i32
impl i32 {
    pub const MIN: i32 = -2147483648;
    pub const MAX: i32 = 2147483647;
    pub const BITS: u32 = 32;
}

/// Integer constants and methods for i64
impl i64 {
    pub const MIN: i64 = -9223372036854775808;
    pub const MAX: i64 = 9223372036854775807;
    pub const BITS: u32 = 64;
}

/// Integer constants and methods for i128
impl i128 {
    pub const MIN: i128 = -170141183460469231731687303715884105728;
    pub const MAX: i128 = 170141183460469231731687303715884105727;
    pub const BITS: u32 = 128;
}

/// Integer constants and methods for isize
impl isize {
    pub const MIN: isize = -9223372036854775808;
    pub const MAX: isize = 9223372036854775807;
    pub const BITS: u32 = 64;  // Assuming 64-bit
}

/// Integer constants and methods for u8
impl u8 {
    pub const MIN: u8 = 0;
    pub const MAX: u8 = 255;
    pub const BITS: u32 = 8;

    /// Returns true if this byte is an ASCII letter
    pub fn is_ascii_alphabetic(self: Self) -> bool / pure {
        matches!(self, b'A'..=b'Z' | b'a'..=b'z')
    }

    /// Returns true if this byte is an ASCII digit
    pub fn is_ascii_digit(self: Self) -> bool / pure {
        matches!(self, b'0'..=b'9')
    }

    /// Returns true if this byte is an ASCII alphanumeric character
    pub fn is_ascii_alphanumeric(self: Self) -> bool / pure {
        self.is_ascii_alphabetic() || self.is_ascii_digit()
    }

    /// Returns true if this byte is ASCII whitespace
    pub fn is_ascii_whitespace(self: Self) -> bool / pure {
        matches!(self, b' ' | b'\t' | b'\n' | b'\r' | 0x0c)
    }

    /// Converts to uppercase ASCII
    pub fn to_ascii_uppercase(self: Self) -> u8 / pure {
        if self.is_ascii_lowercase() { self - 32 } else { self }
    }

    /// Converts to lowercase ASCII
    pub fn to_ascii_lowercase(self: Self) -> u8 / pure {
        if self.is_ascii_uppercase() { self + 32 } else { self }
    }

    /// Returns true if this byte is an ASCII uppercase letter
    pub fn is_ascii_uppercase(self: Self) -> bool / pure {
        matches!(self, b'A'..=b'Z')
    }

    /// Returns true if this byte is an ASCII lowercase letter
    pub fn is_ascii_lowercase(self: Self) -> bool / pure {
        matches!(self, b'a'..=b'z')
    }
}

/// Integer constants and methods for u16
impl u16 {
    pub const MIN: u16 = 0;
    pub const MAX: u16 = 65535;
    pub const BITS: u32 = 16;
}

/// Integer constants and methods for u32
impl u32 {
    pub const MIN: u32 = 0;
    pub const MAX: u32 = 4294967295;
    pub const BITS: u32 = 32;
}

/// Integer constants and methods for u64
impl u64 {
    pub const MIN: u64 = 0;
    pub const MAX: u64 = 18446744073709551615;
    pub const BITS: u32 = 64;
}

/// Integer constants and methods for u128
impl u128 {
    pub const MIN: u128 = 0;
    pub const MAX: u128 = 340282366920938463463374607431768211455;
    pub const BITS: u32 = 128;
}

/// Integer constants and methods for usize
impl usize {
    pub const MIN: usize = 0;
    pub const MAX: usize = 18446744073709551615;
    pub const BITS: u32 = 64;  // Assuming 64-bit
}

/// Float constants and methods for f32
impl f32 {
    pub const RADIX: u32 = 2;
    pub const MANTISSA_DIGITS: u32 = 24;
    pub const DIGITS: u32 = 6;
    pub const EPSILON: f32 = 1.1920929e-7;
    pub const MIN: f32 = -3.4028235e+38;
    pub const MIN_POSITIVE: f32 = 1.1754944e-38;
    pub const MAX: f32 = 3.4028235e+38;
    pub const MIN_EXP: i32 = -125;
    pub const MAX_EXP: i32 = 128;
    pub const MIN_10_EXP: i32 = -37;
    pub const MAX_10_EXP: i32 = 38;
    pub const NAN: f32 = 0.0 / 0.0;
    pub const INFINITY: f32 = 1.0 / 0.0;
    pub const NEG_INFINITY: f32 = -1.0 / 0.0;

    pub const fn is_nan(self: Self) -> bool / pure { self != self }
    pub const fn is_infinite(self: Self) -> bool / pure { self == Self::INFINITY || self == Self::NEG_INFINITY }
    pub const fn is_finite(self: Self) -> bool / pure { !self.is_nan() && !self.is_infinite() }
    pub fn is_sign_positive(self: Self) -> bool / pure { self.to_bits() & 0x80000000 == 0 }
    pub fn is_sign_negative(self: Self) -> bool / pure { self.to_bits() & 0x80000000 != 0 }

    pub fn to_bits(self: Self) -> u32 / pure { unsafe { mem::transmute(self) } }
    pub fn from_bits(bits: u32) -> Self / pure { unsafe { mem::transmute(bits) } }

    pub fn abs(self: Self) -> Self / pure { __builtin_fabsf(self) }
    pub fn floor(self: Self) -> Self / pure { __builtin_floorf(self) }
    pub fn ceil(self: Self) -> Self / pure { __builtin_ceilf(self) }
    pub fn round(self: Self) -> Self / pure { __builtin_roundf(self) }
    pub fn trunc(self: Self) -> Self / pure { __builtin_truncf(self) }
    pub fn sqrt(self: Self) -> Self / pure { __builtin_sqrtf(self) }
    pub fn powf(self: Self, n: f32) -> Self / pure { __builtin_powf(self, n) }
    pub fn powi(self: Self, n: i32) -> Self / pure { __builtin_powif(self, n) }
    pub fn exp(self: Self) -> Self / pure { __builtin_expf(self) }
    pub fn ln(self: Self) -> Self / pure { __builtin_logf(self) }
    pub fn log10(self: Self) -> Self / pure { __builtin_log10f(self) }
    pub fn log2(self: Self) -> Self / pure { __builtin_log2f(self) }
    pub fn sin(self: Self) -> Self / pure { __builtin_sinf(self) }
    pub fn cos(self: Self) -> Self / pure { __builtin_cosf(self) }
    pub fn tan(self: Self) -> Self / pure { __builtin_tanf(self) }
}

/// Float constants and methods for f64
impl f64 {
    pub const RADIX: u32 = 2;
    pub const MANTISSA_DIGITS: u32 = 53;
    pub const DIGITS: u32 = 15;
    pub const EPSILON: f64 = 2.2204460492503131e-16;
    pub const MIN: f64 = -1.7976931348623157e+308;
    pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308;
    pub const MAX: f64 = 1.7976931348623157e+308;
    pub const MIN_EXP: i32 = -1021;
    pub const MAX_EXP: i32 = 1024;
    pub const MIN_10_EXP: i32 = -307;
    pub const MAX_10_EXP: i32 = 308;
    pub const NAN: f64 = 0.0 / 0.0;
    pub const INFINITY: f64 = 1.0 / 0.0;
    pub const NEG_INFINITY: f64 = -1.0 / 0.0;

    pub const fn is_nan(self: Self) -> bool / pure { self != self }
    pub const fn is_infinite(self: Self) -> bool / pure { self == Self::INFINITY || self == Self::NEG_INFINITY }
    pub const fn is_finite(self: Self) -> bool / pure { !self.is_nan() && !self.is_infinite() }
    pub fn is_sign_positive(self: Self) -> bool / pure { self.to_bits() & 0x8000000000000000 == 0 }
    pub fn is_sign_negative(self: Self) -> bool / pure { self.to_bits() & 0x8000000000000000 != 0 }

    pub fn to_bits(self: Self) -> u64 / pure { unsafe { mem::transmute(self) } }
    pub fn from_bits(bits: u64) -> Self / pure { unsafe { mem::transmute(bits) } }

    pub fn abs(self: Self) -> Self / pure { __builtin_fabs(self) }
    pub fn floor(self: Self) -> Self / pure { __builtin_floor(self) }
    pub fn ceil(self: Self) -> Self / pure { __builtin_ceil(self) }
    pub fn round(self: Self) -> Self / pure { __builtin_round(self) }
    pub fn trunc(self: Self) -> Self / pure { __builtin_trunc(self) }
    pub fn sqrt(self: Self) -> Self / pure { __builtin_sqrt(self) }
    pub fn powf(self: Self, n: f64) -> Self / pure { __builtin_pow(self, n) }
    pub fn powi(self: Self, n: i32) -> Self / pure { __builtin_powi(self, n) }
    pub fn exp(self: Self) -> Self / pure { __builtin_exp(self) }
    pub fn ln(self: Self) -> Self / pure { __builtin_log(self) }
    pub fn log10(self: Self) -> Self / pure { __builtin_log10(self) }
    pub fn log2(self: Self) -> Self / pure { __builtin_log2(self) }
    pub fn sin(self: Self) -> Self / pure { __builtin_sin(self) }
    pub fn cos(self: Self) -> Self / pure { __builtin_cos(self) }
    pub fn tan(self: Self) -> Self / pure { __builtin_tan(self) }
}

/// Boolean methods
impl bool {
    /// Returns Some(t) if self is true, else None
    pub fn then_some<T>(self: Self, t: T) -> Option<T> / pure {
        if self { Some(t) } else { None }
    }

    /// Returns Some(f()) if self is true, else None
    pub fn then<T, F: FnOnce() -> T>(self: Self, f: F) -> Option<T> / pure {
        if self { Some(f()) } else { None }
    }
}

/// Char methods
impl char {
    pub const MAX: char = '\u{10ffff}';
    pub const REPLACEMENT_CHARACTER: char = '\u{fffd}';
    pub const UNICODE_VERSION: (u8, u8, u8) = (15, 1, 0);

    /// Checks if a Unicode scalar value is valid
    pub fn from_u32(i: u32) -> Option<char> / pure {
        if i > 0x10FFFF || (i >= 0xD800 && i <= 0xDFFF) {
            None
        } else {
            Some(unsafe { mem::transmute(i) })
        }
    }

    /// Returns the numeric value of a digit character
    pub fn to_digit(self: Self, radix: u32) -> Option<u32> / pure {
        assert!(radix >= 2 && radix <= 36, "radix must be between 2 and 36");
        let val = match self {
            '0'..='9' => (self as u32) - ('0' as u32),
            'a'..='z' => (self as u32) - ('a' as u32) + 10,
            'A'..='Z' => (self as u32) - ('A' as u32) + 10,
            _ => return None,
        };
        if val < radix { Some(val) } else { None }
    }

    /// Creates a digit character from a number
    pub fn from_digit(num: u32, radix: u32) -> Option<char> / pure {
        assert!(radix >= 2 && radix <= 36, "radix must be between 2 and 36");
        if num < radix {
            let c = if num < 10 {
                (b'0' + num as u8) as char
            } else {
                (b'a' + num as u8 - 10) as char
            };
            Some(c)
        } else {
            None
        }
    }

    pub fn is_alphabetic(self: Self) -> bool / pure { __builtin_char_is_alphabetic(self) }
    pub fn is_numeric(self: Self) -> bool / pure { __builtin_char_is_numeric(self) }
    pub fn is_alphanumeric(self: Self) -> bool / pure { self.is_alphabetic() || self.is_numeric() }
    pub fn is_whitespace(self: Self) -> bool / pure { __builtin_char_is_whitespace(self) }
    pub fn is_uppercase(self: Self) -> bool / pure { __builtin_char_is_uppercase(self) }
    pub fn is_lowercase(self: Self) -> bool / pure { __builtin_char_is_lowercase(self) }
    pub fn is_control(self: Self) -> bool / pure { __builtin_char_is_control(self) }
    pub fn is_ascii(self: Self) -> bool / pure { (self as u32) <= 0x7F }

    pub fn to_uppercase(self: Self) -> ToUppercase / pure { __builtin_char_to_uppercase(self) }
    pub fn to_lowercase(self: Self) -> ToLowercase / pure { __builtin_char_to_lowercase(self) }
    pub fn to_ascii_uppercase(self: Self) -> char / pure {
        if self.is_ascii_lowercase() {
            ((self as u8) - 32) as char
        } else {
            self
        }
    }
    pub fn to_ascii_lowercase(self: Self) -> char / pure {
        if self.is_ascii_uppercase() {
            ((self as u8) + 32) as char
        } else {
            self
        }
    }

    pub fn is_ascii_uppercase(self: Self) -> bool / pure { matches!(self, 'A'..='Z') }
    pub fn is_ascii_lowercase(self: Self) -> bool / pure { matches!(self, 'a'..='z') }
    pub fn is_ascii_alphabetic(self: Self) -> bool / pure { self.is_ascii_uppercase() || self.is_ascii_lowercase() }
    pub fn is_ascii_digit(self: Self) -> bool / pure { matches!(self, '0'..='9') }
    pub fn is_ascii_hexdigit(self: Self) -> bool / pure { matches!(self, '0'..='9' | 'a'..='f' | 'A'..='F') }
    pub fn is_ascii_alphanumeric(self: Self) -> bool / pure { self.is_ascii_alphabetic() || self.is_ascii_digit() }
    pub fn is_ascii_whitespace(self: Self) -> bool / pure { matches!(self, ' ' | '\t' | '\n' | '\r' | '\x0c') }
    pub fn is_ascii_punctuation(self: Self) -> bool / pure { matches!(self, '!'..='/' | ':'..='@' | '['..='`' | '{'..='~') }
    pub fn is_ascii_graphic(self: Self) -> bool / pure { matches!(self, '!'..='~') }
    pub fn is_ascii_control(self: Self) -> bool / pure { matches!(self, '\x00'..='\x1f' | '\x7f') }

    pub fn len_utf8(self: Self) -> usize / pure {
        let code = self as u32;
        if code < 0x80 { 1 }
        else if code < 0x800 { 2 }
        else if code < 0x10000 { 3 }
        else { 4 }
    }

    pub fn len_utf16(self: Self) -> usize / pure {
        if (self as u32) < 0x10000 { 1 } else { 2 }
    }

    pub fn encode_utf8(self: Self, dst: &mut [u8]) -> &mut str / pure {
        let len = self.len_utf8();
        assert!(dst.len() >= len, "buffer too small");
        let code = self as u32;
        match len {
            1 => dst[0] = code as u8,
            2 => {
                dst[0] = 0xC0 | ((code >> 6) & 0x1F) as u8;
                dst[1] = 0x80 | (code & 0x3F) as u8;
            }
            3 => {
                dst[0] = 0xE0 | ((code >> 12) & 0x0F) as u8;
                dst[1] = 0x80 | ((code >> 6) & 0x3F) as u8;
                dst[2] = 0x80 | (code & 0x3F) as u8;
            }
            4 => {
                dst[0] = 0xF0 | ((code >> 18) & 0x07) as u8;
                dst[1] = 0x80 | ((code >> 12) & 0x3F) as u8;
                dst[2] = 0x80 | ((code >> 6) & 0x3F) as u8;
                dst[3] = 0x80 | (code & 0x3F) as u8;
            }
            _ => unreachable!(),
        }
        unsafe { str::from_utf8_unchecked_mut(&mut dst[..len]) }
    }
}

/// Iterator for uppercase conversion (may yield multiple chars)
pub struct ToUppercase {
    chars: [char; 3],
    len: usize,
    idx: usize,
}

impl Iterator for ToUppercase {
    type Item = char;

    fn next(self: &mut Self) -> Option<char> / pure {
        if self.idx < self.len {
            let c = self.chars[self.idx];
            self.idx += 1;
            Some(c)
        } else {
            None
        }
    }
}

/// Iterator for lowercase conversion (may yield multiple chars)
pub struct ToLowercase {
    chars: [char; 3],
    len: usize,
    idx: usize,
}

impl Iterator for ToLowercase {
    type Item = char;

    fn next(self: &mut Self) -> Option<char> / pure {
        if self.idx < self.len {
            let c = self.chars[self.idx];
            self.idx += 1;
            Some(c)
        } else {
            None
        }
    }
}
