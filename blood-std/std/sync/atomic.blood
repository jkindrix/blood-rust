// Blood Standard Library - Atomic Types
//
// Lock-free atomic operations.

/// Atomic memory ordering
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum Ordering {
    /// No ordering constraints
    Relaxed,
    /// A load operation that is part of an acquire sequence
    Acquire,
    /// A store operation that is part of a release sequence
    Release,
    /// Both acquire and release
    AcqRel,
    /// Sequential consistency
    SeqCst,
}

/// Issues a memory fence with the given ordering
pub fn fence(order: Ordering) / pure {
    __builtin_atomic_fence(order)
}

/// Issues a compiler fence (no CPU ordering)
pub fn compiler_fence(order: Ordering) / pure {
    __builtin_compiler_fence(order)
}

/// Atomic boolean type
pub struct AtomicBool {
    value: u8,
}

impl AtomicBool {
    /// Creates a new AtomicBool
    pub const fn new(value: bool) -> Self / pure {
        AtomicBool { value: value as u8 }
    }

    /// Loads the value
    pub fn load(self: &Self, order: Ordering) -> bool / pure {
        __builtin_atomic_load_u8(&self.value, order) != 0
    }

    /// Stores a value
    pub fn store(self: &Self, value: bool, order: Ordering) / pure {
        __builtin_atomic_store_u8(&self.value, value as u8, order)
    }

    /// Swaps the value
    pub fn swap(self: &Self, value: bool, order: Ordering) -> bool / pure {
        __builtin_atomic_swap_u8(&self.value, value as u8, order) != 0
    }

    /// Compares and exchanges the value
    pub fn compare_exchange(
        self: &Self,
        current: bool,
        new: bool,
        success: Ordering,
        failure: Ordering,
    ) -> Result<bool, bool> / pure {
        match __builtin_atomic_cmpxchg_u8(&self.value, current as u8, new as u8, success, failure) {
            Ok(v) => Ok(v != 0),
            Err(v) => Err(v != 0),
        }
    }

    /// Weak version of compare_exchange
    pub fn compare_exchange_weak(
        self: &Self,
        current: bool,
        new: bool,
        success: Ordering,
        failure: Ordering,
    ) -> Result<bool, bool> / pure {
        match __builtin_atomic_cmpxchg_weak_u8(&self.value, current as u8, new as u8, success, failure) {
            Ok(v) => Ok(v != 0),
            Err(v) => Err(v != 0),
        }
    }

    /// Logical AND and returns the previous value
    pub fn fetch_and(self: &Self, value: bool, order: Ordering) -> bool / pure {
        __builtin_atomic_and_u8(&self.value, value as u8, order) != 0
    }

    /// Logical OR and returns the previous value
    pub fn fetch_or(self: &Self, value: bool, order: Ordering) -> bool / pure {
        __builtin_atomic_or_u8(&self.value, value as u8, order) != 0
    }

    /// Logical XOR and returns the previous value
    pub fn fetch_xor(self: &Self, value: bool, order: Ordering) -> bool / pure {
        __builtin_atomic_xor_u8(&self.value, value as u8, order) != 0
    }

    /// Logical NAND and returns the previous value
    pub fn fetch_nand(self: &Self, value: bool, order: Ordering) -> bool / pure {
        __builtin_atomic_nand_u8(&self.value, value as u8, order) != 0
    }

    /// Gets a mutable reference to the underlying value
    pub fn get_mut(self: &mut Self) -> &mut bool / pure {
        unsafe { &mut *((&mut self.value) as *mut u8 as *mut bool) }
    }

    /// Consumes and returns the value
    pub fn into_inner(self: Self) -> bool / pure {
        self.value != 0
    }
}

impl Default for AtomicBool {
    fn default() -> Self / pure {
        AtomicBool::new(false)
    }
}

impl Debug for AtomicBool {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        Debug::fmt(&self.load(Ordering::SeqCst), f)
    }
}

impl From<bool> for AtomicBool {
    fn from(value: bool) -> Self / pure {
        AtomicBool::new(value)
    }
}

// Macro to generate atomic integer types
macro_rules! impl_atomic_int {
    ($name:ident, $int:ty, $load:ident, $store:ident, $swap:ident, $cmpxchg:ident, $cmpxchg_weak:ident,
     $add:ident, $sub:ident, $and:ident, $or:ident, $xor:ident, $max:ident, $min:ident) => {
        pub struct $name {
            value: $int,
        }

        impl $name {
            /// Creates a new atomic integer
            pub const fn new(value: $int) -> Self / pure {
                $name { value }
            }

            /// Loads the value
            pub fn load(self: &Self, order: Ordering) -> $int / pure {
                __builtin::$load(&self.value, order)
            }

            /// Stores a value
            pub fn store(self: &Self, value: $int, order: Ordering) / pure {
                __builtin::$store(&self.value, value, order)
            }

            /// Swaps the value
            pub fn swap(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$swap(&self.value, value, order)
            }

            /// Compares and exchanges
            pub fn compare_exchange(
                self: &Self,
                current: $int,
                new: $int,
                success: Ordering,
                failure: Ordering,
            ) -> Result<$int, $int> / pure {
                __builtin::$cmpxchg(&self.value, current, new, success, failure)
            }

            /// Weak compare and exchange
            pub fn compare_exchange_weak(
                self: &Self,
                current: $int,
                new: $int,
                success: Ordering,
                failure: Ordering,
            ) -> Result<$int, $int> / pure {
                __builtin::$cmpxchg_weak(&self.value, current, new, success, failure)
            }

            /// Adds and returns the previous value
            pub fn fetch_add(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$add(&self.value, value, order)
            }

            /// Subtracts and returns the previous value
            pub fn fetch_sub(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$sub(&self.value, value, order)
            }

            /// Bitwise AND and returns the previous value
            pub fn fetch_and(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$and(&self.value, value, order)
            }

            /// Bitwise OR and returns the previous value
            pub fn fetch_or(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$or(&self.value, value, order)
            }

            /// Bitwise XOR and returns the previous value
            pub fn fetch_xor(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$xor(&self.value, value, order)
            }

            /// Fetches the maximum value
            pub fn fetch_max(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$max(&self.value, value, order)
            }

            /// Fetches the minimum value
            pub fn fetch_min(self: &Self, value: $int, order: Ordering) -> $int / pure {
                __builtin::$min(&self.value, value, order)
            }

            /// Updates the value using a function
            pub fn fetch_update<F: FnMut($int) -> Option<$int>>(
                self: &Self,
                set_order: Ordering,
                fetch_order: Ordering,
                f: F,
            ) -> Result<$int, $int> / pure {
                let mut prev = self.load(fetch_order);
                loop {
                    match f(prev) {
                        Some(next) => {
                            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                                Ok(_) => return Ok(prev),
                                Err(old) => prev = old,
                            }
                        }
                        None => return Err(prev),
                    }
                }
            }

            /// Gets a mutable reference
            pub fn get_mut(self: &mut Self) -> &mut $int / pure {
                &mut self.value
            }

            /// Consumes and returns the value
            pub fn into_inner(self: Self) -> $int / pure {
                self.value
            }
        }

        impl Default for $name {
            fn default() -> Self / pure {
                $name::new(0)
            }
        }

        impl Debug for $name {
            fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
                Debug::fmt(&self.load(Ordering::SeqCst), f)
            }
        }

        impl From<$int> for $name {
            fn from(value: $int) -> Self / pure {
                $name::new(value)
            }
        }
    };
}

impl_atomic_int!(AtomicI8, i8, atomic_load_i8, atomic_store_i8, atomic_swap_i8,
    atomic_cmpxchg_i8, atomic_cmpxchg_weak_i8, atomic_add_i8, atomic_sub_i8,
    atomic_and_i8, atomic_or_i8, atomic_xor_i8, atomic_max_i8, atomic_min_i8);

impl_atomic_int!(AtomicI16, i16, atomic_load_i16, atomic_store_i16, atomic_swap_i16,
    atomic_cmpxchg_i16, atomic_cmpxchg_weak_i16, atomic_add_i16, atomic_sub_i16,
    atomic_and_i16, atomic_or_i16, atomic_xor_i16, atomic_max_i16, atomic_min_i16);

impl_atomic_int!(AtomicI32, i32, atomic_load_i32, atomic_store_i32, atomic_swap_i32,
    atomic_cmpxchg_i32, atomic_cmpxchg_weak_i32, atomic_add_i32, atomic_sub_i32,
    atomic_and_i32, atomic_or_i32, atomic_xor_i32, atomic_max_i32, atomic_min_i32);

impl_atomic_int!(AtomicI64, i64, atomic_load_i64, atomic_store_i64, atomic_swap_i64,
    atomic_cmpxchg_i64, atomic_cmpxchg_weak_i64, atomic_add_i64, atomic_sub_i64,
    atomic_and_i64, atomic_or_i64, atomic_xor_i64, atomic_max_i64, atomic_min_i64);

impl_atomic_int!(AtomicU8, u8, atomic_load_u8, atomic_store_u8, atomic_swap_u8,
    atomic_cmpxchg_u8, atomic_cmpxchg_weak_u8, atomic_add_u8, atomic_sub_u8,
    atomic_and_u8, atomic_or_u8, atomic_xor_u8, atomic_max_u8, atomic_min_u8);

impl_atomic_int!(AtomicU16, u16, atomic_load_u16, atomic_store_u16, atomic_swap_u16,
    atomic_cmpxchg_u16, atomic_cmpxchg_weak_u16, atomic_add_u16, atomic_sub_u16,
    atomic_and_u16, atomic_or_u16, atomic_xor_u16, atomic_max_u16, atomic_min_u16);

impl_atomic_int!(AtomicU32, u32, atomic_load_u32, atomic_store_u32, atomic_swap_u32,
    atomic_cmpxchg_u32, atomic_cmpxchg_weak_u32, atomic_add_u32, atomic_sub_u32,
    atomic_and_u32, atomic_or_u32, atomic_xor_u32, atomic_max_u32, atomic_min_u32);

impl_atomic_int!(AtomicU64, u64, atomic_load_u64, atomic_store_u64, atomic_swap_u64,
    atomic_cmpxchg_u64, atomic_cmpxchg_weak_u64, atomic_add_u64, atomic_sub_u64,
    atomic_and_u64, atomic_or_u64, atomic_xor_u64, atomic_max_u64, atomic_min_u64);

impl_atomic_int!(AtomicUsize, usize, atomic_load_usize, atomic_store_usize, atomic_swap_usize,
    atomic_cmpxchg_usize, atomic_cmpxchg_weak_usize, atomic_add_usize, atomic_sub_usize,
    atomic_and_usize, atomic_or_usize, atomic_xor_usize, atomic_max_usize, atomic_min_usize);

impl_atomic_int!(AtomicIsize, isize, atomic_load_isize, atomic_store_isize, atomic_swap_isize,
    atomic_cmpxchg_isize, atomic_cmpxchg_weak_isize, atomic_add_isize, atomic_sub_isize,
    atomic_and_isize, atomic_or_isize, atomic_xor_isize, atomic_max_isize, atomic_min_isize);

/// Atomic pointer type
pub struct AtomicPtr<T> {
    value: *mut T,
}

impl<T> AtomicPtr<T> {
    /// Creates a new AtomicPtr
    pub const fn new(ptr: *mut T) -> Self / pure {
        AtomicPtr { value: ptr }
    }

    /// Loads the pointer
    pub fn load(self: &Self, order: Ordering) -> *mut T / pure {
        __builtin_atomic_load_ptr(&self.value, order)
    }

    /// Stores a pointer
    pub fn store(self: &Self, ptr: *mut T, order: Ordering) / pure {
        __builtin_atomic_store_ptr(&self.value, ptr, order)
    }

    /// Swaps the pointer
    pub fn swap(self: &Self, ptr: *mut T, order: Ordering) -> *mut T / pure {
        __builtin_atomic_swap_ptr(&self.value, ptr, order)
    }

    /// Compares and exchanges
    pub fn compare_exchange(
        self: &Self,
        current: *mut T,
        new: *mut T,
        success: Ordering,
        failure: Ordering,
    ) -> Result<*mut T, *mut T> / pure {
        __builtin_atomic_cmpxchg_ptr(&self.value, current, new, success, failure)
    }

    /// Weak compare and exchange
    pub fn compare_exchange_weak(
        self: &Self,
        current: *mut T,
        new: *mut T,
        success: Ordering,
        failure: Ordering,
    ) -> Result<*mut T, *mut T> / pure {
        __builtin_atomic_cmpxchg_weak_ptr(&self.value, current, new, success, failure)
    }

    /// Gets a mutable reference
    pub fn get_mut(self: &mut Self) -> &mut *mut T / pure {
        &mut self.value
    }

    /// Consumes and returns the pointer
    pub fn into_inner(self: Self) -> *mut T / pure {
        self.value
    }
}

impl<T> Default for AtomicPtr<T> {
    fn default() -> Self / pure {
        AtomicPtr::new(ptr::null_mut())
    }
}

impl<T> Debug for AtomicPtr<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        Debug::fmt(&self.load(Ordering::SeqCst), f)
    }
}

impl<T> From<*mut T> for AtomicPtr<T> {
    fn from(ptr: *mut T) -> Self / pure {
        AtomicPtr::new(ptr)
    }
}

unsafe impl<T> Send for AtomicPtr<T> {}
unsafe impl<T> Sync for AtomicPtr<T> {}
