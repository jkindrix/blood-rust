// Blood Standard Library - Mutex
//
// Mutual exclusion lock.

use super::atomic::{AtomicBool, AtomicU32, Ordering};
use crate::cell::UnsafeCell;

/// A mutual exclusion lock
///
/// Mutex provides interior mutability with runtime exclusive access
/// enforcement and thread safety.
pub struct Mutex<T: ?Sized> {
    locked: AtomicBool,
    data: UnsafeCell<T>,
}

impl<T> Mutex<T> {
    /// Creates a new Mutex
    pub const fn new(value: T) -> Self / pure {
        Mutex {
            locked: AtomicBool::new(false),
            data: UnsafeCell::new(value),
        }
    }

    /// Consumes the mutex and returns the inner value
    pub fn into_inner(self: Self) -> T / pure {
        self.data.into_inner()
    }
}

impl<T: ?Sized> Mutex<T> {
    /// Acquires the lock, blocking until available
    pub fn lock(self: &Self) -> MutexGuard<'_, T> / pure {
        // Simple spinlock for demonstration
        // Real implementation would use OS primitives
        while self.locked.compare_exchange(
            false,
            true,
            Ordering::Acquire,
            Ordering::Relaxed
        ).is_err() {
            // Spin-wait
            core::hint::spin_loop();
        }

        MutexGuard { mutex: self }
    }

    /// Attempts to acquire the lock without blocking
    pub fn try_lock(self: &Self) -> Option<MutexGuard<'_, T>> / pure {
        if self.locked.compare_exchange(
            false,
            true,
            Ordering::Acquire,
            Ordering::Relaxed
        ).is_ok() {
            Some(MutexGuard { mutex: self })
        } else {
            None
        }
    }

    /// Returns true if the lock is currently held
    pub fn is_locked(self: &Self) -> bool / pure {
        self.locked.load(Ordering::Relaxed)
    }

    /// Gets a mutable reference to the underlying data
    ///
    /// This is safe because &mut Self guarantees exclusive access.
    pub fn get_mut(self: &mut Self) -> &mut T / pure {
        self.data.get_mut()
    }
}

impl<T: ?Sized + Default> Default for Mutex<T> {
    fn default() -> Self / pure {
        Mutex::new(T::default())
    }
}

impl<T: ?Sized + Debug> Debug for Mutex<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self.try_lock() {
            Some(guard) => {
                f.debug_struct("Mutex")
                    .field("data", &*guard)
                    .finish()
            }
            None => {
                struct LockedPlaceholder;
                impl Debug for LockedPlaceholder {
                    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
                        f.write_str("<locked>")
                    }
                }
                f.debug_struct("Mutex")
                    .field("data", &LockedPlaceholder)
                    .finish()
            }
        }
    }
}

impl<T> From<T> for Mutex<T> {
    fn from(value: T) -> Self / pure {
        Mutex::new(value)
    }
}

unsafe impl<T: ?Sized + Send> Send for Mutex<T> {}
unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}

/// An RAII guard that releases the lock when dropped
pub struct MutexGuard<'a, T: ?Sized> {
    mutex: &'a Mutex<T>,
}

impl<'a, T: ?Sized> Deref for MutexGuard<'a, T> {
    type Target = T;

    fn deref(self: &Self) -> &T / pure {
        unsafe { &*self.mutex.data.get() }
    }
}

impl<'a, T: ?Sized> DerefMut for MutexGuard<'a, T> {
    fn deref_mut(self: &mut Self) -> &mut T / pure {
        unsafe { &mut *self.mutex.data.get() }
    }
}

impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {
    fn drop(self: &mut Self) / pure {
        self.mutex.locked.store(false, Ordering::Release);
    }
}

impl<'a, T: ?Sized + Debug> Debug for MutexGuard<'a, T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        Debug::fmt(&**self, f)
    }
}

impl<'a, T: ?Sized + Display> Display for MutexGuard<'a, T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        Display::fmt(&**self, f)
    }
}

/// A poisoned mutex error (when a thread panicked while holding the lock)
pub struct PoisonError<T> {
    guard: T,
}

impl<T> PoisonError<T> {
    /// Creates a new PoisonError
    pub fn new(guard: T) -> Self / pure {
        PoisonError { guard }
    }

    /// Consumes the error and returns the guard
    pub fn into_inner(self: Self) -> T / pure {
        self.guard
    }

    /// Returns a reference to the guard
    pub fn get_ref(self: &Self) -> &T / pure {
        &self.guard
    }

    /// Returns a mutable reference to the guard
    pub fn get_mut(self: &mut Self) -> &mut T / pure {
        &mut self.guard
    }
}

impl<T> Debug for PoisonError<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("PoisonError { .. }")
    }
}

impl<T> Display for PoisonError<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        f.write_str("poisoned lock: another task failed inside")
    }
}

/// Result type for lock operations that might be poisoned
pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;

/// Result type for try_lock operations
pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;

/// Error returned by try_lock
pub enum TryLockError<T> {
    /// The lock is poisoned
    Poisoned(PoisonError<T>),
    /// The lock would block
    WouldBlock,
}

impl<T> Debug for TryLockError<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self {
            TryLockError::Poisoned(_) => f.write_str("TryLockError::Poisoned(..)"),
            TryLockError::WouldBlock => f.write_str("TryLockError::WouldBlock"),
        }
    }
}

impl<T> Display for TryLockError<T> {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self {
            TryLockError::Poisoned(_) => f.write_str("poisoned lock: another task failed inside"),
            TryLockError::WouldBlock => f.write_str("try_lock failed because the operation would block"),
        }
    }
}

impl<T> From<PoisonError<T>> for TryLockError<T> {
    fn from(err: PoisonError<T>) -> Self / pure {
        TryLockError::Poisoned(err)
    }
}
