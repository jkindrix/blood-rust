// Blood Standard Library - Comparison Traits
//
// Traits for comparing and ordering values.

/// Result of a comparison between two values
pub enum Ordering {
    /// The first value is less than the second
    Less,
    /// The two values are equal
    Equal,
    /// The first value is greater than the second
    Greater,
}

impl Ordering {
    /// Returns true if the ordering is Less
    pub fn is_lt(self: Self) -> bool / pure {
        matches!(self, Ordering::Less)
    }

    /// Returns true if the ordering is Equal
    pub fn is_eq(self: Self) -> bool / pure {
        matches!(self, Ordering::Equal)
    }

    /// Returns true if the ordering is Greater
    pub fn is_gt(self: Self) -> bool / pure {
        matches!(self, Ordering::Greater)
    }

    /// Returns true if the ordering is Less or Equal
    pub fn is_le(self: Self) -> bool / pure {
        !matches!(self, Ordering::Greater)
    }

    /// Returns true if the ordering is Greater or Equal
    pub fn is_ge(self: Self) -> bool / pure {
        !matches!(self, Ordering::Less)
    }

    /// Returns true if the ordering is not Equal
    pub fn is_ne(self: Self) -> bool / pure {
        !matches!(self, Ordering::Equal)
    }

    /// Reverses the ordering
    pub fn reverse(self: Self) -> Self / pure {
        match self {
            Ordering::Less => Ordering::Greater,
            Ordering::Equal => Ordering::Equal,
            Ordering::Greater => Ordering::Less,
        }
    }

    /// Chains two orderings
    pub fn then(self: Self, other: Ordering) -> Ordering / pure {
        match self {
            Ordering::Equal => other,
            _ => self,
        }
    }

    /// Chains with a function that computes the secondary ordering
    pub fn then_with<F>(self: Self, f: F) -> Ordering / pure
    where
        F: FnOnce() -> Ordering,
    {
        match self {
            Ordering::Equal => f(),
            _ => self,
        }
    }
}

impl Clone for Ordering {
    fn clone(self: &Self) -> Self / pure { *self }
}

impl Copy for Ordering {}

impl PartialEq for Ordering {
    fn eq(self: &Self, other: &Self) -> bool / pure {
        match (self, other) {
            (Ordering::Less, Ordering::Less) => true,
            (Ordering::Equal, Ordering::Equal) => true,
            (Ordering::Greater, Ordering::Greater) => true,
            _ => false,
        }
    }
}

impl Eq for Ordering {}

impl Debug for Ordering {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self {
            Ordering::Less => f.write_str("Less"),
            Ordering::Equal => f.write_str("Equal"),
            Ordering::Greater => f.write_str("Greater"),
        }
    }
}

/// Trait for partial equality comparisons
pub trait PartialEq<Rhs = Self> {
    /// Tests for equality
    fn eq(self: &Self, other: &Rhs) -> bool / pure;

    /// Tests for inequality
    fn ne(self: &Self, other: &Rhs) -> bool / pure {
        !self.eq(other)
    }
}

/// Trait for full equality comparisons
///
/// Eq requires that equality is reflexive, symmetric, and transitive.
pub trait Eq: PartialEq {}

/// Trait for partial ordering comparisons
pub trait PartialOrd<Rhs = Self>: PartialEq<Rhs> {
    /// Returns an ordering if one exists
    fn partial_cmp(self: &Self, other: &Rhs) -> Option<Ordering> / pure;

    /// Tests for less than
    fn lt(self: &Self, other: &Rhs) -> bool / pure {
        matches!(self.partial_cmp(other), Some(Ordering::Less))
    }

    /// Tests for less than or equal
    fn le(self: &Self, other: &Rhs) -> bool / pure {
        matches!(self.partial_cmp(other), Some(Ordering::Less) | Some(Ordering::Equal))
    }

    /// Tests for greater than
    fn gt(self: &Self, other: &Rhs) -> bool / pure {
        matches!(self.partial_cmp(other), Some(Ordering::Greater))
    }

    /// Tests for greater than or equal
    fn ge(self: &Self, other: &Rhs) -> bool / pure {
        matches!(self.partial_cmp(other), Some(Ordering::Greater) | Some(Ordering::Equal))
    }
}

/// Trait for total ordering
pub trait Ord: Eq + PartialOrd {
    /// Returns the ordering between self and other
    fn cmp(self: &Self, other: &Self) -> Ordering / pure;

    /// Returns the maximum of two values
    fn max(self: Self, other: Self) -> Self / pure {
        match self.cmp(&other) {
            Ordering::Less | Ordering::Equal => other,
            Ordering::Greater => self,
        }
    }

    /// Returns the minimum of two values
    fn min(self: Self, other: Self) -> Self / pure {
        match self.cmp(&other) {
            Ordering::Less | Ordering::Equal => self,
            Ordering::Greater => other,
        }
    }

    /// Clamps a value within bounds
    fn clamp(self: Self, min: Self, max: Self) -> Self / pure
    where
        Self: Sized,
    {
        if self.cmp(&min) == Ordering::Less {
            min
        } else if self.cmp(&max) == Ordering::Greater {
            max
        } else {
            self
        }
    }
}

/// Returns the minimum of two values
pub fn min<T: Ord>(a: T, b: T) -> T / pure {
    a.min(b)
}

/// Returns the maximum of two values
pub fn max<T: Ord>(a: T, b: T) -> T / pure {
    a.max(b)
}

/// Returns the minimum and maximum of two values
pub fn minmax<T: Ord>(a: T, b: T) -> (T, T) / pure {
    if a.cmp(&b) == Ordering::Less {
        (a, b)
    } else {
        (b, a)
    }
}

// PartialEq implementations for primitives

impl PartialEq for bool {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for char {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for i8 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for i16 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for i32 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for i64 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for u8 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for u16 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for u32 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for u64 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for usize {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for f32 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

impl PartialEq for f64 {
    fn eq(self: &Self, other: &Self) -> bool / pure { *self == *other }
}

// Eq implementations
impl Eq for bool {}
impl Eq for char {}
impl Eq for i8 {}
impl Eq for i16 {}
impl Eq for i32 {}
impl Eq for i64 {}
impl Eq for u8 {}
impl Eq for u16 {}
impl Eq for u32 {}
impl Eq for u64 {}
impl Eq for usize {}
// Note: f32 and f64 do NOT implement Eq due to NaN

// PartialOrd implementations for primitives

impl PartialOrd for i32 {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        Some(self.cmp(other))
    }
}

impl PartialOrd for i64 {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        Some(self.cmp(other))
    }
}

impl PartialOrd for u32 {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        Some(self.cmp(other))
    }
}

impl PartialOrd for u64 {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        Some(self.cmp(other))
    }
}

impl PartialOrd for f64 {
    fn partial_cmp(self: &Self, other: &Self) -> Option<Ordering> / pure {
        if self.is_nan() || other.is_nan() {
            None
        } else if *self < *other {
            Some(Ordering::Less)
        } else if *self > *other {
            Some(Ordering::Greater)
        } else {
            Some(Ordering::Equal)
        }
    }
}

// Ord implementations for primitives

impl Ord for i32 {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        if *self < *other { Ordering::Less }
        else if *self > *other { Ordering::Greater }
        else { Ordering::Equal }
    }
}

impl Ord for i64 {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        if *self < *other { Ordering::Less }
        else if *self > *other { Ordering::Greater }
        else { Ordering::Equal }
    }
}

impl Ord for u32 {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        if *self < *other { Ordering::Less }
        else if *self > *other { Ordering::Greater }
        else { Ordering::Equal }
    }
}

impl Ord for u64 {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        if *self < *other { Ordering::Less }
        else if *self > *other { Ordering::Greater }
        else { Ordering::Equal }
    }
}

impl Ord for usize {
    fn cmp(self: &Self, other: &Self) -> Ordering / pure {
        if *self < *other { Ordering::Less }
        else if *self > *other { Ordering::Greater }
        else { Ordering::Equal }
    }
}
