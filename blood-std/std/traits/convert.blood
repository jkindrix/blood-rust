// Blood Standard Library - Conversion Traits
//
// Traits for converting between types.

/// Trait for conversions that consume the input value
///
/// Implementing `From` automatically provides `Into`.
pub trait From<T> {
    /// Converts from the input type
    fn from(value: T) -> Self / pure;
}

/// Trait for conversions that consume self
///
/// Prefer implementing `From` instead when possible.
pub trait Into<T> {
    /// Converts this type into the target type
    fn into(self: Self) -> T / pure;
}

// Blanket implementation: From implies Into
impl<T, U> Into<U> for T
where
    U: From<T>,
{
    fn into(self: Self) -> U / pure {
        U::from(self)
    }
}

// Identity conversion
impl<T> From<T> for T {
    fn from(value: T) -> Self / pure { value }
}

/// Trait for fallible conversions that consume the input value
pub trait TryFrom<T>: Sized {
    /// The error type returned on conversion failure
    type Error;

    /// Attempts to convert from the input type
    fn try_from(value: T) -> Result<Self, Self::Error> / pure;
}

/// Trait for fallible conversions that consume self
pub trait TryInto<T>: Sized {
    /// The error type returned on conversion failure
    type Error;

    /// Attempts to convert this type into the target type
    fn try_into(self: Self) -> Result<T, Self::Error> / pure;
}

// Blanket implementation: TryFrom implies TryInto
impl<T, U> TryInto<U> for T
where
    U: TryFrom<T>,
{
    type Error = U::Error;

    fn try_into(self: Self) -> Result<U, Self::Error> / pure {
        U::try_from(self)
    }
}

// Infallible TryFrom when From exists
impl<T, U> TryFrom<U> for T
where
    T: From<U>,
{
    type Error = !;  // Never type - conversion cannot fail

    fn try_from(value: U) -> Result<Self, Self::Error> / pure {
        Ok(T::from(value))
    }
}

/// Trait for cheap reference-to-reference conversions
pub trait AsRef<T: ?Sized> {
    /// Converts this reference to a reference of the target type
    fn as_ref(self: &Self) -> &T / pure;
}

/// Trait for cheap mutable reference-to-mutable reference conversions
pub trait AsMut<T: ?Sized> {
    /// Converts this mutable reference to a mutable reference of the target type
    fn as_mut(self: &mut Self) -> &mut T / pure;
}

// Identity AsRef
impl<T: ?Sized> AsRef<T> for T {
    fn as_ref(self: &Self) -> &T / pure { self }
}

// Identity AsMut
impl<T: ?Sized> AsMut<T> for T {
    fn as_mut(self: &mut Self) -> &mut T / pure { self }
}

// AsRef for references
impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T
where
    T: AsRef<U>,
{
    fn as_ref(self: &Self) -> &U / pure {
        (*self).as_ref()
    }
}

/// Trait for borrowing data
///
/// Borrow is similar to AsRef but has additional semantic meaning:
/// the borrowed form must hash and compare the same as the owned form.
pub trait Borrow<Borrowed: ?Sized> {
    /// Borrows data from the owned form
    fn borrow(self: &Self) -> &Borrowed / pure;
}

/// Trait for mutably borrowing data
pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {
    /// Mutably borrows data from the owned form
    fn borrow_mut(self: &mut Self) -> &mut Borrowed / pure;
}

// Identity Borrow
impl<T: ?Sized> Borrow<T> for T {
    fn borrow(self: &Self) -> &T / pure { self }
}

// Identity BorrowMut
impl<T: ?Sized> BorrowMut<T> for T {
    fn borrow_mut(self: &mut Self) -> &mut T / pure { self }
}

// Borrow for references
impl<'a, T: ?Sized> Borrow<T> for &'a T {
    fn borrow(self: &Self) -> &T / pure { *self }
}

// String conversions
impl AsRef<str> for String {
    fn as_ref(self: &Self) -> &str / pure {
        self.as_str()
    }
}

impl AsRef<[u8]> for String {
    fn as_ref(self: &Self) -> &[u8] / pure {
        self.as_bytes()
    }
}

impl Borrow<str> for String {
    fn borrow(self: &Self) -> &str / pure {
        self.as_str()
    }
}

impl From<&str> for String {
    fn from(s: &str) -> String / pure {
        String::from_str(s)
    }
}

// Slice conversions
impl<T> AsRef<[T]> for Vec<T> {
    fn as_ref(self: &Self) -> &[T] / pure {
        self.as_slice()
    }
}

impl<T> AsMut<[T]> for Vec<T> {
    fn as_mut(self: &mut Self) -> &mut [T] / pure {
        self.as_mut_slice()
    }
}

impl<T> Borrow<[T]> for Vec<T> {
    fn borrow(self: &Self) -> &[T] / pure {
        self.as_slice()
    }
}

impl<T> BorrowMut<[T]> for Vec<T> {
    fn borrow_mut(self: &mut Self) -> &mut [T] / pure {
        self.as_mut_slice()
    }
}

// Array conversions
impl<T, const N: usize> AsRef<[T]> for [T; N] {
    fn as_ref(self: &Self) -> &[T] / pure {
        self
    }
}

impl<T, const N: usize> AsMut<[T]> for [T; N] {
    fn as_mut(self: &mut Self) -> &mut [T] / pure {
        self
    }
}

// Numeric conversions (widening - infallible)
impl From<u8> for u16 {
    fn from(value: u8) -> u16 / pure { value as u16 }
}

impl From<u8> for u32 {
    fn from(value: u8) -> u32 / pure { value as u32 }
}

impl From<u8> for u64 {
    fn from(value: u8) -> u64 / pure { value as u64 }
}

impl From<u8> for usize {
    fn from(value: u8) -> usize / pure { value as usize }
}

impl From<u16> for u32 {
    fn from(value: u16) -> u32 / pure { value as u32 }
}

impl From<u16> for u64 {
    fn from(value: u16) -> u64 / pure { value as u64 }
}

impl From<u32> for u64 {
    fn from(value: u32) -> u64 / pure { value as u64 }
}

impl From<i8> for i16 {
    fn from(value: i8) -> i16 / pure { value as i16 }
}

impl From<i8> for i32 {
    fn from(value: i8) -> i32 / pure { value as i32 }
}

impl From<i8> for i64 {
    fn from(value: i8) -> i64 / pure { value as i64 }
}

impl From<i16> for i32 {
    fn from(value: i16) -> i32 / pure { value as i32 }
}

impl From<i16> for i64 {
    fn from(value: i16) -> i64 / pure { value as i64 }
}

impl From<i32> for i64 {
    fn from(value: i32) -> i64 / pure { value as i64 }
}

impl From<f32> for f64 {
    fn from(value: f32) -> f64 / pure { value as f64 }
}

// Numeric conversions (narrowing - fallible)

/// Error type for integer conversion failures
pub struct TryFromIntError {
    kind: IntErrorKind,
}

pub enum IntErrorKind {
    Overflow,
    Underflow,
}

impl TryFromIntError {
    pub fn new(kind: IntErrorKind) -> Self / pure {
        TryFromIntError { kind }
    }
}

impl Debug for TryFromIntError {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self.kind {
            IntErrorKind::Overflow => f.write_str("integer overflow"),
            IntErrorKind::Underflow => f.write_str("integer underflow"),
        }
    }
}

impl Display for TryFromIntError {
    fn fmt(self: &Self, f: &mut Formatter) -> Result<(), Error> / {IO} {
        match self.kind {
            IntErrorKind::Overflow => f.write_str("out of range integral type conversion attempted"),
            IntErrorKind::Underflow => f.write_str("out of range integral type conversion attempted"),
        }
    }
}

impl TryFrom<u64> for u32 {
    type Error = TryFromIntError;

    fn try_from(value: u64) -> Result<u32, TryFromIntError> / pure {
        if value <= u32::MAX as u64 {
            Ok(value as u32)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        }
    }
}

impl TryFrom<u64> for u16 {
    type Error = TryFromIntError;

    fn try_from(value: u64) -> Result<u16, TryFromIntError> / pure {
        if value <= u16::MAX as u64 {
            Ok(value as u16)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        }
    }
}

impl TryFrom<u64> for u8 {
    type Error = TryFromIntError;

    fn try_from(value: u64) -> Result<u8, TryFromIntError> / pure {
        if value <= u8::MAX as u64 {
            Ok(value as u8)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        }
    }
}

impl TryFrom<i64> for i32 {
    type Error = TryFromIntError;

    fn try_from(value: i64) -> Result<i32, TryFromIntError> / pure {
        if value >= i32::MIN as i64 && value <= i32::MAX as i64 {
            Ok(value as i32)
        } else if value > i32::MAX as i64 {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        } else {
            Err(TryFromIntError::new(IntErrorKind::Underflow))
        }
    }
}

impl TryFrom<i64> for i16 {
    type Error = TryFromIntError;

    fn try_from(value: i64) -> Result<i16, TryFromIntError> / pure {
        if value >= i16::MIN as i64 && value <= i16::MAX as i64 {
            Ok(value as i16)
        } else if value > i16::MAX as i64 {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        } else {
            Err(TryFromIntError::new(IntErrorKind::Underflow))
        }
    }
}

impl TryFrom<i64> for i8 {
    type Error = TryFromIntError;

    fn try_from(value: i64) -> Result<i8, TryFromIntError> / pure {
        if value >= i8::MIN as i64 && value <= i8::MAX as i64 {
            Ok(value as i8)
        } else if value > i8::MAX as i64 {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        } else {
            Err(TryFromIntError::new(IntErrorKind::Underflow))
        }
    }
}

// Signed/unsigned conversions
impl TryFrom<i32> for u32 {
    type Error = TryFromIntError;

    fn try_from(value: i32) -> Result<u32, TryFromIntError> / pure {
        if value >= 0 {
            Ok(value as u32)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Underflow))
        }
    }
}

impl TryFrom<i64> for u64 {
    type Error = TryFromIntError;

    fn try_from(value: i64) -> Result<u64, TryFromIntError> / pure {
        if value >= 0 {
            Ok(value as u64)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Underflow))
        }
    }
}

impl TryFrom<u32> for i32 {
    type Error = TryFromIntError;

    fn try_from(value: u32) -> Result<i32, TryFromIntError> / pure {
        if value <= i32::MAX as u32 {
            Ok(value as i32)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        }
    }
}

impl TryFrom<u64> for i64 {
    type Error = TryFromIntError;

    fn try_from(value: u64) -> Result<i64, TryFromIntError> / pure {
        if value <= i64::MAX as u64 {
            Ok(value as i64)
        } else {
            Err(TryFromIntError::new(IntErrorKind::Overflow))
        }
    }
}
