// Blood Standard Library - Hash Traits
//
// Traits for hashing values.

/// Trait for types that can be hashed
pub trait Hash {
    /// Feeds this value into the given hasher
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure;

    /// Feeds a slice of this type into the given hasher
    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) / pure
    where
        Self: Sized,
    {
        for item in data {
            item.hash(state);
        }
    }
}

/// Trait for hashers
pub trait Hasher {
    /// Returns the hash value
    fn finish(self: &Self) -> u64 / pure;

    /// Writes bytes to the hasher
    fn write(self: &mut Self, bytes: &[u8]) / pure;

    /// Writes a single byte
    fn write_u8(self: &mut Self, i: u8) / pure {
        self.write(&[i])
    }

    /// Writes a u16
    fn write_u16(self: &mut Self, i: u16) / pure {
        self.write(&i.to_le_bytes())
    }

    /// Writes a u32
    fn write_u32(self: &mut Self, i: u32) / pure {
        self.write(&i.to_le_bytes())
    }

    /// Writes a u64
    fn write_u64(self: &mut Self, i: u64) / pure {
        self.write(&i.to_le_bytes())
    }

    /// Writes a u128
    fn write_u128(self: &mut Self, i: u128) / pure {
        self.write(&i.to_le_bytes())
    }

    /// Writes a usize
    fn write_usize(self: &mut Self, i: usize) / pure {
        self.write(&(i as u64).to_le_bytes())
    }

    /// Writes an i8
    fn write_i8(self: &mut Self, i: i8) / pure {
        self.write_u8(i as u8)
    }

    /// Writes an i16
    fn write_i16(self: &mut Self, i: i16) / pure {
        self.write_u16(i as u16)
    }

    /// Writes an i32
    fn write_i32(self: &mut Self, i: i32) / pure {
        self.write_u32(i as u32)
    }

    /// Writes an i64
    fn write_i64(self: &mut Self, i: i64) / pure {
        self.write_u64(i as u64)
    }

    /// Writes an i128
    fn write_i128(self: &mut Self, i: i128) / pure {
        self.write_u128(i as u128)
    }

    /// Writes an isize
    fn write_isize(self: &mut Self, i: isize) / pure {
        self.write_usize(i as usize)
    }

    /// Writes a length prefix (for variable-length data)
    fn write_length_prefix(self: &mut Self, len: usize) / pure {
        self.write_usize(len)
    }
}

/// Trait for building hashers with keys
pub trait BuildHasher {
    /// The hasher type
    type Hasher: Hasher;

    /// Creates a new hasher
    fn build_hasher(self: &Self) -> Self::Hasher / pure;

    /// Hashes a single value
    fn hash_one<T: Hash>(self: &Self, value: &T) -> u64 / pure {
        let mut hasher = self.build_hasher();
        value.hash(&mut hasher);
        hasher.finish()
    }
}

/// Default hasher state for random seeding
pub struct RandomState {
    k0: u64,
    k1: u64,
}

impl RandomState {
    /// Creates a new RandomState with random keys
    pub fn new() -> Self / {Random} {
        RandomState {
            k0: perform random_u64(),
            k1: perform random_u64(),
        }
    }

    /// Creates a RandomState with specific keys (for testing)
    pub fn with_seeds(k0: u64, k1: u64) -> Self / pure {
        RandomState { k0, k1 }
    }
}

impl Default for RandomState {
    fn default() -> Self / pure {
        // Use fixed default keys when effect handling isn't available
        RandomState::with_seeds(0x517cc1b727220a95, 0x6b63f7f7d5e94c95)
    }
}

impl BuildHasher for RandomState {
    type Hasher = SipHasher;

    fn build_hasher(self: &Self) -> SipHasher / pure {
        SipHasher::new_with_keys(self.k0, self.k1)
    }
}

/// SipHash 1-3 hasher
///
/// A fast, cryptographically strong hash function suitable for hash tables.
pub struct SipHasher {
    v0: u64,
    v1: u64,
    v2: u64,
    v3: u64,
    buf: [u8; 8],
    buf_len: usize,
    length: usize,
}

impl SipHasher {
    /// Creates a new SipHasher with default keys
    pub fn new() -> Self / pure {
        SipHasher::new_with_keys(0, 0)
    }

    /// Creates a new SipHasher with specific keys
    pub fn new_with_keys(k0: u64, k1: u64) -> Self / pure {
        SipHasher {
            v0: k0 ^ 0x736f6d6570736575,
            v1: k1 ^ 0x646f72616e646f6d,
            v2: k0 ^ 0x6c7967656e657261,
            v3: k1 ^ 0x7465646279746573,
            buf: [0; 8],
            buf_len: 0,
            length: 0,
        }
    }

    fn sipround(self: &mut Self) / pure {
        self.v0 = self.v0.wrapping_add(self.v1);
        self.v1 = self.v1.rotate_left(13);
        self.v1 ^= self.v0;
        self.v0 = self.v0.rotate_left(32);
        self.v2 = self.v2.wrapping_add(self.v3);
        self.v3 = self.v3.rotate_left(16);
        self.v3 ^= self.v2;
        self.v0 = self.v0.wrapping_add(self.v3);
        self.v3 = self.v3.rotate_left(21);
        self.v3 ^= self.v0;
        self.v2 = self.v2.wrapping_add(self.v1);
        self.v1 = self.v1.rotate_left(17);
        self.v1 ^= self.v2;
        self.v2 = self.v2.rotate_left(32);
    }

    fn process_block(self: &mut Self, m: u64) / pure {
        self.v3 ^= m;
        self.sipround();  // c rounds (SipHash-1-3 has c=1)
        self.v0 ^= m;
    }
}

impl Default for SipHasher {
    fn default() -> Self / pure {
        SipHasher::new()
    }
}

impl Hasher for SipHasher {
    fn finish(self: &Self) -> u64 / pure {
        let mut state = *self;

        // Pad remaining bytes
        let b = ((state.length & 0xff) as u64) << 56;
        let mut m = b;
        for i in 0..state.buf_len {
            m |= (state.buf[i] as u64) << (i * 8);
        }

        state.v3 ^= m;
        state.sipround();
        state.v0 ^= m;

        state.v2 ^= 0xff;

        // d rounds (SipHash-1-3 has d=3)
        state.sipround();
        state.sipround();
        state.sipround();

        state.v0 ^ state.v1 ^ state.v2 ^ state.v3
    }

    fn write(self: &mut Self, bytes: &[u8]) / pure {
        self.length += bytes.len();

        let mut i = 0;

        // Fill buffer if partially filled
        if self.buf_len > 0 {
            while i < bytes.len() && self.buf_len < 8 {
                self.buf[self.buf_len] = bytes[i];
                self.buf_len += 1;
                i += 1;
            }

            if self.buf_len == 8 {
                let m = u64::from_le_bytes(self.buf);
                self.process_block(m);
                self.buf_len = 0;
            }
        }

        // Process complete blocks
        while i + 8 <= bytes.len() {
            let m = u64::from_le_bytes([
                bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3],
                bytes[i + 4], bytes[i + 5], bytes[i + 6], bytes[i + 7],
            ]);
            self.process_block(m);
            i += 8;
        }

        // Save remaining bytes
        while i < bytes.len() {
            self.buf[self.buf_len] = bytes[i];
            self.buf_len += 1;
            i += 1;
        }
    }
}

impl Clone for SipHasher {
    fn clone(self: &Self) -> Self / pure { *self }
}

impl Copy for SipHasher {}

/// FxHash - a fast, non-cryptographic hash function
///
/// Very fast for small keys, suitable for hash tables where
/// cryptographic strength is not required.
pub struct FxHasher {
    hash: u64,
}

impl FxHasher {
    const K: u64 = 0x517cc1b727220a95;

    pub fn new() -> Self / pure {
        FxHasher { hash: 0 }
    }

    fn add_to_hash(self: &mut Self, value: u64) / pure {
        self.hash = self.hash.rotate_left(5).bitxor(value).wrapping_mul(Self::K);
    }
}

impl Default for FxHasher {
    fn default() -> Self / pure {
        FxHasher::new()
    }
}

impl Hasher for FxHasher {
    fn finish(self: &Self) -> u64 / pure {
        self.hash
    }

    fn write(self: &mut Self, bytes: &[u8]) / pure {
        let mut i = 0;

        // Process 8 bytes at a time
        while i + 8 <= bytes.len() {
            let value = u64::from_le_bytes([
                bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3],
                bytes[i + 4], bytes[i + 5], bytes[i + 6], bytes[i + 7],
            ]);
            self.add_to_hash(value);
            i += 8;
        }

        // Process 4 bytes
        if i + 4 <= bytes.len() {
            let value = u32::from_le_bytes([
                bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3],
            ]) as u64;
            self.add_to_hash(value);
            i += 4;
        }

        // Process 2 bytes
        if i + 2 <= bytes.len() {
            let value = u16::from_le_bytes([bytes[i], bytes[i + 1]]) as u64;
            self.add_to_hash(value);
            i += 2;
        }

        // Process remaining byte
        if i < bytes.len() {
            self.add_to_hash(bytes[i] as u64);
        }
    }

    fn write_u8(self: &mut Self, i: u8) / pure {
        self.add_to_hash(i as u64);
    }

    fn write_u16(self: &mut Self, i: u16) / pure {
        self.add_to_hash(i as u64);
    }

    fn write_u32(self: &mut Self, i: u32) / pure {
        self.add_to_hash(i as u64);
    }

    fn write_u64(self: &mut Self, i: u64) / pure {
        self.add_to_hash(i);
    }

    fn write_usize(self: &mut Self, i: usize) / pure {
        self.add_to_hash(i as u64);
    }
}

impl Clone for FxHasher {
    fn clone(self: &Self) -> Self / pure { *self }
}

impl Copy for FxHasher {}

/// BuildHasher for FxHash
pub struct FxBuildHasher;

impl BuildHasher for FxBuildHasher {
    type Hasher = FxHasher;

    fn build_hasher(self: &Self) -> FxHasher / pure {
        FxHasher::new()
    }
}

impl Default for FxBuildHasher {
    fn default() -> Self / pure {
        FxBuildHasher
    }
}

impl Clone for FxBuildHasher {
    fn clone(self: &Self) -> Self / pure { *self }
}

impl Copy for FxBuildHasher {}

// Hash implementations for primitives

impl Hash for bool {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u8(*self as u8);
    }
}

impl Hash for char {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u32(*self as u32);
    }
}

impl Hash for u8 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u8(*self);
    }
}

impl Hash for u16 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u16(*self);
    }
}

impl Hash for u32 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u32(*self);
    }
}

impl Hash for u64 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u64(*self);
    }
}

impl Hash for u128 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_u128(*self);
    }
}

impl Hash for usize {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_usize(*self);
    }
}

impl Hash for i8 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_i8(*self);
    }
}

impl Hash for i16 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_i16(*self);
    }
}

impl Hash for i32 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_i32(*self);
    }
}

impl Hash for i64 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_i64(*self);
    }
}

impl Hash for i128 {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_i128(*self);
    }
}

impl Hash for isize {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_isize(*self);
    }
}

impl Hash for str {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write(self.as_bytes());
        // Hash the length to avoid prefix collisions
        state.write_length_prefix(self.len());
    }
}

impl Hash for String {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        self.as_str().hash(state);
    }
}

impl<T: Hash> Hash for [T] {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        state.write_length_prefix(self.len());
        Hash::hash_slice(self, state);
    }
}

impl<T: Hash, const N: usize> Hash for [T; N] {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        Hash::hash_slice(&self[..], state);
    }
}

impl<T: Hash> Hash for Option<T> {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        match self {
            None => 0u8.hash(state),
            Some(x) => {
                1u8.hash(state);
                x.hash(state);
            }
        }
    }
}

impl<T: Hash, E: Hash> Hash for Result<T, E> {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        match self {
            Ok(x) => {
                0u8.hash(state);
                x.hash(state);
            }
            Err(e) => {
                1u8.hash(state);
                e.hash(state);
            }
        }
    }
}

// Hash for tuples

impl Hash for () {
    fn hash<H: Hasher>(self: &Self, _state: &mut H) / pure {}
}

impl<A: Hash> Hash for (A,) {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        self.0.hash(state);
    }
}

impl<A: Hash, B: Hash> Hash for (A, B) {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        self.0.hash(state);
        self.1.hash(state);
    }
}

impl<A: Hash, B: Hash, C: Hash> Hash for (A, B, C) {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
    }
}

impl<A: Hash, B: Hash, C: Hash, D: Hash> Hash for (A, B, C, D) {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        self.0.hash(state);
        self.1.hash(state);
        self.2.hash(state);
        self.3.hash(state);
    }
}

// Hash for references
impl<T: Hash + ?Sized> Hash for &T {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        (*self).hash(state);
    }
}

impl<T: Hash + ?Sized> Hash for &mut T {
    fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
        (*self).hash(state);
    }
}

/// Derive macro for Hash
#[derive(Hash)]
macro_rules! derive_hash {
    ($name:ident { $($field:ident),* }) => {
        impl Hash for $name {
            fn hash<H: Hasher>(self: &Self, state: &mut H) / pure {
                $(self.$field.hash(state);)*
            }
        }
    };
}
