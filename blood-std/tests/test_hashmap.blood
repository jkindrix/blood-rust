// Blood Standard Library Tests - HashMap<K, V>
//
// Comprehensive tests for the HashMap collection type.

use std::collections::HashMap;

// =============================================================================
// Construction Tests
// =============================================================================

/// Test HashMap::new() creates empty map
fn test_hashmap_new() {
    let map: HashMap<str, i32> = HashMap::new();
    assert(map.len() == 0, "new HashMap should be empty");
    assert(map.is_empty(), "new HashMap is_empty should be true");
}

/// Test HashMap::with_capacity() preallocates
fn test_hashmap_with_capacity() {
    let map: HashMap<str, i32> = HashMap::with_capacity(100);
    assert(map.len() == 0, "with_capacity should be empty");
    assert(map.is_empty(), "with_capacity is_empty should be true");
    assert(map.capacity() >= 100, "with_capacity should allocate");
}

// =============================================================================
// Insert/Get Tests
// =============================================================================

/// Test insert() adds entries
fn test_hashmap_insert() {
    let mut map: HashMap<str, i32> = HashMap::new();

    let old = map.insert("one", 1);
    assert(old == None, "insert on new key returns None");
    assert(map.len() == 1, "insert should increase len");

    let old2 = map.insert("two", 2);
    assert(old2 == None, "insert on new key returns None");
    assert(map.len() == 2, "insert should increase len");
}

/// Test insert() replaces existing
fn test_hashmap_insert_replace() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 1);

    let old = map.insert("key", 2);
    assert(old == Some(1), "insert on existing key returns old value");
    assert(map.len() == 1, "insert replace should not change len");
    assert(map.get(&"key") == Some(&2), "new value should be stored");
}

/// Test get() retrieves values
fn test_hashmap_get() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);
    map.insert("three", 3);

    assert(map.get(&"one") == Some(&1), "get existing key");
    assert(map.get(&"two") == Some(&2), "get existing key");
    assert(map.get(&"three") == Some(&3), "get existing key");
    assert(map.get(&"four") == None, "get missing key returns None");
}

/// Test get_mut() retrieves mutable reference
fn test_hashmap_get_mut() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 1);

    if let Some(value) = map.get_mut(&"key") {
        *value = 42;
    }

    assert(map.get(&"key") == Some(&42), "get_mut should allow mutation");
}

/// Test contains_key() checks membership
fn test_hashmap_contains_key() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("exists", 1);

    assert(map.contains_key(&"exists"), "contains_key on existing");
    assert(!map.contains_key(&"missing"), "contains_key on missing");
}

// =============================================================================
// Remove Tests
// =============================================================================

/// Test remove() removes and returns value
fn test_hashmap_remove() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 42);

    let removed = map.remove(&"key");
    assert(removed == Some(42), "remove should return value");
    assert(map.len() == 0, "remove should decrease len");
    assert(!map.contains_key(&"key"), "key should be gone");
}

/// Test remove() on missing key
fn test_hashmap_remove_missing() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 42);

    let removed = map.remove(&"missing");
    assert(removed == None, "remove missing key returns None");
    assert(map.len() == 1, "remove missing should not change len");
}

/// Test remove_entry() removes and returns key-value pair
fn test_hashmap_remove_entry() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 42);

    let entry = map.remove_entry(&"key");
    assert(entry == Some(("key", 42)), "remove_entry should return pair");
}

/// Test clear() removes all entries
fn test_hashmap_clear() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);
    map.insert("three", 3);

    map.clear();

    assert(map.is_empty(), "clear should empty map");
    assert(map.len() == 0, "clear should set len to 0");
}

// =============================================================================
// Entry API Tests
// =============================================================================

/// Test entry().or_insert() for missing key
fn test_hashmap_entry_or_insert() {
    let mut map: HashMap<str, i32> = HashMap::new();

    let value = map.entry("key").or_insert(42);
    assert(*value == 42, "or_insert should insert value");
    assert(map.len() == 1, "or_insert should increase len");
}

/// Test entry().or_insert() for existing key
fn test_hashmap_entry_or_insert_existing() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 1);

    let value = map.entry("key").or_insert(42);
    assert(*value == 1, "or_insert should return existing value");
    assert(map.len() == 1, "or_insert should not change len");
}

/// Test entry().or_insert_with() lazy initialization
fn test_hashmap_entry_or_insert_with() {
    let mut map: HashMap<str, i32> = HashMap::new();

    let value = map.entry("key").or_insert_with(|| 42);
    assert(*value == 42, "or_insert_with should compute value");
}

/// Test entry().or_default() uses Default trait
fn test_hashmap_entry_or_default() {
    let mut map: HashMap<str, i32> = HashMap::new();

    let value = map.entry("key").or_default();
    assert(*value == 0, "or_default should use Default::default()");
}

/// Test entry().and_modify() for existing key
fn test_hashmap_entry_and_modify() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 10);

    map.entry("key").and_modify(|v| *v = *v * 2);
    assert(map.get(&"key") == Some(&20), "and_modify should apply function");
}

/// Test chained entry operations
fn test_hashmap_entry_chain() {
    let mut map: HashMap<str, i32> = HashMap::new();

    // Insert default, then modify
    map.entry("counter")
        .or_insert(0)
        .and_modify(|v| *v = *v + 1);

    // This pattern is common for counting
    *map.entry("counter").or_insert(0) += 1;
    *map.entry("counter").or_insert(0) += 1;

    assert(map.get(&"counter") == Some(&2), "counter should be incremented");
}

/// Test try_insert() for conditional insertion
fn test_hashmap_try_insert() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("existing", 1);

    // Try to insert on new key - succeeds
    let result1 = map.try_insert("new", 2);
    assert(result1.is_ok(), "try_insert on new key should succeed");

    // Try to insert on existing key - fails
    let result2 = map.try_insert("existing", 99);
    assert(result2.is_err(), "try_insert on existing key should fail");
    assert(map.get(&"existing") == Some(&1), "existing value unchanged");
}

// =============================================================================
// Iteration Tests
// =============================================================================

/// Test keys() iterator
fn test_hashmap_keys() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);
    map.insert("three", 3);

    let mut keys: Vec<&str> = map.keys().collect();
    keys.sort();

    assert(keys.len() == 3, "keys should have 3 elements");
    assert(keys.contains(&&"one"), "keys should contain 'one'");
    assert(keys.contains(&&"two"), "keys should contain 'two'");
    assert(keys.contains(&&"three"), "keys should contain 'three'");
}

/// Test values() iterator
fn test_hashmap_values() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);
    map.insert("three", 3);

    let mut values: Vec<&i32> = map.values().collect();
    values.sort();

    assert(values == vec![&1, &2, &3], "values should be [1, 2, 3]");
}

/// Test values_mut() iterator
fn test_hashmap_values_mut() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);

    for v in map.values_mut() {
        *v = *v * 10;
    }

    assert(map.get(&"one") == Some(&10), "values_mut should allow mutation");
    assert(map.get(&"two") == Some(&20), "values_mut should allow mutation");
}

/// Test iter() over key-value pairs
fn test_hashmap_iter() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("a", 1);
    map.insert("b", 2);

    let mut count = 0;
    for (k, v) in map.iter() {
        count = count + 1;
        assert(map.get(k) == Some(v), "iter should yield valid pairs");
    }
    assert(count == 2, "iter should visit all entries");
}

/// Test into_iter() consumes map
fn test_hashmap_into_iter() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("key", 42);

    let pairs: Vec<(str, i32)> = map.into_iter().collect();
    assert(pairs.len() == 1, "into_iter should yield all entries");
}

/// Test drain() removes and returns all entries
fn test_hashmap_drain() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.insert("one", 1);
    map.insert("two", 2);

    let drained: Vec<(str, i32)> = map.drain().collect();

    assert(drained.len() == 2, "drain should yield all entries");
    assert(map.is_empty(), "drain should empty map");
}

// =============================================================================
// Capacity Tests
// =============================================================================

/// Test reserve() preallocates
fn test_hashmap_reserve() {
    let mut map: HashMap<str, i32> = HashMap::new();
    map.reserve(100);

    assert(map.capacity() >= 100, "reserve should allocate");
}

/// Test shrink_to_fit() reduces capacity
fn test_hashmap_shrink_to_fit() {
    let mut map: HashMap<str, i32> = HashMap::with_capacity(100);
    map.insert("one", 1);

    map.shrink_to_fit();

    assert(map.capacity() < 100, "shrink_to_fit should reduce");
    assert(map.get(&"one") == Some(&1), "elements preserved");
}

/// Test shrink_to() reduces to specific capacity
fn test_hashmap_shrink_to() {
    let mut map: HashMap<str, i32> = HashMap::with_capacity(100);
    map.insert("one", 1);
    map.insert("two", 2);

    map.shrink_to(10);

    assert(map.capacity() <= 16, "shrink_to should limit capacity");
    assert(map.len() == 2, "shrink_to should preserve elements");
}

// =============================================================================
// Integer Key Tests
// =============================================================================

/// Test with integer keys
fn test_hashmap_integer_keys() {
    let mut map: HashMap<i32, str> = HashMap::new();
    map.insert(1, "one");
    map.insert(2, "two");
    map.insert(100, "hundred");

    assert(map.get(&1) == Some(&"one"), "integer key lookup");
    assert(map.get(&2) == Some(&"two"), "integer key lookup");
    assert(map.get(&100) == Some(&"hundred"), "integer key lookup");
    assert(map.get(&3) == None, "missing integer key");
}

/// Test with negative integer keys
fn test_hashmap_negative_keys() {
    let mut map: HashMap<i32, i32> = HashMap::new();
    map.insert(-1, 1);
    map.insert(-100, 100);
    map.insert(0, 0);

    assert(map.get(&-1) == Some(&1), "negative key lookup");
    assert(map.get(&-100) == Some(&100), "negative key lookup");
    assert(map.get(&0) == Some(&0), "zero key lookup");
}

// =============================================================================
// Stress Tests
// =============================================================================

/// Test many insertions
fn test_hashmap_many_insertions() {
    let mut map: HashMap<i32, i32> = HashMap::new();

    // Insert 1000 entries
    let mut i = 0;
    while i < 1000 {
        map.insert(i, i * 2);
        i = i + 1;
    }

    assert(map.len() == 1000, "should have 1000 entries");

    // Verify all entries
    i = 0;
    while i < 1000 {
        assert(map.get(&i) == Some(&(i * 2)), "each entry should be retrievable");
        i = i + 1;
    }
}

/// Test insert and remove cycle
fn test_hashmap_insert_remove_cycle() {
    let mut map: HashMap<i32, i32> = HashMap::new();

    // Insert, remove, insert cycle
    let mut i = 0;
    while i < 100 {
        map.insert(i, i);
        i = i + 1;
    }
    assert(map.len() == 100, "should have 100 entries");

    i = 0;
    while i < 50 {
        map.remove(&i);
        i = i + 1;
    }
    assert(map.len() == 50, "should have 50 entries");

    i = 0;
    while i < 50 {
        map.insert(i, i * 10);
        i = i + 1;
    }
    assert(map.len() == 100, "should have 100 entries again");

    // Verify new values
    assert(map.get(&0) == Some(&0), "reinserted value");
    assert(map.get(&49) == Some(&490), "reinserted value");
    assert(map.get(&50) == Some(&50), "original value");
}

// =============================================================================
// Clone and Equality Tests
// =============================================================================

/// Test Clone trait
fn test_hashmap_clone() {
    let mut map1: HashMap<str, i32> = HashMap::new();
    map1.insert("one", 1);
    map1.insert("two", 2);

    let map2 = map1.clone();

    assert(map1.len() == map2.len(), "clone should have same len");
    assert(map1.get(&"one") == map2.get(&"one"), "clone should have same entries");
    assert(map1.get(&"two") == map2.get(&"two"), "clone should have same entries");
}

/// Test PartialEq trait
fn test_hashmap_equality() {
    let mut map1: HashMap<str, i32> = HashMap::new();
    map1.insert("one", 1);
    map1.insert("two", 2);

    let mut map2: HashMap<str, i32> = HashMap::new();
    map2.insert("one", 1);
    map2.insert("two", 2);

    let mut map3: HashMap<str, i32> = HashMap::new();
    map3.insert("one", 1);
    map3.insert("two", 99);

    assert(map1 == map2, "equal maps should be equal");
    assert(map1 != map3, "different values should not be equal");
}

// =============================================================================
// Main Test Runner
// =============================================================================

fn main() {
    println_str("Running HashMap<K, V> tests...");
    println_str("");

    // Construction
    test_hashmap_new();
    test_hashmap_with_capacity();
    println_str("[PASS] Construction tests");

    // Insert/Get
    test_hashmap_insert();
    test_hashmap_insert_replace();
    test_hashmap_get();
    test_hashmap_get_mut();
    test_hashmap_contains_key();
    println_str("[PASS] Insert/Get tests");

    // Remove
    test_hashmap_remove();
    test_hashmap_remove_missing();
    test_hashmap_remove_entry();
    test_hashmap_clear();
    println_str("[PASS] Remove tests");

    // Entry API
    test_hashmap_entry_or_insert();
    test_hashmap_entry_or_insert_existing();
    test_hashmap_entry_or_insert_with();
    test_hashmap_entry_or_default();
    test_hashmap_entry_and_modify();
    test_hashmap_entry_chain();
    test_hashmap_try_insert();
    println_str("[PASS] Entry API tests");

    // Iteration
    test_hashmap_keys();
    test_hashmap_values();
    test_hashmap_values_mut();
    test_hashmap_iter();
    test_hashmap_into_iter();
    test_hashmap_drain();
    println_str("[PASS] Iteration tests");

    // Capacity
    test_hashmap_reserve();
    test_hashmap_shrink_to_fit();
    test_hashmap_shrink_to();
    println_str("[PASS] Capacity tests");

    // Integer keys
    test_hashmap_integer_keys();
    test_hashmap_negative_keys();
    println_str("[PASS] Integer key tests");

    // Stress tests
    test_hashmap_many_insertions();
    test_hashmap_insert_remove_cycle();
    println_str("[PASS] Stress tests");

    // Clone/Equality
    test_hashmap_clone();
    test_hashmap_equality();
    println_str("[PASS] Clone/Equality tests");

    println_str("");
    println_str("All HashMap<K, V> tests passed!");
}
