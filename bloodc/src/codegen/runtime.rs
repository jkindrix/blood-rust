//! Runtime support for Blood programs.
//!
//! This module provides declarations and stubs for runtime functions
//! that Blood programs can call.
//!
//! ## Runtime Linking
//!
//! Compiled Blood programs must be linked with the Blood runtime library:
//!
//! - **Rust runtime** (`blood-runtime`): Full-featured runtime with fibers,
//!   channels, and effects support. Build with `cargo build --release` and
//!   link with `-lblood_runtime`.
//!
//! - **C runtime** (fallback): Minimal C runtime for simple programs without
//!   advanced features. Generated by `generate_c_runtime()`.
//!
//! ## Available Functions
//!
//! ### I/O
//! - `print_int`, `println_int` - Integer output
//! - `print_str`, `println_str` - String output
//!
//! ### Memory (Generational References)
//! - `blood_alloc` - Allocate with generation tracking
//! - `blood_free` - Free allocated memory
//! - `blood_check_generation` - Validate reference freshness
//! - `blood_stale_reference_panic` - Handle stale reference errors
//!
//! ### Effects
//! - `blood_evidence_create/destroy/push/pop/get` - Evidence vectors
//! - `blood_fiber_create/suspend/resume` - Continuation support
//!
//! ### Runtime Lifecycle
//! - `blood_runtime_init` - Initialize runtime
//! - `blood_runtime_shutdown` - Cleanup runtime

/// Runtime function names.
pub mod functions {
    // === I/O Functions ===

    /// Print an integer (no newline).
    pub const PRINT_INT: &str = "print_int";

    /// Print an integer with newline.
    pub const PRINTLN_INT: &str = "println_int";

    /// Print a 64-bit integer with newline.
    pub const PRINTLN_I64: &str = "println_i64";

    /// Print a string (no newline).
    pub const PRINT_STR: &str = "print_str";

    /// Print a string with newline.
    pub const PRINTLN_STR: &str = "println_str";

    // === Memory Management ===

    /// Allocate memory with generational reference.
    pub const ALLOC: &str = "blood_alloc";

    /// Free memory.
    pub const FREE: &str = "blood_free";

    /// Check if a generational reference is valid.
    pub const CHECK_GENERATION: &str = "blood_check_generation";

    /// Called on stale reference access.
    pub const STALE_REFERENCE_PANIC: &str = "blood_stale_reference_panic";

    // === Effect Runtime ===

    /// Create evidence vector.
    pub const EVIDENCE_CREATE: &str = "blood_evidence_create";

    /// Destroy evidence vector.
    pub const EVIDENCE_DESTROY: &str = "blood_evidence_destroy";

    /// Push handler onto evidence vector.
    pub const EVIDENCE_PUSH: &str = "blood_evidence_push";

    /// Pop handler from evidence vector.
    pub const EVIDENCE_POP: &str = "blood_evidence_pop";

    /// Get handler from evidence vector.
    pub const EVIDENCE_GET: &str = "blood_evidence_get";

    // === Fiber/Continuation Support ===

    /// Create a new fiber.
    pub const FIBER_CREATE: &str = "blood_fiber_create";

    /// Suspend current fiber.
    pub const FIBER_SUSPEND: &str = "blood_fiber_suspend";

    /// Resume a suspended fiber.
    pub const FIBER_RESUME: &str = "blood_fiber_resume";

    // === Runtime Lifecycle ===

    /// Initialize runtime.
    pub const RUNTIME_INIT: &str = "blood_runtime_init";

    /// Shutdown runtime.
    pub const RUNTIME_SHUTDOWN: &str = "blood_runtime_shutdown";

    /// Panic handler.
    pub const PANIC: &str = "blood_panic";
}

/// Generate a minimal C runtime source.
///
/// This can be compiled with `cc -c runtime.c -o runtime.o` and linked
/// with Blood programs.
///
/// For full runtime features (fibers, channels, effects), use the Rust
/// `blood-runtime` crate instead.
pub fn generate_c_runtime() -> String {
    r#"// Blood Runtime Library - Minimal C Implementation
// Compile with: cc -c runtime.c -o runtime.o
//
// For full runtime features, use the Rust blood-runtime crate:
//   cargo build --release -p blood-runtime
//   Link with: -lblood_runtime

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

// ============================================================================
// I/O Functions
// ============================================================================

void print_int(int32_t n) {
    printf("%d", n);
    fflush(stdout);
}

void println_int(int32_t n) {
    printf("%d\n", n);
}

void println_i64(int64_t n) {
    printf("%ld\n", n);
}

void print_str(const char* s) {
    if (s) printf("%s", s);
    fflush(stdout);
}

void println_str(const char* s) {
    if (s) printf("%s\n", s);
}

// ============================================================================
// Memory Management (Simple - no generational tracking)
// ============================================================================

int blood_alloc(size_t size, uint64_t* out_addr, uint64_t* out_gen_meta) {
    if (!out_addr || !out_gen_meta) return -1;
    void* ptr = malloc(size);
    if (!ptr) return -3;
    *out_addr = (uint64_t)ptr;
    *out_gen_meta = ((uint64_t)1 << 32) | 2; // gen=1, metadata=REGION
    return 0;
}

void blood_free(uint64_t addr, size_t size) {
    (void)size; // unused in simple implementation
    if (addr) free((void*)addr);
}

int blood_check_generation(uint32_t expected, uint32_t actual) {
    if (expected == UINT32_MAX) return 1; // PERSISTENT always valid
    return expected == actual ? 1 : 0;
}

uint32_t blood_get_generation(uint64_t addr) {
    (void)addr;
    return 1; // Simple: always return first generation
}

// ============================================================================
// Effect Runtime (Stubs)
// ============================================================================

void* blood_evidence_create(void) {
    return malloc(sizeof(uint64_t) * 16);
}

void blood_evidence_destroy(void* ev) {
    free(ev);
}

void blood_evidence_push(void* ev, uint64_t handler) {
    (void)ev; (void)handler; // Stub
}

uint64_t blood_evidence_pop(void* ev) {
    (void)ev;
    return 0; // Stub
}

uint64_t blood_evidence_get(void* ev, size_t index) {
    (void)ev; (void)index;
    return 0; // Stub
}

// ============================================================================
// Fiber Support (Stubs - not supported in minimal runtime)
// ============================================================================

uint64_t blood_fiber_create(void) {
    static uint64_t next_id = 1;
    return next_id++;
}

uint64_t blood_fiber_suspend(void) {
    return 0;
}

void blood_fiber_resume(uint64_t fiber, uint64_t value) {
    (void)fiber; (void)value;
}

// ============================================================================
// Error Handling
// ============================================================================

void blood_stale_reference_panic(uint32_t expected, uint32_t actual) {
    fprintf(stderr, "BLOOD RUNTIME ERROR: Stale reference detected!\n");
    fprintf(stderr, "Expected generation: %u, Actual: %u\n", expected, actual);
    fprintf(stderr, "This indicates use-after-free. Aborting.\n");
    abort();
}

void blood_panic(const char* msg) {
    fprintf(stderr, "BLOOD RUNTIME PANIC: %s\n", msg ? msg : "unknown error");
    abort();
}

// ============================================================================
// Runtime Lifecycle
// ============================================================================

int blood_runtime_init(void) {
    return 0;
}

void blood_runtime_shutdown(void) {
    // Nothing to do in minimal runtime
}
"#.to_string()
}
