// Test builtin methods for Option, Result, Vec, String, str, Slice
// Focus on methods that should work with current implementation

// === Result methods (simple predicates) ===
fn test_result_is_ok(r: Result<i32, String>) -> bool {
    r.is_ok()
}

fn test_result_is_err(r: Result<i32, String>) -> bool {
    r.is_err()
}

// === Option methods (simple predicates) ===
fn test_option_is_some(opt: Option<i32>) -> bool {
    opt.is_some()
}

fn test_option_is_none(opt: Option<i32>) -> bool {
    opt.is_none()
}

// === Vec methods (simple ones without elem pass-by-pointer) ===
fn test_vec_len(v: &Vec<i32>) -> usize {
    v.len()
}

fn test_vec_is_empty(v: &Vec<i32>) -> bool {
    v.is_empty()
}

fn test_vec_capacity(v: &Vec<i32>) -> usize {
    v.capacity()
}

fn test_vec_clear(v: &mut Vec<i32>) {
    v.clear();
}

fn test_vec_push(v: &mut Vec<i32>, val: i32) {
    v.push(val);
}

fn test_vec_reverse(v: &mut Vec<i32>) {
    v.reverse();
}

fn test_vec_pop(v: &mut Vec<i32>) -> Option<i32> {
    v.pop()
}

fn test_vec_contains(v: &Vec<i32>, val: &i32) -> bool {
    v.contains(val)
}

// Vec methods returning Option<&T>
fn test_vec_get(v: &Vec<i32>, i: usize) -> Option<&i32> {
    v.get(i)
}

fn test_vec_first(v: &Vec<i32>) -> Option<&i32> {
    v.first()
}

fn test_vec_last(v: &Vec<i32>) -> Option<&i32> {
    v.last()
}

// === String methods ===
fn test_string_len(s: &String) -> usize {
    s.len()
}

fn test_string_is_empty(s: &String) -> bool {
    s.is_empty()
}

fn test_string_contains(s: &String, pattern: &str) -> bool {
    s.contains(pattern)
}

fn test_string_starts_with(s: &String, pattern: &str) -> bool {
    s.starts_with(pattern)
}

fn test_string_ends_with(s: &String, pattern: &str) -> bool {
    s.ends_with(pattern)
}

fn test_string_trim(s: &String) -> &str {
    s.trim()
}

fn test_string_to_uppercase(s: &String) -> String {
    s.to_uppercase()
}

fn test_string_to_lowercase(s: &String) -> String {
    s.to_lowercase()
}

// === str methods ===
fn test_str_len(s: &str) -> usize {
    s.len()
}

fn test_str_is_empty(s: &str) -> bool {
    s.is_empty()
}

fn test_str_contains(s: &str, pattern: &str) -> bool {
    s.contains(pattern)
}

fn test_str_starts_with(s: &str, pattern: &str) -> bool {
    s.starts_with(pattern)
}

fn test_str_ends_with(s: &str, pattern: &str) -> bool {
    s.ends_with(pattern)
}

fn test_str_trim(s: &str) -> &str {
    s.trim()
}

fn test_str_to_uppercase(s: &str) -> String {
    s.to_uppercase()
}

fn test_str_to_lowercase(s: &str) -> String {
    s.to_lowercase()
}

// === Slice methods ===
fn test_slice_len(s: &[i32]) -> usize {
    s.len()
}

fn test_slice_is_empty(s: &[i32]) -> bool {
    s.is_empty()
}

fn test_slice_first(s: &[i32]) -> Option<&i32> {
    s.first()
}

fn test_slice_last(s: &[i32]) -> Option<&i32> {
    s.last()
}

fn test_slice_get(s: &[i32], i: usize) -> Option<&i32> {
    s.get(i)
}

fn test_slice_contains(s: &[i32], val: &i32) -> bool {
    s.contains(val)
}

fn test_slice_get_mut(s: &mut [i32], i: usize) -> Option<&mut i32> {
    s.get_mut(i)
}

fn test_slice_starts_with(s: &[i32], needle: &[i32]) -> bool {
    s.starts_with(needle)
}

fn test_slice_ends_with(s: &[i32], needle: &[i32]) -> bool {
    s.ends_with(needle)
}

fn test_slice_reverse(s: &mut [i32]) {
    s.reverse();
}

// === Box methods ===
fn test_box_new(val: i32) -> Box<i32> {
    Box::new(val)
}

fn main() {
    // Test that all methods type-check and compile correctly
    let b = Box::new(42);
}
