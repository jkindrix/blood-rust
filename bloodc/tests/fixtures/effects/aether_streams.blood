// =============================================================================
// Aether Stream Processing Test Suite
// =============================================================================
//
// Comprehensive tests for Blood's algebraic effect system, validated against
// the Aether reactive stream processing library patterns.
//
// These tests verify:
// - Basic Emit<T> effects
// - Struct/enum values through effects
// - Match on enum fields in handlers
// - Array/struct field assignment in handlers
// - Nested effect handlers (5+ levels)
// - Stateful accumulation in handlers
// - Effect-annotated closures
//
// All tests use division-by-zero as assertion failure mechanism.

effect Emit<T> {
    op emit(value: T) -> ();
}

// ============================================================================
// Test utilities
// ============================================================================

fn assert_eq_i32(actual: i32, expected: i32, test_name: i32) {
    if actual != expected {
        // test_name encodes which test failed
        let zero: i32 = actual - actual;
        let x: i32 = 1 / zero;  // Crash with identifiable test_name
    }
}

// ============================================================================
// Basic stream operations
// ============================================================================

fn range(start: i32, end: i32) / {Emit<i32>} {
    let mut i: i32 = start;
    while i < end {
        perform Emit.emit(i);
        i = i + 1;
    }
}

fn collect_sum(stream: fn() / {Emit<i32>}) -> i32 {
    let mut sum: i32 = 0;
    try { stream(); }
    with {
        Emit.emit(v) => {
            sum = sum + v;
            resume(());
        }
    };
    sum
}

fn collect_count(stream: fn() / {Emit<i32>}) -> i32 {
    let mut count: i32 = 0;
    try { stream(); }
    with {
        Emit.emit(v) => {
            count = count + 1;
            resume(());
        }
    };
    count
}

fn collect_to_array(stream: fn() / {Emit<i32>}) -> [i32; 16] {
    let mut arr: [i32; 16] = [0; 16];
    let mut idx: i32 = 0;
    try { stream(); }
    with {
        Emit.emit(v) => {
            if idx < 16 {
                arr[idx] = v;
                idx = idx + 1;
            }
            resume(());
        }
    };
    arr
}

// ============================================================================
// Stream transformers
// ============================================================================

fn map_double(stream: fn() / {Emit<i32>}) / {Emit<i32>} {
    try { stream(); }
    with {
        Emit.emit(v) => {
            perform Emit.emit(v * 2);
            resume(());
        }
    };
}

fn filter_even(stream: fn() / {Emit<i32>}) / {Emit<i32>} {
    try { stream(); }
    with {
        Emit.emit(v) => {
            if v % 2 == 0 {
                perform Emit.emit(v);
            }
            resume(());
        }
    };
}

fn take(stream: fn() / {Emit<i32>}, n: i32) / {Emit<i32>} {
    let mut count: i32 = 0;
    try { stream(); }
    with {
        Emit.emit(v) => {
            if count < n {
                perform Emit.emit(v);
                count = count + 1;
            }
            resume(());
        }
    };
}

fn skip(stream: fn() / {Emit<i32>}, n: i32) / {Emit<i32>} {
    let mut count: i32 = 0;
    try { stream(); }
    with {
        Emit.emit(v) => {
            if count >= n {
                perform Emit.emit(v);
            }
            count = count + 1;
            resume(());
        }
    };
}

// ============================================================================
// Tests
// ============================================================================

fn test_range_sum() -> i32 {
    // sum(1..11) = 1+2+3+4+5+6+7+8+9+10 = 55
    let result: i32 = collect_sum(|| / {Emit<i32>} { range(1, 11); });
    assert_eq_i32(result, 55, 1);
    0
}

fn test_range_count() -> i32 {
    // count(1..11) = 10
    let result: i32 = collect_count(|| / {Emit<i32>} { range(1, 11); });
    assert_eq_i32(result, 10, 2);
    0
}

fn test_map_double() -> i32 {
    // sum(double(1..6)) = 2+4+6+8+10 = 30
    let result: i32 = collect_sum(|| / {Emit<i32>} {
        map_double(|| / {Emit<i32>} { range(1, 6); });
    });
    assert_eq_i32(result, 30, 3);
    0
}

fn test_filter_even() -> i32 {
    // sum(filter_even(1..11)) = 2+4+6+8+10 = 30
    let result: i32 = collect_sum(|| / {Emit<i32>} {
        filter_even(|| / {Emit<i32>} { range(1, 11); });
    });
    assert_eq_i32(result, 30, 4);
    0
}

fn test_take() -> i32 {
    // sum(take(1..100, 5)) = 1+2+3+4+5 = 15
    let result: i32 = collect_sum(|| / {Emit<i32>} {
        take(|| / {Emit<i32>} { range(1, 100); }, 5);
    });
    assert_eq_i32(result, 15, 5);
    0
}

fn test_skip() -> i32 {
    // sum(skip(1..11, 7)) = 8+9+10 = 27
    let result: i32 = collect_sum(|| / {Emit<i32>} {
        skip(|| / {Emit<i32>} { range(1, 11); }, 7);
    });
    assert_eq_i32(result, 27, 6);
    0
}

fn test_chained_operations() -> i32 {
    // take(3, filter_even(map_double(1..10)))
    // map_double(1..10) = 2,4,6,8,10,12,14,16,18
    // filter_even = all of them (already even)
    // take(3) = 2,4,6
    // sum = 12
    let result: i32 = collect_sum(|| / {Emit<i32>} {
        take(|| / {Emit<i32>} {
            filter_even(|| / {Emit<i32>} {
                map_double(|| / {Emit<i32>} { range(1, 10); });
            });
        }, 3);
    });
    assert_eq_i32(result, 12, 7);
    0
}

fn test_empty_stream() -> i32 {
    // sum of empty stream = 0
    let result: i32 = collect_sum(|| / {Emit<i32>} { range(5, 5); });
    assert_eq_i32(result, 0, 8);
    0
}

fn test_single_element() -> i32 {
    // sum(42..43) = 42
    let result: i32 = collect_sum(|| / {Emit<i32>} { range(42, 43); });
    assert_eq_i32(result, 42, 9);
    0
}

fn test_collect_array() -> i32 {
    // collect first 5 elements into array
    let arr: [i32; 16] = collect_to_array(|| / {Emit<i32>} { range(10, 15); });
    assert_eq_i32(arr[0], 10, 10);
    assert_eq_i32(arr[1], 11, 11);
    assert_eq_i32(arr[2], 12, 12);
    assert_eq_i32(arr[3], 13, 13);
    assert_eq_i32(arr[4], 14, 14);
    0
}

fn test_nested_handlers() -> i32 {
    // Deeply nested: skip(2, take(5, filter_even(map_double(1..20))))
    // map_double(1..20) = 2,4,6,...,38
    // filter_even = same (all even)
    // take(5) = 2,4,6,8,10
    // skip(2) = 6,8,10
    // sum = 24
    let result: i32 = collect_sum(|| / {Emit<i32>} {
        skip(|| / {Emit<i32>} {
            take(|| / {Emit<i32>} {
                filter_even(|| / {Emit<i32>} {
                    map_double(|| / {Emit<i32>} { range(1, 20); });
                });
            }, 5);
        }, 2);
    });
    assert_eq_i32(result, 24, 12);
    0
}

// ============================================================================
// Main: Run all tests
// ============================================================================

fn main() {
    test_range_sum();
    test_range_count();
    test_map_double();
    test_filter_even();
    test_take();
    test_skip();
    test_chained_operations();
    test_empty_stream();
    test_single_element();
    test_collect_array();
    test_nested_handlers();

    // If we get here, all tests passed
}
