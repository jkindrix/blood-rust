// =============================================================================
// Snapshot Effect Resume Test
// =============================================================================
//
// Validates that struct data maintains integrity across multiple effect handler
// suspend/resume cycles with nested handlers. This indirectly exercises the
// generation snapshot mechanism: when an effect handler suspends and resumes,
// the runtime must correctly preserve all captured state including struct
// field values. Any corruption in snapshot capture/restore would manifest as
// incorrect field values after resume.
//
// Tests:
// 1. Struct fields survive single suspend/resume in deep handler
// 2. Struct fields survive multiple suspend/resume cycles
// 3. Struct data integrity through nested (2-level) handlers
// 4. Accumulated struct state across interleaved effect operations
// 5. Struct data round-trip through 3-level nested handlers

effect Counter {
    op inc() -> i32;
}

effect Accumulator {
    op add(x: i32) -> i32;
}

effect Logger {
    op log(x: i32) -> ();
}

struct Pair {
    a: i32,
    b: i32,
}

struct Triple {
    x: i32,
    y: i32,
    z: i32,
}

fn assert_eq(actual: i32, expected: i32) {
    if actual != expected {
        let zero: i32 = 0;
        let crash: i32 = 1 / zero;
    }
}

deep handler SimpleCounter for Counter {
    let mut count: i32
    return(x) { x }
    op inc() {
        count = count + 1;
        resume(count)
    }
}

deep handler BasicAccumulator for Accumulator {
    let mut total: i32
    return(x) { x }
    op add(x) {
        total = total + x;
        resume(total)
    }
}

deep handler BasicLogger for Logger {
    let mut log_count: i32
    return(x) { x }
    op log(x) {
        log_count = log_count + 1;
        resume(())
    }
}

fn main() {
    // ========================================================================
    // Test 1: Struct fields survive single suspend/resume in deep handler
    // ========================================================================
    let p1: Pair = Pair { a: 10, b: 20 };

    let r1: i32 = with SimpleCounter { count: 0 } handle {
        let c: i32 = perform Counter.inc();
        p1.a + p1.b + c
    };
    // 10 + 20 + 1 = 31
    assert_eq(r1, 31);

    // ========================================================================
    // Test 2: Struct fields survive multiple suspend/resume cycles
    // ========================================================================
    let p2: Pair = Pair { a: 5, b: 7 };

    let r2: i32 = with SimpleCounter { count: 0 } handle {
        let c1: i32 = perform Counter.inc();  // -> 1
        let c2: i32 = perform Counter.inc();  // -> 2
        let c3: i32 = perform Counter.inc();  // -> 3
        p2.a + p2.b + c1 + c2 + c3
    };
    // 5 + 7 + 1 + 2 + 3 = 18
    assert_eq(r2, 18);

    // ========================================================================
    // Test 3: Struct data integrity through nested (2-level) handlers
    // ========================================================================
    let t: Triple = Triple { x: 10, y: 20, z: 30 };

    let r3: i32 = with SimpleCounter { count: 0 } handle {
        with BasicAccumulator { total: 0 } handle {
            let c1: i32 = perform Counter.inc();        // counter -> 1
            let a1: i32 = perform Accumulator.add(c1);   // accum -> 1
            let c2: i32 = perform Counter.inc();        // counter -> 2
            let a2: i32 = perform Accumulator.add(c2);   // accum -> 3
            // Struct fields must survive all 4 suspend/resume cycles
            // across 2 different handler levels
            t.x + t.y + t.z + a2
        }
    };
    // 10 + 20 + 30 + 3 = 63
    assert_eq(r3, 63);

    // ========================================================================
    // Test 4: Accumulated struct state across interleaved operations
    // ========================================================================
    let mut p4: Pair = Pair { a: 0, b: 0 };

    with SimpleCounter { count: 0 } handle {
        let c1: i32 = perform Counter.inc();  // -> 1
        p4.a = p4.a + c1;
        let c2: i32 = perform Counter.inc();  // -> 2
        p4.b = p4.b + c2;
        let c3: i32 = perform Counter.inc();  // -> 3
        p4.a = p4.a + c3;
        let c4: i32 = perform Counter.inc();  // -> 4
        p4.b = p4.b + c4;
        0
    };
    // p4.a = 0 + 1 + 3 = 4, p4.b = 0 + 2 + 4 = 6
    assert_eq(p4.a, 4);
    assert_eq(p4.b, 6);

    // ========================================================================
    // Test 5: Struct data round-trip through 3-level nested handlers
    // ========================================================================
    let p5: Pair = Pair { a: 3, b: 7 };

    let r5: i32 = with SimpleCounter { count: 0 } handle {
        with BasicAccumulator { total: 0 } handle {
            with BasicLogger { log_count: 0 } handle {
                perform Logger.log(p5.a);
                let c1: i32 = perform Counter.inc();        // counter -> 1
                let a1: i32 = perform Accumulator.add(p5.a); // accum -> 3
                perform Logger.log(p5.b);
                let c2: i32 = perform Counter.inc();        // counter -> 2
                let a2: i32 = perform Accumulator.add(p5.b); // accum -> 10
                // After 6 suspend/resume cycles across 3 handler levels
                p5.a + p5.b + c1 + c2 + a2
            }
        }
    };
    // 3 + 7 + 1 + 2 + 10 = 23
    assert_eq(r5, 23);

    // If we get here, all 5 tests passed
}
