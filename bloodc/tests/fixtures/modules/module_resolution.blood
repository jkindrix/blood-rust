// Module resolution test: imports types, functions, constants from helper module.
mod helper;

// Test module-qualified struct in type annotation
fn test_struct_type_annotation() -> helper::Data {
    helper::Data { value: 42 }
}

// Test module-qualified struct literal
fn test_struct_literal() -> helper::Point {
    helper::Point { x: 10, y: 20 }
}

// Test module-qualified enum unit variant
fn test_enum_unit() -> helper::Kind {
    helper::Kind::A
}

// Test module-qualified enum tuple variant
fn test_enum_tuple() -> helper::Kind {
    helper::Kind::B(42)
}

// Test module-qualified struct variant enum construction
fn test_enum_struct() -> helper::Kind {
    helper::Kind::C { x: 1, y: 2 }
}

// Test module-qualified type alias
fn test_type_alias() -> helper::MyInt {
    100
}

// Test module-qualified constant
fn test_const() -> i32 {
    helper::MAX_VALUE
}

// Test module-qualified function
fn test_function() -> i32 {
    helper::get_value()
}

// Test module-qualified associated function
fn test_associated_fn() -> helper::Point {
    helper::Point::new(5, 10)
}

// Test module-qualified associated function (no args)
fn test_associated_fn_no_args() -> helper::Point {
    helper::Point::origin()
}

fn main() {
    let _ = test_struct_type_annotation();
    let _ = test_struct_literal();
    let _ = test_enum_unit();
    let _ = test_enum_tuple();
    let _ = test_enum_struct();
    let _ = test_type_alias();
    let _ = test_const();
    let _ = test_function();
    let _ = test_associated_fn();
    let _ = test_associated_fn_no_args();
}
