// Test multiple trait bounds - failure case

trait Counter {
    fn count(&self) -> i32;
}

trait Doubler {
    fn double(&self) -> i32;
}

// Only implement Counter for i32, NOT Doubler
impl Counter for i32 {
    fn count(&self) -> i32 {
        *self
    }
}

// Function with multiple bounds - T must implement both Counter and Doubler
fn count_and_double<T: Counter + Doubler>(val: &T) -> i32 {
    val.count() + val.double()
}

fn main() {
    // This should FAIL - i32 only implements Counter, not Doubler
    let x: i32 = 10;
    let result = count_and_double(&x);  // ERROR: i32 doesn't implement Doubler
    println!("{}", result);
}
