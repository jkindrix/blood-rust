// Regression test for BUG-005: Mutations through &mut field_of_ref silently lost.
//
// User-written `&mut data.inner` was parsed as UnaryOp::RefMut and lowered via
// lower_expr (rvalue path), which copied the field value into a temporary.
// The reference then pointed to the copy, so mutations were lost on return.
//
// The fix makes lower_unary use lower_place for Ref/RefMut operands, obtaining
// the original memory location without copying.

struct Inner {
    pub value: i32,
}

struct Outer {
    pub inner: Inner,
}

fn set_value(target: &mut Inner, val: i32) {
    target.value = val;
}

fn main() -> i32 {
    let mut data = Outer { inner: Inner { value: 0 } };

    // Case: &mut local_struct.field â€” must mutate the original
    set_value(&mut data.inner, 42);

    // If fix works: data.inner.value == 42, return 0 (success)
    // If broken:    data.inner.value == 0,  return 1 (failure)
    if data.inner.value == 42 {
        return 0;
    }
    return 1;
}
