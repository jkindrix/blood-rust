// Test Option<T> and Result<T, E> methods

// === Option methods that return Option<T> (same type) ===

fn test_option_or(a: Option<i32>, b: Option<i32>) -> Option<i32> {
    a.or(b)
}

fn test_option_xor(a: Option<i32>, b: Option<i32>) -> Option<i32> {
    a.xor(b)
}

fn test_option_take(opt: &mut Option<i32>) -> Option<i32> {
    opt.take()
}

fn test_option_replace(opt: &mut Option<i32>, val: i32) -> Option<i32> {
    opt.replace(val)
}

// === Option methods that return Option<&T> or Option<&mut T> ===

fn test_option_as_ref(opt: &Option<i32>) -> Option<&i32> {
    opt.as_ref()
}

fn test_option_as_mut(opt: &mut Option<i32>) -> Option<&mut i32> {
    opt.as_mut()
}

// === Result methods ===

fn test_result_or(a: Result<i32, String>, b: Result<i32, String>) -> Result<i32, String> {
    a.or(b)
}

fn test_result_as_ref(res: &Result<i32, String>) -> Result<&i32, &String> {
    res.as_ref()
}

fn test_result_as_mut(res: &mut Result<i32, String>) -> Result<&mut i32, &mut String> {
    res.as_mut()
}

// === Result methods that return T or E ===

fn test_result_expect(res: Result<i32, String>, msg: &str) -> i32 {
    res.expect(msg)
}

fn test_result_expect_err(res: Result<i32, String>, msg: &str) -> String {
    res.expect_err(msg)
}

fn test_result_unwrap_or(res: Result<i32, String>, default: i32) -> i32 {
    res.unwrap_or(default)
}

fn test_result_ok(res: Result<i32, String>) -> Option<i32> {
    res.ok()
}

fn test_result_err(res: Result<i32, String>) -> Option<String> {
    res.err()
}

fn main() {
    let opt: Option<i32> = Some(42);
}
