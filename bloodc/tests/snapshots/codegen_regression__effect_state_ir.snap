---
source: bloodc/tests/codegen_regression.rs
expression: ir
---
; ModuleID = 'blood_program'

@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 65535, void ()* @__blood_register_handlers, i8* null }]

declare double @parse_f64({ i8*, i64 })

declare double @ptr_read_f64(i64)

declare i1 @file_append_string({ i8*, i64 }, { i8*, i64 })

declare i1 @file_delete({ i8*, i64 })

declare i1 @file_exists({ i8*, i64 })

declare i1 @file_write_string({ i8*, i64 }, { i8*, i64 })

declare i1 @str_eq({ i8*, i64 }, { i8*, i64 })

declare i32 @args_count()

declare i32 @blood_alloc(i64, i64*, i64*)

declare i32 @blood_check_generation(i32, i32)

declare i32 @blood_get_generation(i64)

declare i32 @blood_region_exit_scope(i64)

declare i32 @blood_region_is_pending_deallocation(i64)

declare i32 @blood_region_is_suspended(i64)

declare i32 @blood_region_resume(i64)

declare i32 @blood_region_suspend(i64)

declare i32 @blood_register_allocation(i64, i64)

declare i32 @blood_runtime_init()

declare i32 @blood_scheduler_init(i64)

declare i32 @blood_scheduler_is_running()

declare i32 @blood_scheduler_run_background()

declare i32 @blood_validate_generation(i64, i32)

declare i32 @char_from_u32(i32)

declare i32 @i64_to_i32(i64)

declare i32 @option_is_none(i8*)

declare i32 @option_is_some(i8*)

declare i32 @option_try(i8*, i64, i8*)

declare i32 @ptr_read_i32(i64)

declare i32 @read_int()

declare i32 @result_is_err(i8*)

declare i32 @result_is_ok(i8*)

declare i32 @result_try(i8*, i64, i8*)

declare i32 @string_contains({ i8*, i64 }*, { i8*, i64 }*)

declare i32 @string_ends_with({ i8*, i64 }*, { i8*, i64 }*)

declare i32 @string_is_empty(i8*)

declare i32 @string_starts_with({ i8*, i64 }*, { i8*, i64 }*)

declare i32 @system({ i8*, i64 })

declare i32 @vec_contains(i8*, i8*, i64)

declare i32 @vec_get(i8*, i64, i64, i8*)

declare i32 @vec_is_empty(i8*)

declare i32 @vec_pop(i8*, i64, i8*)

declare i64 @blood_alloc_or_abort(i64, i32*)

declare i64 @blood_alloc_simple(i64)

declare i64 @blood_continuation_create_multishot(i64 (i64, i8*)*, i8*)

declare i64 @blood_continuation_resume(i64, i64)

declare i64 @blood_continuation_resume_with_regions(i64, i64)

declare i64 @blood_continuation_take_suspended_regions(i64, i8*, i64)

declare i64 @blood_effect_context_get_snapshot()

declare i64 @blood_effect_context_take_snapshot()

declare i64 @blood_evidence_get(i8*, i64)

declare i64 @blood_evidence_pop(i8*)

declare i64 @blood_fiber_create()

declare i64 @blood_fiber_suspend()

declare i64 @blood_get_type_tag(i8*)

declare i64 @blood_handler_depth(i64)

declare i64 @blood_memcpy(i64, i64, i64)

declare i64 @blood_perform(i64, i32, i64*, i64, i64)

declare i64 @blood_realloc(i64, i64)

declare i64 @blood_region_alloc(i64, i64, i64)

declare i64 @blood_region_create(i64, i64)

declare i64 @blood_region_used(i64)

declare i64 @blood_scheduler_active_fibers()

declare i64 @blood_scheduler_runnable_fibers()

declare i64 @blood_scheduler_spawn(i8*, i8*)

declare i64 @blood_scheduler_spawn_simple(i8*)

declare i64 @blood_snapshot_create()

declare i64 @blood_snapshot_len(i64)

declare i64 @blood_snapshot_validate(i64)

declare i64 @blood_thread_join(i64)

declare i64 @blood_thread_spawn(i64, i64)

declare i64 @i32_to_i64(i32)

declare i64 @parse_i64_radix({ i8*, i64 }, i32)

declare i64 @ptr_read_i64(i64)

declare i64 @ptr_read_u64(i64)

declare i64 @size_of_bool()

declare i64 @size_of_i32()

declare i64 @size_of_i64()

declare i64 @str_len({ i8*, i64 })

declare i64 @str_len_chars({ i8*, i64 }*)

declare i64 @str_len_usize({ i8*, i64 }*)

declare i64 @string_len(i8*)

declare i64 @string_len_chars({ i8*, i64 }*)

declare i64 @vec_capacity(i8*)

declare i64 @vec_len(i8*)

declare i8 @ptr_read_u8(i64)

declare i8* @blood_dispatch_lookup(i64, i64)

declare i8* @blood_evidence_create()

declare i8* @blood_evidence_current()

declare i8* @blood_evidence_get_state(i8*, i64)

declare i8* @box_as_mut(i8*)

declare i8* @box_as_ref(i8*)

declare i8* @box_from_raw(i8*)

declare i8* @box_into_raw(i8*)

declare i8* @box_leak(i8*)

declare i8* @box_new(i8*, i64)

declare i8* @vec_get_ptr(i8*, i64, i64)

declare void @blood_assert(i32)

declare void @blood_assert_eq_bool(i1, i1)

declare void @blood_assert_eq_int(i32, i32)

declare void @blood_continuation_add_suspended_region(i64, i64)

declare void @blood_dispatch_register(i64, i64, i8*)

declare void @blood_effect_context_set_snapshot(i64)

declare void @blood_evidence_clear_inline()

declare void @blood_evidence_destroy(i8*)

declare void @blood_evidence_push(i8*, i64)

declare void @blood_evidence_push_with_state(i8*, i64, i8*)

declare void @blood_evidence_register(i8*, i64, i8**, i64)

declare void @blood_evidence_set_current(i8*)

declare void @blood_evidence_set_state(i8*, i8*)

declare void @blood_fiber_resume(i64, i64)

declare void @blood_free(i64, i64)

declare void @blood_free_simple(i64)

declare void @blood_increment_generation(i8*)

declare void @blood_panic(i8*)

declare void @blood_region_activate(i64)

declare void @blood_region_deactivate()

declare void @blood_region_destroy(i64)

declare void @blood_runtime_shutdown()

declare void @blood_scheduler_run()

declare void @blood_scheduler_shutdown()

declare void @blood_scheduler_wait()

declare void @blood_scheduler_yield()

declare void @blood_snapshot_add_entry(i64, i64, i32)

declare void @blood_snapshot_destroy(i64)

declare void @blood_snapshot_stale_panic(i64, i64)

declare void @blood_stale_reference_panic(i32, i32)

declare void @blood_unregister_allocation(i64)

declare void @box_free(i8*, i64)

declare void @box_into_inner(i8*, i64, i8*)

declare void @debug_read_enum_at(i8*)

declare void @debug_vec_index(i64, i64)

declare void @debug_vec_ptrs(i8*, i8*)

declare void @eprint_str({ i8*, i64 })

declare void @eprintln_str({ i8*, i64 })

declare void @option_and(i8*, i8*, i64, i8*)

declare void @option_as_mut(i8*, i64, i8*)

declare void @option_as_ref(i8*, i64, i8*)

declare void @option_expect(i8*, i64, i8*, i64, i8*)

declare void @option_ok_or(i8*, i64, i8*, i64, i8*)

declare void @option_or(i8*, i8*, i64, i8*)

declare void @option_replace(i8*, i8*, i64, i8*)

declare void @option_take(i8*, i64, i8*)

declare void @option_unwrap(i8*, i64, i8*)

declare void @option_unwrap_or(i8*, i64, i8*, i8*)

declare void @option_xor(i8*, i8*, i64, i8*)

declare void @panic({ i8*, i64 })

declare void @print_bool(i1)

declare void @print_char(i32)

declare void @print_f32(float)

declare void @print_f32_prec(float, i32)

declare void @print_f64(double)

declare void @print_f64_prec(double, i32)

declare void @print_i64(i64)

declare void @print_int(i32)

declare void @print_newline()

declare void @print_str({ i8*, i64 })

declare void @print_u64(i64)

declare void @println()

declare void @println_bool(i1)

declare void @println_char(i32)

declare void @println_f32(float)

declare void @println_f32_prec(float, i32)

declare void @println_f64(double)

declare void @println_f64_prec(double, i32)

declare void @println_i64(i64)

declare void @println_int(i32)

declare void @println_str({ i8*, i64 })

declare void @println_u64(i64)

declare void @ptr_write_f64(i64, double)

declare void @ptr_write_i32(i64, i32)

declare void @ptr_write_i64(i64, i64)

declare void @ptr_write_u64(i64, i64)

declare void @ptr_write_u8(i64, i8)

declare void @result_and(i8*, i8*, i64, i64, i8*)

declare void @result_as_mut(i8*, i64, i64, i8*)

declare void @result_as_ref(i8*, i64, i64, i8*)

declare void @result_err(i8*, i64, i8*)

declare void @result_expect(i8*, i64, i8*, i64, i8*)

declare void @result_expect_err(i8*, i64, i8*, i64, i8*)

declare void @result_ok(i8*, i64, i8*)

declare void @result_or(i8*, i8*, i64, i64, i8*)

declare void @result_unwrap(i8*, i64, i8*)

declare void @result_unwrap_err(i8*, i64, i8*)

declare void @result_unwrap_or(i8*, i64, i8*, i8*)

declare void @str_to_string({ i8*, i64 }*, i8*)

declare void @string_clear(i8*)

declare void @string_find({ i8*, i64 }*, { i8*, i64 }*, i8*)

declare void @string_new(i8*)

declare void @string_push(i8*, i32)

declare void @string_push_str(i8*, { i8*, i64 }*)

declare void @string_rfind({ i8*, i64 }*, { i8*, i64 }*, i8*)

declare void @string_substring(i8*, i64, i64, i8*)

declare void @vec_clear(i8*)

declare void @vec_first(i8*, i64, i8*)

declare void @vec_free(i8*, i64)

declare void @vec_last(i8*, i64, i8*)

declare void @vec_new(i64, i8*)

declare void @vec_push(i8*, i8*, i64)

declare void @vec_reverse(i8*, i64)

declare void @vec_with_capacity(i64, i64, i8*)

declare { i32, i32 } @str_char_at({ i8*, i64 }*, i64)

declare { i32, i32 } @str_char_at_index({ i8*, i64 }*, i64)

declare { i32, i32 } @string_char_at({ i8*, i64 }*, i64)

declare { i8*, i64 } @args_get(i32)

declare { i8*, i64 } @blood_str_concat({ i8*, i64 }, { i8*, i64 })

declare { i8*, i64 } @bool_to_string(i1)

declare { i8*, i64 } @char_to_string(i32)

declare { i8*, i64 } @f32_to_string(float)

declare { i8*, i64 } @f64_to_string(double)

declare { i8*, i64 } @file_read_to_string({ i8*, i64 })

declare { i8*, i64 } @i128_to_string(i128)

declare { i8*, i64 } @i16_to_string(i16)

declare { i8*, i64 } @i64_to_string(i64)

declare { i8*, i64 } @i8_to_string(i8)

declare { i8*, i64 } @int_to_string(i32)

declare { i8*, i64 } @read_line()

declare { i8*, i64 } @str_as_bytes({ i8*, i64 }*)

declare { i8*, i64 } @string_as_bytes({ i8*, i64 }*)

declare { i8*, i64 } @string_as_str(i8*)

declare { i8*, i64 } @string_trim({ i8*, i64 }*)

declare { i8*, i64 } @string_trim_end({ i8*, i64 }*)

declare { i8*, i64 } @string_trim_start({ i8*, i64 }*)

declare { i8*, i64 } @u128_to_string(i128)

declare { i8*, i64 } @u16_to_string(i16)

declare { i8*, i64 } @u32_to_string(i32)

declare { i8*, i64 } @u64_to_string(i64)

declare { i8*, i64 } @u8_to_string(i8)

define i32 @blood_main() {
bb0:
  %_0_stack = alloca i32, align 4
  %_1_stack = alloca i32, align 4
  %_2_stack = alloca { i32 }, align 4
  %_3_stack = alloca { i32 }, align 4
  %_4_stack = alloca i8, align 1
  %_5_stack = alloca i8, align 1
  %_6_stack = alloca i8, align 1
  %_7_stack = alloca i32, align 4
  %_8_stack = alloca i32, align 4
  %_9_stack = alloca i1, align 1
  %_10_stack = alloca i8, align 1
  %_11_stack = alloca i8, align 1
  store { i32 } zeroinitializer, { i32 }* %_2_stack, align 4
  %load = load { i32 }, { i32 }* %_2_stack, align 4
  store { i32 } %load, { i32 }* %_3_stack, align 4
  %current_ev = call i8* @blood_evidence_current()
  %ev_is_null = icmp eq i8* %current_ev, null
  br i1 %ev_is_null, label %region_create_ev, label %region_clone_ev

bb1:                                              ; preds = %region_merge_ev
  call void @"blood$increment"()
  br label %bb2

bb2:                                              ; preds = %bb1
  call void @"blood$increment"()
  br label %bb3

bb3:                                              ; preds = %bb2
  %snapshot = call i64 @blood_snapshot_create()
  %continuation = call i64 @blood_continuation_create_multishot(i64 (i64, i8*)* @__blood_identity_continuation, i8* null)
  %perform_result = call i64 @blood_perform(i64 334, i32 0, i64* null, i64 0, i64 %continuation)
  %perform_trunc = trunc i64 %perform_result to i32
  store i32 %perform_trunc, i32* %_7_stack, align 4
  %validation = call i64 @blood_snapshot_validate(i64 %snapshot)
  call void @blood_snapshot_destroy(i64 %snapshot)
  %is_valid = icmp eq i64 %validation, 0
  br i1 %is_valid, label %snapshot_valid, label %snapshot_stale

bb4:                                              ; preds = %snapshot_valid
  %current_ev1 = call i8* @blood_evidence_current()
  %0 = call i64 @blood_evidence_pop(i8* %current_ev1)
  call void @blood_evidence_clear_inline()
  %load2 = load i32, i32* %_7_stack, align 4
  %result_ext = sext i32 %load2 to i64
  %state_void_ptr3 = bitcast { i64 }* %state_shadow to i8*
  %return_clause_result = call i64 @LocalState_return(i64 %result_ext, i8* %state_void_ptr3)
  %ret_trunc = trunc i64 %return_clause_result to i32
  store i32 %ret_trunc, i32* %_8_stack, align 4
  %load4 = load i32, i32* %_8_stack, align 4
  store i32 %load4, i32* %_1_stack, align 4
  %load5 = load i32, i32* %_1_stack, align 4
  %ne = icmp ne i32 %load5, 3
  store i1 %ne, i1* %_9_stack, align 1
  %load6 = load i1, i1* %_9_stack, align 1
  switch i1 %load6, label %bb6 [
    i1 true, label %bb5
  ]

bb5:                                              ; preds = %bb4
  store i32 1, i32* %_0_stack, align 4
  %ret_val = load i32, i32* %_0_stack, align 4
  ret i32 %ret_val

bb6:                                              ; preds = %bb4
  store i8 0, i8* %_10_stack, align 1
  br label %bb7

bb7:                                              ; preds = %bb8, %bb6
  store i32 0, i32* %_0_stack, align 4
  %ret_val7 = load i32, i32* %_0_stack, align 4
  ret i32 %ret_val7

bb8:                                              ; No predecessors!
  store i8 0, i8* %_11_stack, align 1
  br label %bb7

region_create_ev:                                 ; preds = %bb0
  %new_evidence = call i8* @blood_evidence_create()
  br label %region_merge_ev

region_clone_ev:                                  ; preds = %bb0
  %cloned_evidence = call i8* @blood_evidence_create()
  br label %region_merge_ev

region_merge_ev:                                  ; preds = %region_clone_ev, %region_create_ev
  %evidence = phi i8* [ %new_evidence, %region_create_ev ], [ %cloned_evidence, %region_clone_ev ]
  call void @blood_evidence_set_current(i8* %evidence)
  %state_shadow = alloca { i64 }, align 8
  %typed_state_for_shadow = bitcast { i32 }* %_3_stack to { i8* }*
  %state_field_0_ptr = getelementptr inbounds { i8* }, { i8* }* %typed_state_for_shadow, i32 0, i32 0
  %state_field_0 = load i8*, i8** %state_field_0_ptr, align 8
  %shadow_0_ptr = getelementptr inbounds { i64 }, { i64 }* %state_shadow, i32 0, i32 0
  %state_field_0_ptoi = ptrtoint i8* %state_field_0 to i64
  store i64 %state_field_0_ptoi, i64* %shadow_0_ptr, align 8
  %state_void_ptr = bitcast { i64 }* %state_shadow to i8*
  call void @blood_evidence_push_with_state(i8* %evidence, i64 334, i8* %state_void_ptr)
  call void @"blood$increment"()
  br label %bb1

snapshot_valid:                                   ; preds = %bb3
  br label %bb4

snapshot_stale:                                   ; preds = %bb3
  call void @blood_stale_reference_panic(i32 0, i32 0)
  unreachable
}

define internal i64 @__blood_identity_continuation(i64 %0, i8* %1) {
entry:
  ret i64 %0
}

define linkonce_odr void @__blood_register_handlers() {
entry:
  %handler_ops = alloca [2 x i8*], align 8
  %op_ptr = getelementptr [2 x i8*], [2 x i8*]* %handler_ops, i32 0, i32 0
  store i8* bitcast (i64 (i8*, i64*, i64, i64)* @LocalState_get to i8*), i8** %op_ptr, align 8
  %op_ptr1 = getelementptr [2 x i8*], [2 x i8*]* %handler_ops, i32 0, i32 1
  store i8* bitcast (i64 (i8*, i64*, i64, i64)* @LocalState_put to i8*), i8** %op_ptr1, align 8
  %ops_ptr = getelementptr [2 x i8*], [2 x i8*]* %handler_ops, i32 0, i32 0
  call void @blood_evidence_register(i8* null, i64 334, i8** %ops_ptr, i64 2)
  ret void
}

define weak_odr i64 @LocalState_get(i8* %0, i64* %1, i64 %2, i64 %3) {
entry:
  %continuation = alloca i64, align 8
  store i64 %3, i64* %continuation, align 8
  %typed_state_ptr = bitcast i8* %0 to { i64 }*
  %state_ptr = getelementptr inbounds { i64 }, { i64 }* %typed_state_ptr, i32 0, i32 0
  %state = alloca i64, align 8
  %state_val = load i64, i64* %state_ptr, align 8
  store i64 %state_val, i64* %state, align 8
  %resume_placeholder = alloca i64, align 8
  %load = load i64, i64* %state, align 8
  %cont_handle = load i64, i64* %continuation, align 8
  %is_tail = icmp eq i64 %cont_handle, 0
  br i1 %is_tail, label %resume_tail, label %resume_cont

resume_tail:                                      ; preds = %entry
  ret i64 %load

resume_cont:                                      ; preds = %entry
  %cont_result = call i64 @blood_continuation_resume(i64 %cont_handle, i64 %load)
  br label %resume_merge

resume_merge:                                     ; preds = %resume_cont
  %resume_result = phi i64 [ %cont_result, %resume_cont ]
  %resume_trunc = trunc i64 %resume_result to i32
  %state_writeback_ptr = getelementptr inbounds { i64 }, { i64 }* %typed_state_ptr, i32 0, i32 0
  %state_writeback_val = load i64, i64* %state, align 8
  store i64 %state_writeback_val, i64* %state_writeback_ptr, align 8
  %ret_ext = sext i32 %resume_trunc to i64
  ret i64 %ret_ext
}

define weak_odr i64 @LocalState_put(i8* %0, i64* %1, i64 %2, i64 %3) {
entry:
  %continuation = alloca i64, align 8
  store i64 %3, i64* %continuation, align 8
  %typed_state_ptr = bitcast i8* %0 to { i64 }*
  %state_ptr = getelementptr inbounds { i64 }, { i64 }* %typed_state_ptr, i32 0, i32 0
  %state = alloca i64, align 8
  %state_val = load i64, i64* %state_ptr, align 8
  store i64 %state_val, i64* %state, align 8
  %s = alloca i64, align 8
  store i64 0, i64* %s, align 8
  %resume_placeholder = alloca i64, align 8
  %arg_0_ptr = getelementptr i64, i64* %1, i64 0
  %arg_0 = load i64, i64* %arg_0_ptr, align 8
  store i64 %arg_0, i64* %s, align 8
  %load = load i64, i64* %s, align 8
  store i64 %load, i64* %state, align 8
  %cont_handle = load i64, i64* %continuation, align 8
  %is_tail = icmp eq i64 %cont_handle, 0
  br i1 %is_tail, label %resume_tail, label %resume_cont

resume_tail:                                      ; preds = %entry
  ret i64 0

resume_cont:                                      ; preds = %entry
  %cont_result = call i64 @blood_continuation_resume(i64 %cont_handle, i64 0)
  br label %resume_merge

resume_merge:                                     ; preds = %resume_cont
  %resume_result = phi i64 [ %cont_result, %resume_cont ]
  %resume_trunc = trunc i64 %resume_result to i32
  %state_writeback_ptr = getelementptr inbounds { i64 }, { i64 }* %typed_state_ptr, i32 0, i32 0
  %state_writeback_val = load i64, i64* %state, align 8
  store i64 %state_writeback_val, i64* %state_writeback_ptr, align 8
  %ret_ext = sext i32 %resume_trunc to i64
  ret i64 %ret_ext
}

define weak_odr i64 @LocalState_return(i64 %0, i8* %1) {
entry:
  %typed_state_ptr = bitcast i8* %1 to { i64 }*
  %x = alloca i32, align 4
  %ret_trunc = trunc i64 %0 to i32
  store i32 %ret_trunc, i32* %x, align 4
  %state_ptr = getelementptr inbounds { i64 }, { i64 }* %typed_state_ptr, i32 0, i32 0
  %state = alloca i64, align 8
  %state_val = load i64, i64* %state_ptr, align 8
  store i64 %state_val, i64* %state, align 8
  %load = load i32, i32* %x, align 4
  %ret_ext = sext i32 %load to i64
  ret i64 %ret_ext
}

define weak_odr void @"blood$increment"() {
bb0:
  %_0_stack = alloca i8, align 1
  %_1_stack = alloca i32, align 4
  %_2_stack = alloca i32, align 4
  %_3_stack = alloca i32, align 4
  %_4_stack = alloca i8, align 1
  %_5_stack = alloca i8, align 1
  %snapshot = call i64 @blood_snapshot_create()
  %continuation = call i64 @blood_continuation_create_multishot(i64 (i64, i8*)* @__blood_identity_continuation, i8* null)
  %perform_result = call i64 @blood_perform(i64 334, i32 0, i64* null, i64 0, i64 %continuation)
  %perform_trunc = trunc i64 %perform_result to i32
  store i32 %perform_trunc, i32* %_2_stack, align 4
  %validation = call i64 @blood_snapshot_validate(i64 %snapshot)
  call void @blood_snapshot_destroy(i64 %snapshot)
  %is_valid = icmp eq i64 %validation, 0
  br i1 %is_valid, label %snapshot_valid, label %snapshot_stale

bb1:                                              ; preds = %snapshot_valid
  %load = load i32, i32* %_2_stack, align 4
  store i32 %load, i32* %_1_stack, align 4
  %load1 = load i32, i32* %_1_stack, align 4
  %add = add i32 %load1, 1
  store i32 %add, i32* %_3_stack, align 4
  %load2 = load i32, i32* %_3_stack, align 4
  %snapshot3 = call i64 @blood_snapshot_create()
  %perform_args = alloca [1 x i64], align 8
  %arg_0 = getelementptr [1 x i64], [1 x i64]* %perform_args, i64 0, i64 0
  %arg_i64 = zext i32 %load2 to i64
  store i64 %arg_i64, i64* %arg_0, align 8
  %args_ptr = bitcast [1 x i64]* %perform_args to i64*
  %continuation4 = call i64 @blood_continuation_create_multishot(i64 (i64, i8*)* @__blood_identity_continuation, i8* null)
  %perform_result5 = call i64 @blood_perform(i64 334, i32 1, i64* %args_ptr, i64 1, i64 %continuation4)
  %validation6 = call i64 @blood_snapshot_validate(i64 %snapshot3)
  call void @blood_snapshot_destroy(i64 %snapshot3)
  %is_valid9 = icmp eq i64 %validation6, 0
  br i1 %is_valid9, label %snapshot_valid7, label %snapshot_stale8

bb2:                                              ; preds = %snapshot_valid7
  store i8 0, i8* %_5_stack, align 1
  %load10 = load i8, i8* %_5_stack, align 1
  store i8 %load10, i8* %_0_stack, align 1
  ret void

snapshot_valid:                                   ; preds = %bb0
  br label %bb1

snapshot_stale:                                   ; preds = %bb0
  call void @blood_stale_reference_panic(i32 0, i32 0)
  unreachable

snapshot_valid7:                                  ; preds = %bb1
  br label %bb2

snapshot_stale8:                                  ; preds = %bb1
  call void @blood_stale_reference_panic(i32 0, i32 0)
  unreachable
}
