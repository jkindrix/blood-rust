---
source: bloodc/tests/codegen_regression.rs
expression: ir
---
; ModuleID = 'blood_program'

declare double @parse_f64({ i8*, i64 })

declare double @ptr_read_f64(i64)

declare i1 @file_append_string({ i8*, i64 }, { i8*, i64 })

declare i1 @file_delete({ i8*, i64 })

declare i1 @file_exists({ i8*, i64 })

declare i1 @file_write_string({ i8*, i64 }, { i8*, i64 })

declare i1 @str_eq({ i8*, i64 }, { i8*, i64 })

declare i32 @args_count()

declare i32 @blood_alloc(i64, i64*, i64*)

declare i32 @blood_check_generation(i32, i32)

declare i32 @blood_get_generation(i64)

declare i32 @blood_region_exit_scope(i64)

declare i32 @blood_region_is_pending_deallocation(i64)

declare i32 @blood_region_is_suspended(i64)

declare i32 @blood_region_resume(i64)

declare i32 @blood_region_suspend(i64)

declare i32 @blood_register_allocation(i64, i64)

declare i32 @blood_runtime_init()

declare i32 @blood_scheduler_init(i64)

declare i32 @blood_scheduler_is_running()

declare i32 @blood_scheduler_run_background()

declare i32 @blood_validate_generation(i64, i32)

declare i32 @char_from_u32(i32)

declare i32 @i64_to_i32(i64)

declare i32 @option_is_none(i8*)

declare i32 @option_is_some(i8*)

declare i32 @option_try(i8*, i64, i8*)

declare i32 @ptr_read_i32(i64)

declare i32 @read_int()

declare i32 @result_is_err(i8*)

declare i32 @result_is_ok(i8*)

declare i32 @result_try(i8*, i64, i8*)

declare i32 @string_contains({ i8*, i64 }*, { i8*, i64 }*)

declare i32 @string_ends_with({ i8*, i64 }*, { i8*, i64 }*)

declare i32 @string_is_empty(i8*)

declare i32 @string_starts_with({ i8*, i64 }*, { i8*, i64 }*)

declare i32 @system({ i8*, i64 })

declare i32 @vec_contains(i8*, i8*, i64)

declare i32 @vec_get(i8*, i64, i64, i8*)

declare i32 @vec_is_empty(i8*)

declare i32 @vec_pop(i8*, i64, i8*)

declare i64 @blood_alloc_or_abort(i64, i32*)

declare i64 @blood_alloc_simple(i64)

declare i64 @blood_continuation_resume_with_regions(i64, i64)

declare i64 @blood_continuation_take_suspended_regions(i64, i8*, i64)

declare i64 @blood_effect_context_get_snapshot()

declare i64 @blood_effect_context_take_snapshot()

declare i64 @blood_evidence_get(i8*, i64)

declare i64 @blood_evidence_pop(i8*)

declare i64 @blood_fiber_create()

declare i64 @blood_fiber_suspend()

declare i64 @blood_get_type_tag(i8*)

declare i64 @blood_handler_depth(i64)

declare i64 @blood_memcpy(i64, i64, i64)

declare i64 @blood_perform(i64, i32, i64*, i64, i64)

declare i64 @blood_realloc(i64, i64)

declare i64 @blood_region_alloc(i64, i64, i64)

declare i64 @blood_region_create(i64, i64)

declare i64 @blood_region_used(i64)

declare i64 @blood_scheduler_active_fibers()

declare i64 @blood_scheduler_runnable_fibers()

declare i64 @blood_scheduler_spawn(i8*, i8*)

declare i64 @blood_scheduler_spawn_simple(i8*)

declare i64 @blood_snapshot_create()

declare i64 @blood_snapshot_len(i64)

declare i64 @blood_snapshot_validate(i64)

declare i64 @blood_thread_join(i64)

declare i64 @blood_thread_spawn(i64, i64)

declare i64 @i32_to_i64(i32)

declare i64 @parse_i64_radix({ i8*, i64 }, i32)

declare i64 @ptr_read_i64(i64)

declare i64 @ptr_read_u64(i64)

declare i64 @size_of_bool()

declare i64 @size_of_i32()

declare i64 @size_of_i64()

declare i64 @str_len({ i8*, i64 })

declare i64 @str_len_chars({ i8*, i64 }*)

declare i64 @str_len_usize({ i8*, i64 }*)

declare i64 @string_len(i8*)

declare i64 @string_len_chars({ i8*, i64 }*)

declare i64 @vec_capacity(i8*)

declare i64 @vec_len(i8*)

declare i8 @ptr_read_u8(i64)

declare i8* @blood_dispatch_lookup(i64, i64)

declare i8* @blood_evidence_create()

declare i8* @blood_evidence_current()

declare i8* @blood_evidence_get_state(i8*, i64)

declare i8* @box_as_mut(i8*)

declare i8* @box_as_ref(i8*)

declare i8* @box_from_raw(i8*)

declare i8* @box_into_raw(i8*)

declare i8* @box_leak(i8*)

declare i8* @box_new(i8*, i64)

declare i8* @vec_get_ptr(i8*, i64, i64)

declare void @blood_assert(i32)

declare void @blood_assert_eq_bool(i1, i1)

declare void @blood_assert_eq_int(i32, i32)

declare void @blood_continuation_add_suspended_region(i64, i64)

declare void @blood_dispatch_register(i64, i64, i8*)

declare void @blood_effect_context_set_snapshot(i64)

declare void @blood_evidence_destroy(i8*)

declare void @blood_evidence_push(i8*, i64)

declare void @blood_evidence_register(i8*, i64, i8**, i64)

declare void @blood_evidence_set_state(i8*, i8*)

declare void @blood_fiber_resume(i64, i64)

declare void @blood_free(i64, i64)

declare void @blood_free_simple(i64)

declare void @blood_increment_generation(i8*)

declare void @blood_panic(i8*)

declare void @blood_region_activate(i64)

declare void @blood_region_deactivate()

declare void @blood_region_destroy(i64)

declare void @blood_runtime_shutdown()

declare void @blood_scheduler_run()

declare void @blood_scheduler_shutdown()

declare void @blood_scheduler_wait()

declare void @blood_scheduler_yield()

declare void @blood_snapshot_add_entry(i64, i64, i32)

declare void @blood_snapshot_destroy(i64)

declare void @blood_snapshot_stale_panic(i64, i64)

declare void @blood_stale_reference_panic(i32, i32)

declare void @blood_unregister_allocation(i64)

declare void @box_free(i8*, i64)

declare void @box_into_inner(i8*, i64, i8*)

declare void @debug_read_enum_at(i8*)

declare void @debug_vec_index(i64, i64)

declare void @debug_vec_ptrs(i8*, i8*)

declare void @eprint_str({ i8*, i64 })

declare void @eprintln_str({ i8*, i64 })

declare void @option_and(i8*, i8*, i64, i8*)

declare void @option_as_mut(i8*, i64, i8*)

declare void @option_as_ref(i8*, i64, i8*)

declare void @option_expect(i8*, i64, i8*, i64, i8*)

declare void @option_ok_or(i8*, i64, i8*, i64, i8*)

declare void @option_or(i8*, i8*, i64, i8*)

declare void @option_replace(i8*, i8*, i64, i8*)

declare void @option_take(i8*, i64, i8*)

declare void @option_unwrap(i8*, i64, i8*)

declare void @option_unwrap_or(i8*, i64, i8*, i8*)

declare void @option_xor(i8*, i8*, i64, i8*)

declare void @panic({ i8*, i64 })

declare void @print_bool(i1)

declare void @print_char(i32)

declare void @print_f32(float)

declare void @print_f32_prec(float, i32)

declare void @print_f64(double)

declare void @print_f64_prec(double, i32)

declare void @print_i64(i64)

declare void @print_int(i32)

declare void @print_newline()

declare void @print_str({ i8*, i64 })

declare void @print_u64(i64)

declare void @println()

declare void @println_bool(i1)

declare void @println_char(i32)

declare void @println_f32(float)

declare void @println_f32_prec(float, i32)

declare void @println_f64(double)

declare void @println_f64_prec(double, i32)

declare void @println_i64(i64)

declare void @println_int(i32)

declare void @println_str({ i8*, i64 })

declare void @println_u64(i64)

declare void @ptr_write_f64(i64, double)

declare void @ptr_write_i32(i64, i32)

declare void @ptr_write_i64(i64, i64)

declare void @ptr_write_u64(i64, i64)

declare void @ptr_write_u8(i64, i8)

declare void @result_and(i8*, i8*, i64, i64, i8*)

declare void @result_as_mut(i8*, i64, i64, i8*)

declare void @result_as_ref(i8*, i64, i64, i8*)

declare void @result_err(i8*, i64, i8*)

declare void @result_expect(i8*, i64, i8*, i64, i8*)

declare void @result_expect_err(i8*, i64, i8*, i64, i8*)

declare void @result_ok(i8*, i64, i8*)

declare void @result_or(i8*, i8*, i64, i64, i8*)

declare void @result_unwrap(i8*, i64, i8*)

declare void @result_unwrap_err(i8*, i64, i8*)

declare void @result_unwrap_or(i8*, i64, i8*, i8*)

declare void @str_to_string({ i8*, i64 }*, i8*)

declare void @string_clear(i8*)

declare void @string_find({ i8*, i64 }*, { i8*, i64 }*, i8*)

declare void @string_new(i8*)

declare void @string_push(i8*, i32)

declare void @string_push_str(i8*, { i8*, i64 }*)

declare void @string_rfind({ i8*, i64 }*, { i8*, i64 }*, i8*)

declare void @string_substring(i8*, i64, i64, i8*)

declare void @vec_clear(i8*)

declare void @vec_first(i8*, i64, i8*)

declare void @vec_free(i8*, i64)

declare void @vec_last(i8*, i64, i8*)

declare void @vec_new(i64, i8*)

declare void @vec_push(i8*, i8*, i64)

declare void @vec_reverse(i8*, i64)

declare void @vec_with_capacity(i64, i64, i8*)

declare { i32, i32 } @str_char_at({ i8*, i64 }*, i64)

declare { i32, i32 } @str_char_at_index({ i8*, i64 }*, i64)

declare { i32, i32 } @string_char_at({ i8*, i64 }*, i64)

declare { i8*, i64 } @args_get(i32)

declare { i8*, i64 } @blood_str_concat({ i8*, i64 }, { i8*, i64 })

declare { i8*, i64 } @bool_to_string(i1)

declare { i8*, i64 } @char_to_string(i32)

declare { i8*, i64 } @f32_to_string(float)

declare { i8*, i64 } @f64_to_string(double)

declare { i8*, i64 } @file_read_to_string({ i8*, i64 })

declare { i8*, i64 } @i128_to_string(i128)

declare { i8*, i64 } @i16_to_string(i16)

declare { i8*, i64 } @i64_to_string(i64)

declare { i8*, i64 } @i8_to_string(i8)

declare { i8*, i64 } @int_to_string(i32)

declare { i8*, i64 } @read_line()

declare { i8*, i64 } @str_as_bytes({ i8*, i64 }*)

declare { i8*, i64 } @string_as_bytes({ i8*, i64 }*)

declare { i8*, i64 } @string_as_str(i8*)

declare { i8*, i64 } @string_trim({ i8*, i64 }*)

declare { i8*, i64 } @string_trim_end({ i8*, i64 }*)

declare { i8*, i64 } @string_trim_start({ i8*, i64 }*)

declare { i8*, i64 } @u128_to_string(i128)

declare { i8*, i64 } @u16_to_string(i16)

declare { i8*, i64 } @u32_to_string(i32)

declare { i8*, i64 } @u64_to_string(i64)

declare { i8*, i64 } @u8_to_string(i8)

define i32 @blood_main() {
bb0:
  %_0_stack = alloca i32, align 4
  %_1_stack = alloca i32, align 4
  %call_result = call i32 @"blood$factorial$i32"(i32 5)
  store i32 %call_result, i32* %_1_stack, align 4
  br label %bb1

bb1:                                              ; preds = %bb0
  %load = load i32, i32* %_1_stack, align 4
  store i32 %load, i32* %_0_stack, align 4
  %ret_val = load i32, i32* %_0_stack, align 4
  ret i32 %ret_val
}

define weak_odr i32 @"blood$factorial$i32"(i32 %0) {
bb0:
  %_0_stack = alloca i32, align 4
  %_1_stack = alloca i32, align 4
  %_2_stack = alloca i1, align 1
  %_3_stack = alloca i32, align 4
  %_4_stack = alloca i32, align 4
  %_5_stack = alloca i32, align 4
  %_6_stack = alloca i32, align 4
  store i32 %0, i32* %_1_stack, align 4
  %load = load i32, i32* %_1_stack, align 4
  %le = icmp sle i32 %load, 1
  store i1 %le, i1* %_2_stack, align 1
  %load1 = load i1, i1* %_2_stack, align 1
  switch i1 %load1, label %bb2 [
    i1 true, label %bb1
  ]

bb1:                                              ; preds = %bb0
  store i32 1, i32* %_3_stack, align 4
  br label %bb3

bb2:                                              ; preds = %bb0
  %load2 = load i32, i32* %_1_stack, align 4
  %sub = sub i32 %load2, 1
  store i32 %sub, i32* %_4_stack, align 4
  %load3 = load i32, i32* %_4_stack, align 4
  %call_result = call i32 @"blood$factorial$i32"(i32 %load3)
  store i32 %call_result, i32* %_5_stack, align 4
  br label %bb4

bb3:                                              ; preds = %bb4, %bb1
  %load4 = load i32, i32* %_3_stack, align 4
  store i32 %load4, i32* %_0_stack, align 4
  %ret_val = load i32, i32* %_0_stack, align 4
  ret i32 %ret_val

bb4:                                              ; preds = %bb2
  %load5 = load i32, i32* %_1_stack, align 4
  %load6 = load i32, i32* %_5_stack, align 4
  %mul = mul i32 %load5, %load6
  store i32 %mul, i32* %_6_stack, align 4
  %load7 = load i32, i32* %_6_stack, align 4
  store i32 %load7, i32* %_3_stack, align 4
  br label %bb3
}
