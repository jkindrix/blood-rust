// Algebraic Effects in Blood
// A comprehensive example demonstrating effect declarations, handlers, and operations.
//
// Algebraic effects provide a principled approach to side effects, separating
// the description of what effects a computation can perform from how those
// effects are handled.

// ===========================================================================
// 1. Effect Declarations
// ===========================================================================

// Simple effect with no parameters
effect Console {
    op print(msg: i32) -> ();
    op read() -> i32;
}

// Generic effect with type parameter
effect State<S> {
    op get() -> S;
    op put(s: S) -> ();
}

// Effect for error handling
effect Error<E> {
    op raise(err: E) -> ();
}

// Effect for non-determinism / choice
effect Choice {
    op choose(a: i32, b: i32) -> i32;
    op flip() -> bool;
}

// Effect for generators / yielding values
effect Yield<T> {
    op yield_value(value: T) -> ();
}

// Effect for async operations (conceptual)
effect Async {
    op suspend() -> ();
    op spawn(task: i32) -> i32;
}

// ===========================================================================
// 2. Deep Handler Declaration
// ===========================================================================

// Deep handlers automatically re-wrap the continuation, making all subsequent
// operations go through the same handler. This is the default and most common.

deep handler LocalState<S> for State<S> {
    // Handler state - mutable variable to store the state
    let mut state: S

    // Return clause - what to do when the handled computation finishes
    return(x) { x }

    // Operation implementations
    op get() {
        resume(state)
    }

    op put(s) {
        state = s;
        resume(())
    }
}

// Deep handler for error handling - early exit behavior
deep handler TryError<E> for Error<E> {
    let mut error_value: E

    return(x) { x }

    op raise(err) {
        // Does not resume - early exit, stores error for later retrieval
        error_value = err;
        // Return unit since this is a non-resumptive handler
        // The handler's return clause determines the final result type
        ()
    }
}

// Deep handler for console operations
deep handler MockConsole for Console {
    let mut last_printed: i32
    let mut read_value: i32

    return(x) { x }

    op print(msg) {
        last_printed = msg;
        resume(())
    }

    op read() {
        resume(read_value)
    }
}

// Deep handler for counting operations
deep handler CountingState for State<i32> {
    let mut state: i32
    let mut get_count: i32
    let mut put_count: i32

    return(x) { (x, get_count, put_count) }

    op get() {
        get_count = get_count + 1;
        resume(state)
    }

    op put(s) {
        put_count = put_count + 1;
        state = s;
        resume(())
    }
}

// ===========================================================================
// 3. Shallow Handler Declaration
// ===========================================================================

// Shallow handlers do NOT automatically re-wrap the continuation. After one
// operation is handled, subsequent operations are not handled by this handler.
// This is useful for one-shot handlers or when you need explicit control.

shallow handler OnceReader<S> for State<S> {
    let value: S

    return(x) { x }

    // Only handles one get, then returns control
    op get() {
        resume(value)
    }

    // Put is a no-op for read-only handler
    op put(s) {
        resume(())
    }
}

// Shallow handler for single yield
shallow handler FirstYield<T> for Yield<T> {
    let mut first: T
    let mut has_yielded: bool

    return(x) { first }

    op yield_value(v) {
        if !has_yielded {
            first = v;
            has_yielded = true;
        }
        resume(())
    }
}

// Shallow handler for flipping control
shallow handler ControlFlip for Choice {
    return(x) { x }

    op choose(a, b) {
        // Just pick the first one, shallow so only handles once
        resume(a)
    }

    op flip() {
        resume(true)
    }
}

// ===========================================================================
// 4. Handler with Return Clause
// ===========================================================================

// The return clause transforms the final result of the handled computation.
// This is useful for wrapping results, collecting state, or post-processing.

deep handler ResultWrapper for State<i32> {
    let mut state: i32

    // Return clause that wraps the result with the final state
    return(x) {
        // Return a tuple of (result, final_state)
        (x, state)
    }

    op get() {
        resume(state)
    }

    op put(s) {
        state = s;
        resume(())
    }
}

// Handler that accumulates values
deep handler Accumulator for Yield<i32> {
    let mut sum: i32
    let mut count: i32

    // Return clause provides the accumulated statistics
    return(x) {
        (x, sum, count)
    }

    op yield_value(v) {
        sum = sum + v;
        count = count + 1;
        resume(())
    }
}

// Handler that tracks operation history
deep handler TrackedState for State<i32> {
    let mut state: i32
    let mut history_len: i32

    return(x) {
        // Return both the result and how many operations were performed
        (x, history_len)
    }

    op get() {
        history_len = history_len + 1;
        resume(state)
    }

    op put(s) {
        history_len = history_len + 1;
        state = s;
        resume(())
    }
}

// ===========================================================================
// 5. Functions Using Effects (perform operations)
// ===========================================================================

// Function that uses the State effect
fn counter() -> i32 / {State<i32>} {
    let current = perform State.get();
    perform State.put(current + 1);
    current
}

// Function that performs multiple state operations
fn triple_increment() -> i32 / {State<i32>} {
    perform State.put(perform State.get() + 1);
    perform State.put(perform State.get() + 1);
    perform State.put(perform State.get() + 1);
    perform State.get()
}

// Function that uses the Console effect
fn greet(n: i32) -> () / {Console} {
    perform Console.print(n);
    let input = perform Console.read();
    perform Console.print(input)
}

// Function with multiple effects in the row
fn stateful_console(msg: i32) -> i32 / {State<i32>, Console} {
    perform Console.print(msg);
    let state = perform State.get();
    perform State.put(state + msg);
    perform State.get()
}

// Function that can raise errors
fn safe_divide(a: i32, b: i32) -> i32 / {Error<i32>} {
    if b == 0 {
        perform Error.raise(1);
        0
    } else {
        a / b
    }
}

// Function that makes non-deterministic choices
fn pick_path() -> i32 / {Choice} {
    let choice = perform Choice.choose(10, 20);
    if perform Choice.flip() {
        choice * 2
    } else {
        choice
    }
}

// Generator function that yields values
fn generate_range(start: i32, end: i32) -> () / {Yield<i32>} {
    let mut i = start;
    while i < end {
        perform Yield.yield_value(i);
        i = i + 1;
    }
}

// ===========================================================================
// 6. Nested Handlers
// ===========================================================================

// Demonstrate nested effect handling where multiple effects are handled
// by different handlers in a nested fashion.

fn use_nested_effects() -> i32 {
    // Outer handler for State
    with LocalState { state: 0 } handle {
        // Inner handler for Console (mocked)
        with MockConsole { last_printed: 0, read_value: 42 } handle {
            // This code can use both State and Console effects
            let x = perform State.get();
            perform Console.print(x);
            let y = perform Console.read();
            perform State.put(y);
            perform State.get()
        }
    }
}

// Example using state with yield (simplified to avoid nested handler return type complexity)
fn nested_state_example() -> i32 {
    with LocalState { state: 100 } handle {
        // Use State effect
        let start = perform State.get();
        perform State.put(start + 10);
        let mid = perform State.get();
        perform State.put(mid + 20);
        perform State.get()
    }
}

// Triple nesting for complex effect combinations
fn triple_nested() -> i32 {
    with TryError { error_value: 0 } handle {
        with LocalState { state: 0 } handle {
            with MockConsole { last_printed: 0, read_value: 10 } handle {
                // Can use Error, State, and Console
                let val = perform Console.read();
                if val < 0 {
                    perform Error.raise(1);
                    // Unreachable after raise, but needed for type consistency
                    0
                } else {
                    perform State.put(val);
                    perform Console.print(val);
                    perform State.get()
                }
            }
        }
    }
}

// ===========================================================================
// 7. Pure Functions and Effect Annotations
// ===========================================================================

// Pure function - explicitly no effects
fn add(a: i32, b: i32) -> i32 / pure {
    a + b
}

// Another pure function
fn multiply(a: i32, b: i32) -> i32 / pure {
    a * b
}

// Function with inferred effects (when type checker supports it)
fn compute_sum(n: i32) -> i32 {
    let mut sum = 0;
    let mut i = 1;
    while i <= n {
        sum = sum + i;
        i = i + 1;
    }
    sum
}

// ===========================================================================
// 8. Practical Examples
// ===========================================================================

// Stateful computation: Fibonacci with state
fn fib_stateful() -> i32 / {State<i32>} {
    let n = perform State.get();
    if n <= 1 {
        n
    } else {
        let mut a = 0;
        let mut b = 1;
        let mut i = 2;
        while i <= n {
            let temp = a + b;
            a = b;
            b = temp;
            i = i + 1;
        }
        b
    }
}

// Compute Fibonacci using state effect
fn compute_fib(n: i32) -> i32 {
    with LocalState { state: n } handle {
        fib_stateful()
    }
}

// Range generator that can be collected
fn generate_squares(n: i32) -> () / {Yield<i32>} {
    let mut i = 1;
    while i <= n {
        perform Yield.yield_value(i * i);
        i = i + 1;
    }
}

// Sum all yielded values using the Accumulator handler
fn sum_squares(n: i32) -> i32 {
    with Accumulator { sum: 0, count: 0 } handle {
        generate_squares(n);
        0
    }
}

// ===========================================================================
// 9. Main Function
// ===========================================================================

fn main() {
    // Test basic state handling
    let result1 = with LocalState { state: 0 } handle {
        counter()
    };

    // Test triple increment
    let result2 = with LocalState { state: 0 } handle {
        triple_increment()
    };

    // Test nested handlers (inline to ensure effects are properly tracked)
    let result3 = with LocalState { state: 0 } handle {
        with MockConsole { last_printed: 0, read_value: 42 } handle {
            let x = perform State.get();
            perform Console.print(x);
            let y = perform Console.read();
            perform State.put(y);
            perform State.get()
        }
    };

    // Test pure functions (no effects needed)
    let sum = add(10, 20);
    let product = multiply(5, 6);

    // Test computing sum
    let total = compute_sum(10);

    // Test Fibonacci
    let fib_10 = compute_fib(10);

    // Print results (if we had actual console)
    println_int(result1);
    println_int(result2);
    println_int(result3);
    println_int(sum);
    println_int(product);
    println_int(total);
    println_int(fib_10);
}
