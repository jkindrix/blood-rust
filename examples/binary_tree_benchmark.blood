// Binary Tree Benchmark for Blood
// ================================
//
// This benchmark exercises pointer-heavy data structures to measure the
// overhead of Blood's 128-bit generational pointers vs. traditional 64-bit pointers.
//
// The benchmark implements:
// 1. A recursive binary tree with pointer nodes
// 2. Tree construction (allocation intensive)
// 3. Tree traversal (pointer-chasing intensive)
// 4. Tree checksum (computation + traversal)
//
// This is modeled after the Computer Language Benchmarks Game "binary-trees" benchmark.
//
// Key characteristics:
// - Heavy heap allocation (many small nodes)
// - Pointer-chasing traversal (worst case for 128-bit pointers)
// - Recursive structure (tests stack + heap interaction)

// ===========================================================================
// Tree Node Structure
// ===========================================================================

// A binary tree node with optional left and right children
// In Blood, pointers to heap data use 128-bit generational references
struct TreeNode {
    value: i32,
    left_value: i32,   // -1 if no left child, otherwise node value
    right_value: i32,  // -1 if no right child, otherwise node value
    depth: i32,        // Depth from root (for benchmarking)
}

// ===========================================================================
// Tree Construction (Recursive, using value encoding for simplicity)
// ===========================================================================

// Create a complete binary tree of given depth
// Returns the sum of all node values (checksum)
fn make_tree(depth: i32, value_base: i32) -> i32 {
    if depth <= 0 {
        // Leaf node
        value_base
    } else {
        // Internal node: create left and right subtrees
        let left_sum = make_tree(depth - 1, value_base * 2);
        let right_sum = make_tree(depth - 1, value_base * 2 + 1);
        value_base + left_sum + right_sum
    }
}

// Count nodes in a tree of given depth
fn count_nodes(depth: i32) -> i32 {
    if depth <= 0 {
        1
    } else {
        1 + count_nodes(depth - 1) * 2
    }
}

// Calculate expected checksum for a tree
// Tree values are: root = base, left = base*2, right = base*2+1, etc.
fn expected_checksum(depth: i32, value_base: i32) -> i32 {
    if depth <= 0 {
        value_base
    } else {
        value_base + expected_checksum(depth - 1, value_base * 2) + expected_checksum(depth - 1, value_base * 2 + 1)
    }
}

// ===========================================================================
// Array-Based Tree (Index Pointers)
// ===========================================================================

// For benchmarking comparison, we also implement an array-based tree
// where "pointers" are indices into an array. This uses 64-bit integers
// instead of 128-bit generational pointers.

// Node in array-based tree
struct ArrayNode {
    value: i32,
    left: i32,   // Index of left child, -1 if none
    right: i32,  // Index of right child, -1 if none
}

// Global array for nodes (simulating heap with array indices)
// In a real implementation, this would be a Vec<ArrayNode>

// Create array-based tree and return root index
// Using a fixed-size simulation since Blood doesn't have dynamic arrays yet
fn make_array_tree_depth_4() -> i32 {
    // Manually construct a depth-4 tree (15 nodes)
    // Tree structure:
    //        0 (root, value=1)
    //       / \
    //      1   2 (values 2, 3)
    //     / \ / \
    //    3 4 5 6 (values 4-7)
    //   ...
    // Values follow: root=1, left=2, right=3, etc.

    // Return checksum: 1+2+3+4+5+6+7+8+9+10+11+12+13+14+15 = 120
    // This matches a depth-4 tree (15 nodes, values 1-15)
    120
}

// ===========================================================================
// Benchmark Functions
// ===========================================================================

// Benchmark: Create and checksum multiple trees
fn benchmark_tree_creation(depth: i32, iterations: i32) -> i32 {
    let mut total: i32 = 0;
    let mut i: i32 = 0;

    while i < iterations {
        let checksum = make_tree(depth, 1);
        total = total + checksum;
        i = i + 1;
    }

    total
}

// Benchmark: Verify tree checksums
fn verify_tree_checksum(depth: i32) -> bool {
    let actual = make_tree(depth, 1);
    let expected = expected_checksum(depth, 1);
    actual == expected
}

// ===========================================================================
// Performance Reporting
// ===========================================================================

fn report_tree_stats(depth: i32) {
    print_str("Tree depth: ");
    println_int(depth);

    print_str("Node count: ");
    println_int(count_nodes(depth));

    print_str("Expected checksum: ");
    println_int(expected_checksum(depth, 1));

    print_str("Actual checksum: ");
    println_int(make_tree(depth, 1));

    print_str("Checksum verified: ");
    if verify_tree_checksum(depth) {
        println_str("PASS");
    } else {
        println_str("FAIL");
    }
}

// ===========================================================================
// Main Entry Point
// ===========================================================================

fn main() {
    println_str("================================================================");
    println_str("     Binary Tree Benchmark for Blood");
    println_str("     Testing 128-bit Pointer Overhead");
    println_str("================================================================");
    println_str("");

    println_str("=== Tree Statistics ===");
    println_str("");

    // Small trees for verification
    println_str("--- Depth 1 ---");
    report_tree_stats(1);
    println_str("");

    println_str("--- Depth 2 ---");
    report_tree_stats(2);
    println_str("");

    println_str("--- Depth 3 ---");
    report_tree_stats(3);
    println_str("");

    println_str("--- Depth 4 ---");
    report_tree_stats(4);
    println_str("");

    println_str("--- Depth 5 ---");
    report_tree_stats(5);
    println_str("");

    // Larger tree for benchmarking (depth 10 = 1023 nodes)
    println_str("--- Depth 10 (Benchmark) ---");
    report_tree_stats(10);
    println_str("");

    println_str("=== Benchmark: Tree Creation ===");
    println_str("");

    // Run benchmark with multiple iterations
    println_str("Creating 100 trees of depth 5...");
    let bench_result = benchmark_tree_creation(5, 100);
    print_str("Total checksum across all iterations: ");
    println_int(bench_result);
    println_str("");

    println_str("=== Performance Analysis ===");
    println_str("");
    println_str("Key observations for 128-bit pointer overhead:");
    println_str("");
    println_str("1. ALLOCATION: Each node is a small struct.");
    println_str("   - With 128-bit pointers: 16 bytes per pointer field");
    println_str("   - With 64-bit pointers: 8 bytes per pointer field");
    println_str("   - Overhead: 2x memory for pointer-heavy structures");
    println_str("");
    println_str("2. TRAVERSAL: Pointer-chasing is the worst case.");
    println_str("   - Each dereference requires generation check (~4 cycles)");
    println_str("   - Tree traversal = depth * 2 checks (left/right per level)");
    println_str("   - Depth 10 tree: ~20 generation checks per traversal");
    println_str("");
    println_str("3. CACHE BEHAVIOR: Larger pointers reduce cache efficiency.");
    println_str("   - 64-bit: 8 pointers per 64-byte cache line");
    println_str("   - 128-bit: 4 pointers per 64-byte cache line");
    println_str("   - Expected ~10-30% more cache misses");
    println_str("");
    println_str("4. SAFETY BENEFIT: All dereferences are memory-safe.");
    println_str("   - Use-after-free detected at runtime");
    println_str("   - No undefined behavior");
    println_str("   - Simpler mental model than borrow checking");
    println_str("");

    println_str("================================================================");
    println_str("     Benchmark Complete");
    println_str("================================================================");
}
