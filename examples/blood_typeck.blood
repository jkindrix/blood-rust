// Blood Type Checker in Blood
// Self-Hosting Milestone (REAL-V-011)
// Demonstrates: Generic programming, complex data structures, algebraic effects, trait bounds
//
// This type checker performs type inference and checking on Blood AST,
// proving that Blood can implement sophisticated type system logic.
//
// Features:
// - Hindley-Milner type inference with extensions
// - Generic type instantiation and substitution
// - Effect type tracking and inference
// - Trait bound verification
// - Type unification with occurs check

// ============================================================================
// Type Representation
// ============================================================================

/// Unique identifier for type variables
type TypeVarId = u64;

/// Unique identifier for effect variables
type EffectVarId = u64;

/// Core type representation in the type checker
#[derive(Clone, PartialEq, Eq)]
enum Ty {
    // Primitive types
    Unit,
    Bool,
    I8, I16, I32, I64, I128, Isize,
    U8, U16, U32, U64, U128, Usize,
    F32, F64,
    Char,
    Str,
    Never,

    // Type variable (for inference)
    Var(TypeVarId),

    // Named type with optional generic arguments
    Named {
        name: String,
        args: Vec<Ty>,
    },

    // Reference type
    Ref {
        mutable: bool,
        ty: Box<Ty>,
    },

    // Raw pointer type
    RawPtr {
        mutable: bool,
        ty: Box<Ty>,
    },

    // Slice type [T]
    Slice(Box<Ty>),

    // Array type [T; N]
    Array {
        ty: Box<Ty>,
        len: u64,
    },

    // Tuple type (A, B, C)
    Tuple(Vec<Ty>),

    // Function type
    Fn {
        params: Vec<Ty>,
        ret: Box<Ty>,
        effects: EffectSet,
    },

    // Generic type parameter
    Param {
        name: String,
        bounds: Vec<TraitRef>,
    },

    // Associated type projection: <T as Trait>::Assoc
    Projection {
        self_ty: Box<Ty>,
        trait_ref: TraitRef,
        assoc_name: String,
    },

    // Error type (for error recovery)
    Error,
}

/// Reference to a trait with generic arguments
#[derive(Clone, PartialEq, Eq)]
struct TraitRef {
    name: String,
    args: Vec<Ty>,
}

/// Set of effects (can contain effect variables for inference)
#[derive(Clone, PartialEq, Eq)]
struct EffectSet {
    effects: Vec<EffectRef>,
    var: Option<EffectVarId>,  // For effect inference
}

/// Reference to an effect
#[derive(Clone, PartialEq, Eq)]
struct EffectRef {
    name: String,
    args: Vec<Ty>,
}

impl EffectSet {
    fn empty() -> EffectSet {
        EffectSet { effects: Vec::new(), var: None }
    }

    fn singleton(effect: EffectRef) -> EffectSet {
        EffectSet { effects: vec![effect], var: None }
    }

    fn with_var(var: EffectVarId) -> EffectSet {
        EffectSet { effects: Vec::new(), var: Some(var) }
    }

    fn union(a: EffectSet, b: EffectSet) -> EffectSet {
        let mut effects = a.effects.clone();
        for e in b.effects.iter() {
            if !effects.contains(e) {
                effects.push(e.clone());
            }
        }
        // If either has a var, keep one (they should be unified)
        let var = a.var.or(b.var);
        EffectSet { effects, var }
    }

    fn contains(self: &EffectSet, effect: &EffectRef) -> bool {
        self.effects.iter().any(|e| e == effect)
    }
}

// ============================================================================
// Type Scheme (Polymorphic Types)
// ============================================================================

/// A polymorphic type with quantified type variables
struct TypeScheme {
    /// Type variables bound in this scheme
    type_vars: Vec<TypeVarId>,
    /// Effect variables bound in this scheme
    effect_vars: Vec<EffectVarId>,
    /// The underlying type
    ty: Ty,
}

impl TypeScheme {
    /// Create a monomorphic scheme (no quantified variables)
    fn mono(ty: Ty) -> TypeScheme {
        TypeScheme {
            type_vars: Vec::new(),
            effect_vars: Vec::new(),
            ty,
        }
    }
}

// ============================================================================
// Type Context / Environment
// ============================================================================

/// Entry in the type environment
struct TypeEnvEntry {
    name: String,
    scheme: TypeScheme,
}

/// Type environment mapping names to type schemes
struct TypeEnv {
    entries: Vec<TypeEnvEntry>,
    /// Parent environment for lexical scoping
    parent: Option<Box<TypeEnv>>,
}

impl TypeEnv {
    fn new() -> TypeEnv {
        TypeEnv { entries: Vec::new(), parent: None }
    }

    fn with_parent(parent: TypeEnv) -> TypeEnv {
        TypeEnv {
            entries: Vec::new(),
            parent: Some(Box::new(parent)),
        }
    }

    fn insert(self: &mut TypeEnv, name: String, scheme: TypeScheme) {
        self.entries.push(TypeEnvEntry { name, scheme });
    }

    fn lookup(self: &TypeEnv, name: &str) -> Option<&TypeScheme> {
        // Search local entries first
        for entry in self.entries.iter().rev() {
            if entry.name == name {
                return Some(&entry.scheme);
            }
        }
        // Then search parent
        match &self.parent {
            Some(parent) => parent.lookup(name),
            None => None,
        }
    }
}

// ============================================================================
// Type Definitions Context
// ============================================================================

/// Struct definition in the type context
struct StructDef {
    name: String,
    type_params: Vec<String>,
    fields: Vec<FieldDef>,
}

struct FieldDef {
    name: String,
    ty: Ty,
}

/// Enum definition in the type context
struct EnumDef {
    name: String,
    type_params: Vec<String>,
    variants: Vec<VariantDef>,
}

struct VariantDef {
    name: String,
    fields: Vec<FieldDef>,
}

/// Trait definition
struct TraitDef {
    name: String,
    type_params: Vec<String>,
    super_traits: Vec<TraitRef>,
    methods: Vec<MethodSig>,
    assoc_types: Vec<AssocTypeDef>,
}

struct MethodSig {
    name: String,
    type_params: Vec<String>,
    params: Vec<Ty>,
    ret: Ty,
    effects: EffectSet,
}

struct AssocTypeDef {
    name: String,
    bounds: Vec<TraitRef>,
}

/// Effect definition
struct EffectDef {
    name: String,
    type_params: Vec<String>,
    operations: Vec<OperationSig>,
}

struct OperationSig {
    name: String,
    params: Vec<Ty>,
    ret: Ty,
}

/// Impl block
struct ImplDef {
    type_params: Vec<String>,
    trait_ref: Option<TraitRef>,
    self_ty: Ty,
    methods: Vec<MethodImpl>,
    assoc_types: Vec<AssocTypeImpl>,
}

struct MethodImpl {
    name: String,
    scheme: TypeScheme,
}

struct AssocTypeImpl {
    name: String,
    ty: Ty,
}

/// Global type definitions context
struct TypeDefs {
    structs: Vec<StructDef>,
    enums: Vec<EnumDef>,
    traits: Vec<TraitDef>,
    effects: Vec<EffectDef>,
    impls: Vec<ImplDef>,
}

impl TypeDefs {
    fn new() -> TypeDefs {
        TypeDefs {
            structs: Vec::new(),
            enums: Vec::new(),
            traits: Vec::new(),
            effects: Vec::new(),
            impls: Vec::new(),
        }
    }

    fn find_struct(self: &TypeDefs, name: &str) -> Option<&StructDef> {
        self.structs.iter().find(|s| s.name == name)
    }

    fn find_enum(self: &TypeDefs, name: &str) -> Option<&EnumDef> {
        self.enums.iter().find(|e| e.name == name)
    }

    fn find_trait(self: &TypeDefs, name: &str) -> Option<&TraitDef> {
        self.traits.iter().find(|t| t.name == name)
    }

    fn find_effect(self: &TypeDefs, name: &str) -> Option<&EffectDef> {
        self.effects.iter().find(|e| e.name == name)
    }
}

// ============================================================================
// Substitution
// ============================================================================

/// Mapping from type variables to types
struct Substitution {
    type_map: Vec<(TypeVarId, Ty)>,
    effect_map: Vec<(EffectVarId, EffectSet)>,
}

impl Substitution {
    fn empty() -> Substitution {
        Substitution {
            type_map: Vec::new(),
            effect_map: Vec::new(),
        }
    }

    fn bind_type(self: &mut Substitution, var: TypeVarId, ty: Ty) {
        self.type_map.push((var, ty));
    }

    fn bind_effect(self: &mut Substitution, var: EffectVarId, effects: EffectSet) {
        self.effect_map.push((var, effects));
    }

    fn lookup_type(self: &Substitution, var: TypeVarId) -> Option<&Ty> {
        self.type_map.iter().rev()
            .find(|(v, _)| *v == var)
            .map(|(_, ty)| ty)
    }

    fn lookup_effect(self: &Substitution, var: EffectVarId) -> Option<&EffectSet> {
        self.effect_map.iter().rev()
            .find(|(v, _)| *v == var)
            .map(|(_, es)| es)
    }

    /// Apply substitution to a type
    fn apply_to_type(self: &Substitution, ty: &Ty) -> Ty {
        match ty {
            Ty::Var(var) => {
                match self.lookup_type(*var) {
                    Some(t) => self.apply_to_type(t),
                    None => ty.clone(),
                }
            }
            Ty::Named { name, args } => {
                Ty::Named {
                    name: name.clone(),
                    args: args.iter().map(|a| self.apply_to_type(a)).collect(),
                }
            }
            Ty::Ref { mutable, ty: inner } => {
                Ty::Ref {
                    mutable: *mutable,
                    ty: Box::new(self.apply_to_type(inner)),
                }
            }
            Ty::RawPtr { mutable, ty: inner } => {
                Ty::RawPtr {
                    mutable: *mutable,
                    ty: Box::new(self.apply_to_type(inner)),
                }
            }
            Ty::Slice(inner) => {
                Ty::Slice(Box::new(self.apply_to_type(inner)))
            }
            Ty::Array { ty: inner, len } => {
                Ty::Array {
                    ty: Box::new(self.apply_to_type(inner)),
                    len: *len,
                }
            }
            Ty::Tuple(elems) => {
                Ty::Tuple(elems.iter().map(|e| self.apply_to_type(e)).collect())
            }
            Ty::Fn { params, ret, effects } => {
                Ty::Fn {
                    params: params.iter().map(|p| self.apply_to_type(p)).collect(),
                    ret: Box::new(self.apply_to_type(ret)),
                    effects: self.apply_to_effects(effects),
                }
            }
            Ty::Param { name, bounds } => {
                Ty::Param {
                    name: name.clone(),
                    bounds: bounds.iter().map(|b| self.apply_to_trait_ref(b)).collect(),
                }
            }
            Ty::Projection { self_ty, trait_ref, assoc_name } => {
                Ty::Projection {
                    self_ty: Box::new(self.apply_to_type(self_ty)),
                    trait_ref: self.apply_to_trait_ref(trait_ref),
                    assoc_name: assoc_name.clone(),
                }
            }
            // Primitives and error don't change
            _ => ty.clone(),
        }
    }

    fn apply_to_trait_ref(self: &Substitution, tr: &TraitRef) -> TraitRef {
        TraitRef {
            name: tr.name.clone(),
            args: tr.args.iter().map(|a| self.apply_to_type(a)).collect(),
        }
    }

    fn apply_to_effects(self: &Substitution, effects: &EffectSet) -> EffectSet {
        let applied_effects: Vec<EffectRef> = effects.effects.iter()
            .map(|e| EffectRef {
                name: e.name.clone(),
                args: e.args.iter().map(|a| self.apply_to_type(a)).collect(),
            })
            .collect();

        match effects.var {
            Some(var) => {
                match self.lookup_effect(var) {
                    Some(resolved) => {
                        EffectSet::union(
                            EffectSet { effects: applied_effects, var: None },
                            resolved.clone(),
                        )
                    }
                    None => {
                        EffectSet { effects: applied_effects, var: Some(var) }
                    }
                }
            }
            None => EffectSet { effects: applied_effects, var: None }
        }
    }

    /// Compose two substitutions: apply self first, then other
    fn compose(self: &Substitution, other: &Substitution) -> Substitution {
        let mut result = Substitution::empty();

        // Apply other to all bindings in self
        for (var, ty) in self.type_map.iter() {
            result.bind_type(*var, other.apply_to_type(ty));
        }

        // Add bindings from other that aren't in self
        for (var, ty) in other.type_map.iter() {
            if self.lookup_type(*var).is_none() {
                result.bind_type(*var, ty.clone());
            }
        }

        // Same for effect variables
        for (var, effects) in self.effect_map.iter() {
            result.bind_effect(*var, other.apply_to_effects(effects));
        }

        for (var, effects) in other.effect_map.iter() {
            if self.lookup_effect(*var).is_none() {
                result.bind_effect(*var, effects.clone());
            }
        }

        result
    }
}

// ============================================================================
// Type Checking Effects (for diagnostics)
// ============================================================================

/// Source location for error reporting
#[derive(Clone, Copy)]
struct Span {
    start_line: u32,
    start_col: u32,
    end_line: u32,
    end_col: u32,
}

/// Type error kinds
enum TypeError {
    /// Type mismatch: expected A, found B
    Mismatch {
        expected: Ty,
        found: Ty,
        span: Span,
    },

    /// Occurs check failure (infinite type)
    OccursCheck {
        var: TypeVarId,
        ty: Ty,
        span: Span,
    },

    /// Unbound variable reference
    UnboundVariable {
        name: String,
        span: Span,
    },

    /// Unbound type reference
    UnboundType {
        name: String,
        span: Span,
    },

    /// Wrong number of type arguments
    ArityMismatch {
        name: String,
        expected: usize,
        found: usize,
        span: Span,
    },

    /// Unhandled effect
    UnhandledEffect {
        effect: EffectRef,
        span: Span,
    },

    /// Missing trait implementation
    MissingImpl {
        ty: Ty,
        trait_name: String,
        span: Span,
    },

    /// Field not found in struct
    FieldNotFound {
        ty: Ty,
        field: String,
        span: Span,
    },

    /// Method not found
    MethodNotFound {
        ty: Ty,
        method: String,
        span: Span,
    },

    /// Invalid pattern for type
    PatternMismatch {
        expected_ty: Ty,
        pattern_kind: String,
        span: Span,
    },
}

/// Type checking diagnostics effect
effect TypeDiag {
    op error(err: TypeError);
    op warning(msg: String, span: Span);
}

// ============================================================================
// Type Checker State
// ============================================================================

/// Mutable state for the type checker
struct TypeChecker {
    /// Next fresh type variable ID
    next_type_var: TypeVarId,
    /// Next fresh effect variable ID
    next_effect_var: EffectVarId,
    /// Current substitution
    subst: Substitution,
    /// Type definitions
    defs: TypeDefs,
}

impl TypeChecker {
    fn new(defs: TypeDefs) -> TypeChecker {
        TypeChecker {
            next_type_var: 0,
            next_effect_var: 0,
            subst: Substitution::empty(),
            defs,
        }
    }

    /// Generate a fresh type variable
    fn fresh_type_var(self: &mut TypeChecker) -> Ty {
        let id = self.next_type_var;
        self.next_type_var += 1;
        Ty::Var(id)
    }

    /// Generate a fresh effect variable
    fn fresh_effect_var(self: &mut TypeChecker) -> EffectSet {
        let id = self.next_effect_var;
        self.next_effect_var += 1;
        EffectSet::with_var(id)
    }

    /// Apply current substitution to a type
    fn apply(self: &TypeChecker, ty: &Ty) -> Ty {
        self.subst.apply_to_type(ty)
    }

    /// Apply current substitution to effects
    fn apply_effects(self: &TypeChecker, effects: &EffectSet) -> EffectSet {
        self.subst.apply_to_effects(effects)
    }
}

// ============================================================================
// Unification
// ============================================================================

/// Unify two types, updating the substitution
fn unify(tc: &mut TypeChecker, ty1: &Ty, ty2: &Ty, span: Span) / {TypeDiag} {
    let t1 = tc.apply(ty1);
    let t2 = tc.apply(ty2);

    match (&t1, &t2) {
        // Same types unify trivially
        (Ty::Unit, Ty::Unit) => {}
        (Ty::Bool, Ty::Bool) => {}
        (Ty::I8, Ty::I8) => {}
        (Ty::I16, Ty::I16) => {}
        (Ty::I32, Ty::I32) => {}
        (Ty::I64, Ty::I64) => {}
        (Ty::I128, Ty::I128) => {}
        (Ty::Isize, Ty::Isize) => {}
        (Ty::U8, Ty::U8) => {}
        (Ty::U16, Ty::U16) => {}
        (Ty::U32, Ty::U32) => {}
        (Ty::U64, Ty::U64) => {}
        (Ty::U128, Ty::U128) => {}
        (Ty::Usize, Ty::Usize) => {}
        (Ty::F32, Ty::F32) => {}
        (Ty::F64, Ty::F64) => {}
        (Ty::Char, Ty::Char) => {}
        (Ty::Str, Ty::Str) => {}
        (Ty::Never, Ty::Never) => {}
        (Ty::Error, _) => {}
        (_, Ty::Error) => {}

        // Type variable binds to type (with occurs check)
        (Ty::Var(var), ty) => {
            if occurs_check(*var, ty) {
                do TypeDiag.error(TypeError::OccursCheck {
                    var: *var,
                    ty: ty.clone(),
                    span,
                });
            } else {
                tc.subst.bind_type(*var, ty.clone());
            }
        }
        (ty, Ty::Var(var)) => {
            if occurs_check(*var, ty) {
                do TypeDiag.error(TypeError::OccursCheck {
                    var: *var,
                    ty: ty.clone(),
                    span,
                });
            } else {
                tc.subst.bind_type(*var, ty.clone());
            }
        }

        // Named types must match name and unify arguments
        (Ty::Named { name: n1, args: a1 }, Ty::Named { name: n2, args: a2 }) => {
            if n1 != n2 {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            } else if a1.len() != a2.len() {
                do TypeDiag.error(TypeError::ArityMismatch {
                    name: n1.clone(),
                    expected: a1.len(),
                    found: a2.len(),
                    span,
                });
            } else {
                for i in 0..a1.len() {
                    unify(tc, &a1[i], &a2[i], span);
                }
            }
        }

        // References must match mutability and unify inner types
        (Ty::Ref { mutable: m1, ty: inner1 }, Ty::Ref { mutable: m2, ty: inner2 }) => {
            if m1 != m2 {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            } else {
                unify(tc, inner1, inner2, span);
            }
        }

        // Raw pointers similar to references
        (Ty::RawPtr { mutable: m1, ty: inner1 }, Ty::RawPtr { mutable: m2, ty: inner2 }) => {
            if m1 != m2 {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            } else {
                unify(tc, inner1, inner2, span);
            }
        }

        // Slices unify inner types
        (Ty::Slice(inner1), Ty::Slice(inner2)) => {
            unify(tc, inner1, inner2, span);
        }

        // Arrays must match size and unify inner types
        (Ty::Array { ty: inner1, len: len1 }, Ty::Array { ty: inner2, len: len2 }) => {
            if len1 != len2 {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            } else {
                unify(tc, inner1, inner2, span);
            }
        }

        // Tuples must match arity and unify element-wise
        (Ty::Tuple(elems1), Ty::Tuple(elems2)) => {
            if elems1.len() != elems2.len() {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            } else {
                for i in 0..elems1.len() {
                    unify(tc, &elems1[i], &elems2[i], span);
                }
            }
        }

        // Function types must unify params, return, and effects
        (Ty::Fn { params: p1, ret: r1, effects: e1 },
         Ty::Fn { params: p2, ret: r2, effects: e2 }) => {
            if p1.len() != p2.len() {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            } else {
                for i in 0..p1.len() {
                    unify(tc, &p1[i], &p2[i], span);
                }
                unify(tc, r1, r2, span);
                unify_effects(tc, e1, e2, span);
            }
        }

        // Type parameters unify by name
        (Ty::Param { name: n1, .. }, Ty::Param { name: n2, .. }) => {
            if n1 != n2 {
                do TypeDiag.error(TypeError::Mismatch {
                    expected: t1.clone(),
                    found: t2.clone(),
                    span,
                });
            }
        }

        // Never type coerces to anything
        (Ty::Never, _) => {}
        (_, Ty::Never) => {}

        // Default: type mismatch
        _ => {
            do TypeDiag.error(TypeError::Mismatch {
                expected: t1.clone(),
                found: t2.clone(),
                span,
            });
        }
    }
}

/// Check if type variable occurs in type (prevents infinite types)
fn occurs_check(var: TypeVarId, ty: &Ty) -> bool {
    match ty {
        Ty::Var(v) => *v == var,
        Ty::Named { args, .. } => args.iter().any(|a| occurs_check(var, a)),
        Ty::Ref { ty: inner, .. } => occurs_check(var, inner),
        Ty::RawPtr { ty: inner, .. } => occurs_check(var, inner),
        Ty::Slice(inner) => occurs_check(var, inner),
        Ty::Array { ty: inner, .. } => occurs_check(var, inner),
        Ty::Tuple(elems) => elems.iter().any(|e| occurs_check(var, e)),
        Ty::Fn { params, ret, .. } => {
            params.iter().any(|p| occurs_check(var, p)) || occurs_check(var, ret)
        }
        Ty::Param { bounds, .. } => {
            bounds.iter().any(|b| b.args.iter().any(|a| occurs_check(var, a)))
        }
        Ty::Projection { self_ty, trait_ref, .. } => {
            occurs_check(var, self_ty) ||
            trait_ref.args.iter().any(|a| occurs_check(var, a))
        }
        _ => false,
    }
}

/// Unify effect sets
fn unify_effects(tc: &mut TypeChecker, e1: &EffectSet, e2: &EffectSet, span: Span) / {TypeDiag} {
    let eff1 = tc.apply_effects(e1);
    let eff2 = tc.apply_effects(e2);

    // If either has a variable, bind it to the union
    match (eff1.var, eff2.var) {
        (Some(v1), Some(v2)) if v1 == v2 => {
            // Same variable, effects must be compatible
        }
        (Some(v1), _) => {
            tc.subst.bind_effect(v1, eff2.clone());
        }
        (_, Some(v2)) => {
            tc.subst.bind_effect(v2, eff1.clone());
        }
        (None, None) => {
            // Concrete effect sets - verify e2 is subset of e1 (or equal)
            for effect in eff2.effects.iter() {
                if !eff1.contains(effect) {
                    do TypeDiag.error(TypeError::UnhandledEffect {
                        effect: effect.clone(),
                        span,
                    });
                }
            }
        }
    }
}

// ============================================================================
// Type Instantiation
// ============================================================================

/// Instantiate a type scheme with fresh type variables
fn instantiate(tc: &mut TypeChecker, scheme: &TypeScheme) -> Ty {
    let mut subst = Substitution::empty();

    // Create fresh variables for all quantified type variables
    for var in scheme.type_vars.iter() {
        let fresh = tc.fresh_type_var();
        subst.bind_type(*var, fresh);
    }

    // Create fresh effect variables
    for var in scheme.effect_vars.iter() {
        let fresh = tc.fresh_effect_var();
        subst.bind_effect(*var, fresh);
    }

    subst.apply_to_type(&scheme.ty)
}

/// Generalize a type to a scheme by quantifying free variables
fn generalize(env: &TypeEnv, tc: &TypeChecker, ty: &Ty) -> TypeScheme {
    let ty = tc.apply(ty);
    let free_vars = free_type_vars(&ty);
    let env_vars = env_free_vars(env);

    // Quantify variables that are free in ty but not in env
    let type_vars: Vec<TypeVarId> = free_vars.iter()
        .filter(|v| !env_vars.contains(v))
        .cloned()
        .collect();

    TypeScheme {
        type_vars,
        effect_vars: Vec::new(),  // Simplified: not quantifying effect vars
        ty,
    }
}

/// Collect free type variables in a type
fn free_type_vars(ty: &Ty) -> Vec<TypeVarId> {
    let mut vars = Vec::new();
    collect_free_vars(ty, &mut vars);
    vars
}

fn collect_free_vars(ty: &Ty, vars: &mut Vec<TypeVarId>) {
    match ty {
        Ty::Var(var) => {
            if !vars.contains(var) {
                vars.push(*var);
            }
        }
        Ty::Named { args, .. } => {
            for arg in args.iter() {
                collect_free_vars(arg, vars);
            }
        }
        Ty::Ref { ty: inner, .. } => collect_free_vars(inner, vars),
        Ty::RawPtr { ty: inner, .. } => collect_free_vars(inner, vars),
        Ty::Slice(inner) => collect_free_vars(inner, vars),
        Ty::Array { ty: inner, .. } => collect_free_vars(inner, vars),
        Ty::Tuple(elems) => {
            for elem in elems.iter() {
                collect_free_vars(elem, vars);
            }
        }
        Ty::Fn { params, ret, .. } => {
            for param in params.iter() {
                collect_free_vars(param, vars);
            }
            collect_free_vars(ret, vars);
        }
        _ => {}
    }
}

fn env_free_vars(env: &TypeEnv) -> Vec<TypeVarId> {
    let mut vars = Vec::new();
    for entry in env.entries.iter() {
        collect_free_vars(&entry.scheme.ty, &mut vars);
    }
    if let Some(parent) = &env.parent {
        let parent_vars = env_free_vars(parent);
        for v in parent_vars.iter() {
            if !vars.contains(v) {
                vars.push(*v);
            }
        }
    }
    vars
}

// ============================================================================
// Expression Type Inference
// ============================================================================

/// Simplified expression for type checking demonstration
enum Expr {
    // Literals
    IntLit(i64),
    FloatLit(f64),
    BoolLit(bool),
    StringLit(String),
    UnitLit,

    // Variable reference
    Var(String),

    // Binary operation
    BinOp {
        op: BinOpKind,
        left: Box<Expr>,
        right: Box<Expr>,
    },

    // Unary operation
    UnaryOp {
        op: UnaryOpKind,
        expr: Box<Expr>,
    },

    // If expression
    If {
        cond: Box<Expr>,
        then_branch: Box<Expr>,
        else_branch: Option<Box<Expr>>,
    },

    // Let binding
    Let {
        name: String,
        ty_annot: Option<Ty>,
        init: Box<Expr>,
        body: Box<Expr>,
    },

    // Function application
    App {
        func: Box<Expr>,
        args: Vec<Expr>,
    },

    // Lambda abstraction
    Lambda {
        params: Vec<(String, Option<Ty>)>,
        body: Box<Expr>,
    },

    // Struct construction
    Struct {
        name: String,
        fields: Vec<(String, Expr)>,
    },

    // Field access
    Field {
        expr: Box<Expr>,
        field: String,
    },

    // Match expression
    Match {
        scrutinee: Box<Expr>,
        arms: Vec<MatchArm>,
    },

    // Tuple construction
    Tuple(Vec<Expr>),

    // Array construction
    Array(Vec<Expr>),

    // Effect operation
    Do {
        effect: String,
        operation: String,
        args: Vec<Expr>,
    },

    // Block expression
    Block(Vec<Stmt>),
}

enum BinOpKind {
    Add, Sub, Mul, Div, Mod,
    Eq, Ne, Lt, Le, Gt, Ge,
    And, Or,
}

enum UnaryOpKind {
    Neg, Not, Ref, Deref,
}

struct MatchArm {
    pattern: Pattern,
    guard: Option<Box<Expr>>,
    body: Expr,
}

enum Pattern {
    Wildcard,
    Var(String),
    Literal(LitPattern),
    Tuple(Vec<Pattern>),
    Struct { name: String, fields: Vec<(String, Pattern)> },
    Enum { name: String, variant: String, fields: Vec<Pattern> },
}

enum LitPattern {
    Int(i64),
    Bool(bool),
    String(String),
}

enum Stmt {
    Expr(Expr),
    Let {
        name: String,
        ty_annot: Option<Ty>,
        init: Expr,
    },
}

/// Infer the type of an expression
fn infer_expr(
    tc: &mut TypeChecker,
    env: &TypeEnv,
    expr: &Expr,
    span: Span,
) -> Ty / {TypeDiag} {
    match expr {
        // Literals have known types
        Expr::IntLit(_) => Ty::I64,
        Expr::FloatLit(_) => Ty::F64,
        Expr::BoolLit(_) => Ty::Bool,
        Expr::StringLit(_) => Ty::Named { name: "String".to_string(), args: Vec::new() },
        Expr::UnitLit => Ty::Unit,

        // Variable lookup
        Expr::Var(name) => {
            match env.lookup(name) {
                Some(scheme) => instantiate(tc, scheme),
                None => {
                    do TypeDiag.error(TypeError::UnboundVariable {
                        name: name.clone(),
                        span,
                    });
                    Ty::Error
                }
            }
        }

        // Binary operations
        Expr::BinOp { op, left, right } => {
            let left_ty = infer_expr(tc, env, left, span);
            let right_ty = infer_expr(tc, env, right, span);

            match op {
                BinOpKind::Add | BinOpKind::Sub | BinOpKind::Mul |
                BinOpKind::Div | BinOpKind::Mod => {
                    // Numeric operations: both operands must be same numeric type
                    unify(tc, &left_ty, &right_ty, span);
                    left_ty
                }
                BinOpKind::Eq | BinOpKind::Ne | BinOpKind::Lt |
                BinOpKind::Le | BinOpKind::Gt | BinOpKind::Ge => {
                    // Comparison: operands must match, result is bool
                    unify(tc, &left_ty, &right_ty, span);
                    Ty::Bool
                }
                BinOpKind::And | BinOpKind::Or => {
                    // Logical: both must be bool
                    unify(tc, &left_ty, &Ty::Bool, span);
                    unify(tc, &right_ty, &Ty::Bool, span);
                    Ty::Bool
                }
            }
        }

        // Unary operations
        Expr::UnaryOp { op, expr: inner } => {
            let inner_ty = infer_expr(tc, env, inner, span);

            match op {
                UnaryOpKind::Neg => {
                    // Negation preserves type (must be numeric)
                    inner_ty
                }
                UnaryOpKind::Not => {
                    // Logical not requires bool
                    unify(tc, &inner_ty, &Ty::Bool, span);
                    Ty::Bool
                }
                UnaryOpKind::Ref => {
                    // Reference creates &T
                    Ty::Ref { mutable: false, ty: Box::new(inner_ty) }
                }
                UnaryOpKind::Deref => {
                    // Dereference requires reference, returns inner type
                    let result = tc.fresh_type_var();
                    let ref_ty = Ty::Ref { mutable: false, ty: Box::new(result.clone()) };
                    unify(tc, &inner_ty, &ref_ty, span);
                    result
                }
            }
        }

        // If expression
        Expr::If { cond, then_branch, else_branch } => {
            let cond_ty = infer_expr(tc, env, cond, span);
            unify(tc, &cond_ty, &Ty::Bool, span);

            let then_ty = infer_expr(tc, env, then_branch, span);

            match else_branch {
                Some(else_expr) => {
                    let else_ty = infer_expr(tc, env, else_expr, span);
                    unify(tc, &then_ty, &else_ty, span);
                    then_ty
                }
                None => {
                    // No else branch: then branch must be unit
                    unify(tc, &then_ty, &Ty::Unit, span);
                    Ty::Unit
                }
            }
        }

        // Let binding
        Expr::Let { name, ty_annot, init, body } => {
            let init_ty = infer_expr(tc, env, init, span);

            // If type annotation provided, unify with inferred type
            let bound_ty = match ty_annot {
                Some(annot) => {
                    unify(tc, &init_ty, annot, span);
                    annot.clone()
                }
                None => init_ty,
            };

            // Generalize and add to environment
            let scheme = generalize(env, tc, &bound_ty);
            let mut new_env = TypeEnv::with_parent(env.clone());
            new_env.insert(name.clone(), scheme);

            infer_expr(tc, &new_env, body, span)
        }

        // Function application
        Expr::App { func, args } => {
            let func_ty = infer_expr(tc, env, func, span);
            let arg_tys: Vec<Ty> = args.iter()
                .map(|a| infer_expr(tc, env, a, span))
                .collect();

            // Create expected function type with fresh result variable
            let result_ty = tc.fresh_type_var();
            let expected_fn = Ty::Fn {
                params: arg_tys,
                ret: Box::new(result_ty.clone()),
                effects: tc.fresh_effect_var(),
            };

            unify(tc, &func_ty, &expected_fn, span);
            result_ty
        }

        // Lambda abstraction
        Expr::Lambda { params, body } => {
            let mut new_env = TypeEnv::with_parent(env.clone());
            let mut param_tys = Vec::new();

            for (name, ty_annot) in params.iter() {
                let param_ty = match ty_annot {
                    Some(ty) => ty.clone(),
                    None => tc.fresh_type_var(),
                };
                new_env.insert(name.clone(), TypeScheme::mono(param_ty.clone()));
                param_tys.push(param_ty);
            }

            let body_ty = infer_expr(tc, &new_env, body, span);

            Ty::Fn {
                params: param_tys,
                ret: Box::new(body_ty),
                effects: EffectSet::empty(),
            }
        }

        // Struct construction
        Expr::Struct { name, fields } => {
            match tc.defs.find_struct(name) {
                Some(struct_def) => {
                    // Create type arguments (fresh vars if generic)
                    let type_args: Vec<Ty> = struct_def.type_params.iter()
                        .map(|_| tc.fresh_type_var())
                        .collect();

                    // Build substitution from type params to args
                    let mut param_subst = Substitution::empty();
                    for (i, param) in struct_def.type_params.iter().enumerate() {
                        // Map param name to type arg
                        let param_ty = Ty::Param { name: param.clone(), bounds: Vec::new() };
                        if let Ty::Var(var) = type_args[i] {
                            param_subst.bind_type(var, param_ty);
                        }
                    }

                    // Check each field
                    for (field_name, field_expr) in fields.iter() {
                        let expr_ty = infer_expr(tc, env, field_expr, span);

                        // Find field definition
                        match struct_def.fields.iter().find(|f| &f.name == field_name) {
                            Some(field_def) => {
                                let expected = param_subst.apply_to_type(&field_def.ty);
                                unify(tc, &expr_ty, &expected, span);
                            }
                            None => {
                                let struct_ty = Ty::Named {
                                    name: name.clone(),
                                    args: type_args.clone(),
                                };
                                do TypeDiag.error(TypeError::FieldNotFound {
                                    ty: struct_ty,
                                    field: field_name.clone(),
                                    span,
                                });
                            }
                        }
                    }

                    Ty::Named { name: name.clone(), args: type_args }
                }
                None => {
                    do TypeDiag.error(TypeError::UnboundType {
                        name: name.clone(),
                        span,
                    });
                    Ty::Error
                }
            }
        }

        // Field access
        Expr::Field { expr: receiver, field } => {
            let receiver_ty = infer_expr(tc, env, receiver, span);
            let resolved = tc.apply(&receiver_ty);

            match &resolved {
                Ty::Named { name, args } => {
                    match tc.defs.find_struct(name) {
                        Some(struct_def) => {
                            match struct_def.fields.iter().find(|f| &f.name == field) {
                                Some(field_def) => {
                                    // Substitute type params with actual args
                                    let mut subst = Substitution::empty();
                                    for (i, param) in struct_def.type_params.iter().enumerate() {
                                        if i < args.len() {
                                            // Create binding
                                            let var = tc.fresh_type_var();
                                            if let Ty::Var(v) = var {
                                                subst.bind_type(v, args[i].clone());
                                            }
                                        }
                                    }
                                    subst.apply_to_type(&field_def.ty)
                                }
                                None => {
                                    do TypeDiag.error(TypeError::FieldNotFound {
                                        ty: resolved.clone(),
                                        field: field.clone(),
                                        span,
                                    });
                                    Ty::Error
                                }
                            }
                        }
                        None => {
                            do TypeDiag.error(TypeError::FieldNotFound {
                                ty: resolved.clone(),
                                field: field.clone(),
                                span,
                            });
                            Ty::Error
                        }
                    }
                }
                Ty::Tuple(elems) => {
                    // Tuple field access by index (0, 1, 2, ...)
                    match field.parse::<usize>() {
                        Ok(idx) if idx < elems.len() => elems[idx].clone(),
                        _ => {
                            do TypeDiag.error(TypeError::FieldNotFound {
                                ty: resolved.clone(),
                                field: field.clone(),
                                span,
                            });
                            Ty::Error
                        }
                    }
                }
                _ => {
                    do TypeDiag.error(TypeError::FieldNotFound {
                        ty: resolved.clone(),
                        field: field.clone(),
                        span,
                    });
                    Ty::Error
                }
            }
        }

        // Match expression
        Expr::Match { scrutinee, arms } => {
            let scrutinee_ty = infer_expr(tc, env, scrutinee, span);
            let result_ty = tc.fresh_type_var();

            for arm in arms.iter() {
                // Check pattern and get bindings
                let bindings = check_pattern(tc, &arm.pattern, &scrutinee_ty, span);

                // Extend environment with pattern bindings
                let mut arm_env = TypeEnv::with_parent(env.clone());
                for (name, ty) in bindings.iter() {
                    arm_env.insert(name.clone(), TypeScheme::mono(ty.clone()));
                }

                // Check guard if present
                if let Some(guard) = &arm.guard {
                    let guard_ty = infer_expr(tc, &arm_env, guard, span);
                    unify(tc, &guard_ty, &Ty::Bool, span);
                }

                // Infer body and unify with result
                let body_ty = infer_expr(tc, &arm_env, &arm.body, span);
                unify(tc, &body_ty, &result_ty, span);
            }

            result_ty
        }

        // Tuple construction
        Expr::Tuple(elems) => {
            let elem_tys: Vec<Ty> = elems.iter()
                .map(|e| infer_expr(tc, env, e, span))
                .collect();
            Ty::Tuple(elem_tys)
        }

        // Array construction
        Expr::Array(elems) => {
            if elems.is_empty() {
                let elem_ty = tc.fresh_type_var();
                Ty::Array { ty: Box::new(elem_ty), len: 0 }
            } else {
                let first_ty = infer_expr(tc, env, &elems[0], span);
                for elem in elems.iter().skip(1) {
                    let elem_ty = infer_expr(tc, env, elem, span);
                    unify(tc, &first_ty, &elem_ty, span);
                }
                Ty::Array {
                    ty: Box::new(first_ty),
                    len: elems.len() as u64,
                }
            }
        }

        // Effect operation
        Expr::Do { effect, operation, args } => {
            match tc.defs.find_effect(effect) {
                Some(effect_def) => {
                    match effect_def.operations.iter().find(|op| &op.name == operation) {
                        Some(op_sig) => {
                            // Check argument count
                            if args.len() != op_sig.params.len() {
                                do TypeDiag.error(TypeError::ArityMismatch {
                                    name: format!("{}.{}", effect, operation),
                                    expected: op_sig.params.len(),
                                    found: args.len(),
                                    span,
                                });
                                return Ty::Error;
                            }

                            // Check argument types
                            for (i, arg) in args.iter().enumerate() {
                                let arg_ty = infer_expr(tc, env, arg, span);
                                unify(tc, &arg_ty, &op_sig.params[i], span);
                            }

                            op_sig.ret.clone()
                        }
                        None => {
                            do TypeDiag.error(TypeError::MethodNotFound {
                                ty: Ty::Named {
                                    name: effect.clone(),
                                    args: Vec::new(),
                                },
                                method: operation.clone(),
                                span,
                            });
                            Ty::Error
                        }
                    }
                }
                None => {
                    do TypeDiag.error(TypeError::UnboundType {
                        name: effect.clone(),
                        span,
                    });
                    Ty::Error
                }
            }
        }

        // Block expression
        Expr::Block(stmts) => {
            infer_block(tc, env, stmts, span)
        }
    }
}

/// Infer type of a block (sequence of statements)
fn infer_block(
    tc: &mut TypeChecker,
    env: &TypeEnv,
    stmts: &Vec<Stmt>,
    span: Span,
) -> Ty / {TypeDiag} {
    if stmts.is_empty() {
        return Ty::Unit;
    }

    let mut current_env = env.clone();

    for (i, stmt) in stmts.iter().enumerate() {
        let is_last = i == stmts.len() - 1;

        match stmt {
            Stmt::Let { name, ty_annot, init } => {
                let init_ty = infer_expr(tc, &current_env, init, span);

                let bound_ty = match ty_annot {
                    Some(annot) => {
                        unify(tc, &init_ty, annot, span);
                        annot.clone()
                    }
                    None => init_ty,
                };

                let scheme = generalize(&current_env, tc, &bound_ty);
                current_env.insert(name.clone(), scheme);

                if is_last {
                    return Ty::Unit;  // Let statement doesn't produce value
                }
            }
            Stmt::Expr(expr) => {
                let ty = infer_expr(tc, &current_env, expr, span);
                if is_last {
                    return ty;  // Last expression is the block's value
                }
            }
        }
    }

    Ty::Unit
}

/// Check pattern and return bindings
fn check_pattern(
    tc: &mut TypeChecker,
    pattern: &Pattern,
    expected_ty: &Ty,
    span: Span,
) -> Vec<(String, Ty)> / {TypeDiag} {
    match pattern {
        Pattern::Wildcard => Vec::new(),

        Pattern::Var(name) => {
            vec![(name.clone(), expected_ty.clone())]
        }

        Pattern::Literal(lit) => {
            let lit_ty = match lit {
                LitPattern::Int(_) => Ty::I64,
                LitPattern::Bool(_) => Ty::Bool,
                LitPattern::String(_) => Ty::Named {
                    name: "String".to_string(),
                    args: Vec::new(),
                },
            };
            unify(tc, expected_ty, &lit_ty, span);
            Vec::new()
        }

        Pattern::Tuple(patterns) => {
            let resolved = tc.apply(expected_ty);
            match &resolved {
                Ty::Tuple(elem_tys) => {
                    if patterns.len() != elem_tys.len() {
                        do TypeDiag.error(TypeError::PatternMismatch {
                            expected_ty: resolved.clone(),
                            pattern_kind: "tuple".to_string(),
                            span,
                        });
                        return Vec::new();
                    }

                    let mut bindings = Vec::new();
                    for (i, pat) in patterns.iter().enumerate() {
                        let pat_bindings = check_pattern(tc, pat, &elem_tys[i], span);
                        bindings.extend(pat_bindings);
                    }
                    bindings
                }
                Ty::Var(_) => {
                    // Infer tuple type from pattern
                    let elem_tys: Vec<Ty> = patterns.iter()
                        .map(|_| tc.fresh_type_var())
                        .collect();
                    let tuple_ty = Ty::Tuple(elem_tys.clone());
                    unify(tc, expected_ty, &tuple_ty, span);

                    let mut bindings = Vec::new();
                    for (i, pat) in patterns.iter().enumerate() {
                        let pat_bindings = check_pattern(tc, pat, &elem_tys[i], span);
                        bindings.extend(pat_bindings);
                    }
                    bindings
                }
                _ => {
                    do TypeDiag.error(TypeError::PatternMismatch {
                        expected_ty: resolved.clone(),
                        pattern_kind: "tuple".to_string(),
                        span,
                    });
                    Vec::new()
                }
            }
        }

        Pattern::Struct { name, fields } => {
            match tc.defs.find_struct(name) {
                Some(struct_def) => {
                    // Create expected type
                    let type_args: Vec<Ty> = struct_def.type_params.iter()
                        .map(|_| tc.fresh_type_var())
                        .collect();
                    let struct_ty = Ty::Named {
                        name: name.clone(),
                        args: type_args.clone(),
                    };
                    unify(tc, expected_ty, &struct_ty, span);

                    let mut bindings = Vec::new();
                    for (field_name, field_pat) in fields.iter() {
                        match struct_def.fields.iter().find(|f| &f.name == field_name) {
                            Some(field_def) => {
                                let field_bindings = check_pattern(tc, field_pat, &field_def.ty, span);
                                bindings.extend(field_bindings);
                            }
                            None => {
                                do TypeDiag.error(TypeError::FieldNotFound {
                                    ty: struct_ty.clone(),
                                    field: field_name.clone(),
                                    span,
                                });
                            }
                        }
                    }
                    bindings
                }
                None => {
                    do TypeDiag.error(TypeError::UnboundType {
                        name: name.clone(),
                        span,
                    });
                    Vec::new()
                }
            }
        }

        Pattern::Enum { name, variant, fields } => {
            match tc.defs.find_enum(name) {
                Some(enum_def) => {
                    let type_args: Vec<Ty> = enum_def.type_params.iter()
                        .map(|_| tc.fresh_type_var())
                        .collect();
                    let enum_ty = Ty::Named {
                        name: name.clone(),
                        args: type_args.clone(),
                    };
                    unify(tc, expected_ty, &enum_ty, span);

                    match enum_def.variants.iter().find(|v| &v.name == variant) {
                        Some(variant_def) => {
                            if fields.len() != variant_def.fields.len() {
                                do TypeDiag.error(TypeError::ArityMismatch {
                                    name: format!("{}::{}", name, variant),
                                    expected: variant_def.fields.len(),
                                    found: fields.len(),
                                    span,
                                });
                                return Vec::new();
                            }

                            let mut bindings = Vec::new();
                            for (i, field_pat) in fields.iter().enumerate() {
                                let field_bindings = check_pattern(
                                    tc,
                                    field_pat,
                                    &variant_def.fields[i].ty,
                                    span,
                                );
                                bindings.extend(field_bindings);
                            }
                            bindings
                        }
                        None => {
                            do TypeDiag.error(TypeError::FieldNotFound {
                                ty: enum_ty,
                                field: variant.clone(),
                                span,
                            });
                            Vec::new()
                        }
                    }
                }
                None => {
                    do TypeDiag.error(TypeError::UnboundType {
                        name: name.clone(),
                        span,
                    });
                    Vec::new()
                }
            }
        }
    }
}

// ============================================================================
// Top-Level Type Checking
// ============================================================================

/// Type check a function definition
fn check_function(
    tc: &mut TypeChecker,
    env: &TypeEnv,
    name: &str,
    params: &Vec<(String, Ty)>,
    ret_ty: &Ty,
    body: &Expr,
    span: Span,
) / {TypeDiag} {
    // Create environment with parameters
    let mut fn_env = TypeEnv::with_parent(env.clone());
    for (param_name, param_ty) in params.iter() {
        fn_env.insert(param_name.clone(), TypeScheme::mono(param_ty.clone()));
    }

    // Infer body type and check against declared return type
    let body_ty = infer_expr(tc, &fn_env, body, span);
    unify(tc, &body_ty, ret_ty, span);
}

/// Collect type definitions from items
fn collect_type_defs(items: &Vec<ItemDef>) -> TypeDefs {
    let mut defs = TypeDefs::new();

    for item in items.iter() {
        match item {
            ItemDef::Struct { name, type_params, fields } => {
                defs.structs.push(StructDef {
                    name: name.clone(),
                    type_params: type_params.clone(),
                    fields: fields.clone(),
                });
            }
            ItemDef::Enum { name, type_params, variants } => {
                defs.enums.push(EnumDef {
                    name: name.clone(),
                    type_params: type_params.clone(),
                    variants: variants.clone(),
                });
            }
            ItemDef::Trait { name, type_params, super_traits, methods, assoc_types } => {
                defs.traits.push(TraitDef {
                    name: name.clone(),
                    type_params: type_params.clone(),
                    super_traits: super_traits.clone(),
                    methods: methods.clone(),
                    assoc_types: assoc_types.clone(),
                });
            }
            ItemDef::Effect { name, type_params, operations } => {
                defs.effects.push(EffectDef {
                    name: name.clone(),
                    type_params: type_params.clone(),
                    operations: operations.clone(),
                });
            }
            ItemDef::Impl { type_params, trait_ref, self_ty, methods, assoc_types } => {
                defs.impls.push(ImplDef {
                    type_params: type_params.clone(),
                    trait_ref: trait_ref.clone(),
                    self_ty: self_ty.clone(),
                    methods: methods.clone(),
                    assoc_types: assoc_types.clone(),
                });
            }
            _ => {}
        }
    }

    defs
}

/// Simplified item definition for demonstration
enum ItemDef {
    Function {
        name: String,
        type_params: Vec<String>,
        params: Vec<(String, Ty)>,
        ret_ty: Ty,
        effects: EffectSet,
        body: Expr,
    },
    Struct {
        name: String,
        type_params: Vec<String>,
        fields: Vec<FieldDef>,
    },
    Enum {
        name: String,
        type_params: Vec<String>,
        variants: Vec<VariantDef>,
    },
    Trait {
        name: String,
        type_params: Vec<String>,
        super_traits: Vec<TraitRef>,
        methods: Vec<MethodSig>,
        assoc_types: Vec<AssocTypeDef>,
    },
    Effect {
        name: String,
        type_params: Vec<String>,
        operations: Vec<OperationSig>,
    },
    Impl {
        type_params: Vec<String>,
        trait_ref: Option<TraitRef>,
        self_ty: Ty,
        methods: Vec<MethodImpl>,
        assoc_types: Vec<AssocTypeImpl>,
    },
}

/// Type check a complete program
fn check_program(items: &Vec<ItemDef>, span: Span) / {TypeDiag} {
    // Collect type definitions
    let defs = collect_type_defs(items);
    let mut tc = TypeChecker::new(defs);

    // Build initial environment with function signatures
    let mut env = TypeEnv::new();
    for item in items.iter() {
        if let ItemDef::Function { name, type_params, params, ret_ty, effects, .. } = item {
            let param_tys: Vec<Ty> = params.iter().map(|(_, ty)| ty.clone()).collect();
            let fn_ty = Ty::Fn {
                params: param_tys,
                ret: Box::new(ret_ty.clone()),
                effects: effects.clone(),
            };

            // Create type scheme (generalize over type params)
            let scheme = TypeScheme {
                type_vars: Vec::new(),  // Simplified: not quantifying here
                effect_vars: Vec::new(),
                ty: fn_ty,
            };

            env.insert(name.clone(), scheme);
        }
    }

    // Type check function bodies
    for item in items.iter() {
        if let ItemDef::Function { name, params, ret_ty, body, .. } = item {
            check_function(&mut tc, &env, name, params, ret_ty, body, span);
        }
    }
}

// ============================================================================
// Error Handler Implementation
// ============================================================================

/// Default error handler that collects errors
handler CollectErrors: TypeDiag {
    errors: Vec<TypeError>,
    warnings: Vec<(String, Span)>,

    fn error(err: TypeError) {
        self.errors.push(err);
        resume(())
    }

    fn warning(msg: String, span: Span) {
        self.warnings.push((msg, span));
        resume(())
    }
}

/// Format a type for display
fn format_type(ty: &Ty) -> String {
    match ty {
        Ty::Unit => "()".to_string(),
        Ty::Bool => "bool".to_string(),
        Ty::I8 => "i8".to_string(),
        Ty::I16 => "i16".to_string(),
        Ty::I32 => "i32".to_string(),
        Ty::I64 => "i64".to_string(),
        Ty::I128 => "i128".to_string(),
        Ty::Isize => "isize".to_string(),
        Ty::U8 => "u8".to_string(),
        Ty::U16 => "u16".to_string(),
        Ty::U32 => "u32".to_string(),
        Ty::U64 => "u64".to_string(),
        Ty::U128 => "u128".to_string(),
        Ty::Usize => "usize".to_string(),
        Ty::F32 => "f32".to_string(),
        Ty::F64 => "f64".to_string(),
        Ty::Char => "char".to_string(),
        Ty::Str => "str".to_string(),
        Ty::Never => "!".to_string(),
        Ty::Var(id) => format!("?{}", id),
        Ty::Named { name, args } => {
            if args.is_empty() {
                name.clone()
            } else {
                let args_str: Vec<String> = args.iter().map(format_type).collect();
                format!("{}<{}>", name, args_str.join(", "))
            }
        }
        Ty::Ref { mutable, ty } => {
            if *mutable {
                format!("&mut {}", format_type(ty))
            } else {
                format!("&{}", format_type(ty))
            }
        }
        Ty::RawPtr { mutable, ty } => {
            if *mutable {
                format!("*mut {}", format_type(ty))
            } else {
                format!("*const {}", format_type(ty))
            }
        }
        Ty::Slice(ty) => format!("[{}]", format_type(ty)),
        Ty::Array { ty, len } => format!("[{}; {}]", format_type(ty), len),
        Ty::Tuple(elems) => {
            let elems_str: Vec<String> = elems.iter().map(format_type).collect();
            format!("({})", elems_str.join(", "))
        }
        Ty::Fn { params, ret, effects } => {
            let params_str: Vec<String> = params.iter().map(format_type).collect();
            let ret_str = format_type(ret);
            if effects.effects.is_empty() && effects.var.is_none() {
                format!("fn({}) -> {}", params_str.join(", "), ret_str)
            } else {
                let effects_str: Vec<String> = effects.effects.iter()
                    .map(|e| e.name.clone())
                    .collect();
                format!("fn({}) -> {} with {}", params_str.join(", "), ret_str, effects_str.join(" + "))
            }
        }
        Ty::Param { name, .. } => name.clone(),
        Ty::Projection { self_ty, trait_ref, assoc_name } => {
            format!("<{} as {}>::{}", format_type(self_ty), trait_ref.name, assoc_name)
        }
        Ty::Error => "<error>".to_string(),
    }
}

/// Format a type error for display
fn format_error(err: &TypeError) -> String {
    match err {
        TypeError::Mismatch { expected, found, span } => {
            format!(
                "error[E0308]: mismatched types at {}:{}\n  expected: {}\n     found: {}",
                span.start_line, span.start_col,
                format_type(expected),
                format_type(found)
            )
        }
        TypeError::OccursCheck { var, ty, span } => {
            format!(
                "error[E0391]: infinite type at {}:{}\n  type variable ?{} occurs in {}",
                span.start_line, span.start_col,
                var, format_type(ty)
            )
        }
        TypeError::UnboundVariable { name, span } => {
            format!(
                "error[E0425]: cannot find value '{}' in this scope at {}:{}",
                name, span.start_line, span.start_col
            )
        }
        TypeError::UnboundType { name, span } => {
            format!(
                "error[E0412]: cannot find type '{}' in this scope at {}:{}",
                name, span.start_line, span.start_col
            )
        }
        TypeError::ArityMismatch { name, expected, found, span } => {
            format!(
                "error[E0107]: wrong number of arguments for '{}' at {}:{}\n  expected: {}\n     found: {}",
                name, span.start_line, span.start_col,
                expected, found
            )
        }
        TypeError::UnhandledEffect { effect, span } => {
            format!(
                "error[E0599]: unhandled effect '{}' at {}:{}",
                effect.name, span.start_line, span.start_col
            )
        }
        TypeError::MissingImpl { ty, trait_name, span } => {
            format!(
                "error[E0277]: the trait '{}' is not implemented for '{}' at {}:{}",
                trait_name, format_type(ty), span.start_line, span.start_col
            )
        }
        TypeError::FieldNotFound { ty, field, span } => {
            format!(
                "error[E0609]: no field '{}' on type '{}' at {}:{}",
                field, format_type(ty), span.start_line, span.start_col
            )
        }
        TypeError::MethodNotFound { ty, method, span } => {
            format!(
                "error[E0599]: no method named '{}' found for type '{}' at {}:{}",
                method, format_type(ty), span.start_line, span.start_col
            )
        }
        TypeError::PatternMismatch { expected_ty, pattern_kind, span } => {
            format!(
                "error[E0308]: {} pattern used where '{}' expected at {}:{}",
                pattern_kind, format_type(expected_ty), span.start_line, span.start_col
            )
        }
    }
}

// ============================================================================
// Example Usage
// ============================================================================

fn main() / {IO} {
    // Example: type check a simple program
    let span = Span { start_line: 1, start_col: 1, end_line: 1, end_col: 1 };

    let program: Vec<ItemDef> = vec![
        // struct Point { x: i64, y: i64 }
        ItemDef::Struct {
            name: "Point".to_string(),
            type_params: Vec::new(),
            fields: vec![
                FieldDef { name: "x".to_string(), ty: Ty::I64 },
                FieldDef { name: "y".to_string(), ty: Ty::I64 },
            ],
        },

        // fn add(a: i64, b: i64) -> i64 { a + b }
        ItemDef::Function {
            name: "add".to_string(),
            type_params: Vec::new(),
            params: vec![
                ("a".to_string(), Ty::I64),
                ("b".to_string(), Ty::I64),
            ],
            ret_ty: Ty::I64,
            effects: EffectSet::empty(),
            body: Expr::BinOp {
                op: BinOpKind::Add,
                left: Box::new(Expr::Var("a".to_string())),
                right: Box::new(Expr::Var("b".to_string())),
            },
        },

        // fn make_point(x: i64, y: i64) -> Point { Point { x, y } }
        ItemDef::Function {
            name: "make_point".to_string(),
            type_params: Vec::new(),
            params: vec![
                ("x".to_string(), Ty::I64),
                ("y".to_string(), Ty::I64),
            ],
            ret_ty: Ty::Named { name: "Point".to_string(), args: Vec::new() },
            effects: EffectSet::empty(),
            body: Expr::Struct {
                name: "Point".to_string(),
                fields: vec![
                    ("x".to_string(), Expr::Var("x".to_string())),
                    ("y".to_string(), Expr::Var("y".to_string())),
                ],
            },
        },

        // fn distance(p: Point) -> i64 { p.x + p.y }
        ItemDef::Function {
            name: "distance".to_string(),
            type_params: Vec::new(),
            params: vec![("p".to_string(), Ty::Named { name: "Point".to_string(), args: Vec::new() })],
            ret_ty: Ty::I64,
            effects: EffectSet::empty(),
            body: Expr::BinOp {
                op: BinOpKind::Add,
                left: Box::new(Expr::Field {
                    expr: Box::new(Expr::Var("p".to_string())),
                    field: "x".to_string(),
                }),
                right: Box::new(Expr::Field {
                    expr: Box::new(Expr::Var("p".to_string())),
                    field: "y".to_string(),
                }),
            },
        },
    ];

    // Type check with error collection
    let handler = CollectErrors {
        errors: Vec::new(),
        warnings: Vec::new(),
    };

    with handler {
        check_program(&program, span);
    }

    // Report results
    if handler.errors.is_empty() {
        println!("Type checking successful!");
    } else {
        println!("Type errors found:");
        for err in handler.errors.iter() {
            println!("{}", format_error(err));
        }
    }

    for (msg, span) in handler.warnings.iter() {
        println!("warning at {}:{}: {}", span.start_line, span.start_col, msg);
    }
}
