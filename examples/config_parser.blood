// Configuration File Parser Example
// Demonstrates: TOML/INI parsing, recursive descent, effect-based error handling,
// type coercion, environment variable interpolation, validation
//
// Supports:
// - TOML-like syntax with sections, key-value pairs
// - Multiple value types: strings, integers, floats, booleans, arrays, tables
// - Environment variable interpolation: ${VAR} or ${VAR:-default}
// - Include directives for config composition
// - Comments (# and //)
// - Dotted keys for nested access

use std::collections::HashMap;
use std::env;

// ============================================================================
// Value Types
// ============================================================================

/// Configuration value types
enum Value {
    /// String value
    String(String),

    /// Integer value
    Integer(i64),

    /// Floating point value
    Float(f64),

    /// Boolean value
    Boolean(bool),

    /// Array of values
    Array(Vec<Value>),

    /// Nested table/section
    Table(HashMap<String, Value>),

    /// Null/undefined value
    Null,
}

impl Value {
    /// Get as string
    fn as_string(&self) -> Option<&String> {
        match self {
            Value::String(s) => Some(s),
            _ => None,
        }
    }

    /// Get as integer
    fn as_integer(&self) -> Option<i64> {
        match self {
            Value::Integer(i) => Some(*i),
            _ => None,
        }
    }

    /// Get as float
    fn as_float(&self) -> Option<f64> {
        match self {
            Value::Float(f) => Some(*f),
            Value::Integer(i) => Some(*i as f64),
            _ => None,
        }
    }

    /// Get as boolean
    fn as_boolean(&self) -> Option<bool> {
        match self {
            Value::Boolean(b) => Some(*b),
            _ => None,
        }
    }

    /// Get as array
    fn as_array(&self) -> Option<&Vec<Value>> {
        match self {
            Value::Array(arr) => Some(arr),
            _ => None,
        }
    }

    /// Get as table
    fn as_table(&self) -> Option<&HashMap<String, Value>> {
        match self {
            Value::Table(table) => Some(table),
            _ => None,
        }
    }

    /// Check if null
    fn is_null(&self) -> bool {
        matches!(self, Value::Null)
    }

    /// Get type name
    fn type_name(&self) -> &'static str {
        match self {
            Value::String(_) => "string",
            Value::Integer(_) => "integer",
            Value::Float(_) => "float",
            Value::Boolean(_) => "boolean",
            Value::Array(_) => "array",
            Value::Table(_) => "table",
            Value::Null => "null",
        }
    }

    /// Deep clone
    fn clone(&self) -> Value {
        match self {
            Value::String(s) => Value::String(s.clone()),
            Value::Integer(i) => Value::Integer(*i),
            Value::Float(f) => Value::Float(*f),
            Value::Boolean(b) => Value::Boolean(*b),
            Value::Array(arr) => Value::Array(arr.iter().map(|v| v.clone()).collect()),
            Value::Table(table) => {
                let mut new_table = HashMap::new();
                for (k, v) in table {
                    new_table.insert(k.clone(), v.clone());
                }
                Value::Table(new_table)
            },
            Value::Null => Value::Null,
        }
    }
}

// ============================================================================
// Configuration Document
// ============================================================================

/// A parsed configuration document
struct Config {
    /// Root table containing all configuration
    root: HashMap<String, Value>,

    /// Source file path (if loaded from file)
    source: Option<String>,
}

impl Config {
    /// Create empty config
    fn new() -> Config {
        Config {
            root: HashMap::new(),
            source: None,
        }
    }

    /// Get a value by dotted key path
    fn get(&self, key: &str) -> Option<&Value> {
        let parts: Vec<&str> = key.split('.').collect();
        let mut current: &HashMap<String, Value> = &self.root;

        for (i, part) in parts.iter().enumerate() {
            if i == parts.len() - 1 {
                return current.get(*part);
            } else {
                match current.get(*part) {
                    Some(Value::Table(table)) => current = table,
                    _ => return None,
                }
            }
        }

        None
    }

    /// Get string value
    fn get_string(&self, key: &str) -> Option<&String> {
        self.get(key).and_then(|v| v.as_string())
    }

    /// Get integer value
    fn get_integer(&self, key: &str) -> Option<i64> {
        self.get(key).and_then(|v| v.as_integer())
    }

    /// Get float value
    fn get_float(&self, key: &str) -> Option<f64> {
        self.get(key).and_then(|v| v.as_float())
    }

    /// Get boolean value
    fn get_boolean(&self, key: &str) -> Option<bool> {
        self.get(key).and_then(|v| v.as_boolean())
    }

    /// Get array value
    fn get_array(&self, key: &str) -> Option<&Vec<Value>> {
        self.get(key).and_then(|v| v.as_array())
    }

    /// Get table/section
    fn get_table(&self, key: &str) -> Option<&HashMap<String, Value>> {
        self.get(key).and_then(|v| v.as_table())
    }

    /// Check if key exists
    fn contains(&self, key: &str) -> bool {
        self.get(key).is_some()
    }

    /// Get with default value
    fn get_or(&self, key: &str, default: Value) -> Value {
        self.get(key).map(|v| v.clone()).unwrap_or(default)
    }

    /// Get string with default
    fn get_string_or(&self, key: &str, default: &str) -> String {
        self.get_string(key).cloned().unwrap_or_else(|| default.to_string())
    }

    /// Get integer with default
    fn get_integer_or(&self, key: &str, default: i64) -> i64 {
        self.get_integer(key).unwrap_or(default)
    }

    /// Get boolean with default
    fn get_boolean_or(&self, key: &str, default: bool) -> bool {
        self.get_boolean(key).unwrap_or(default)
    }

    /// Set a value by dotted key path
    fn set(&mut self, key: &str, value: Value) {
        let parts: Vec<&str> = key.split('.').collect();
        let mut current = &mut self.root;

        for (i, part) in parts.iter().enumerate() {
            if i == parts.len() - 1 {
                current.insert(part.to_string(), value);
                return;
            } else {
                // Ensure intermediate tables exist
                if !current.contains_key(*part) {
                    current.insert(part.to_string(), Value::Table(HashMap::new()));
                }
                match current.get_mut(*part) {
                    Some(Value::Table(table)) => current = table,
                    _ => {
                        // Replace non-table with table
                        current.insert(part.to_string(), Value::Table(HashMap::new()));
                        if let Some(Value::Table(table)) = current.get_mut(*part) {
                            current = table;
                        }
                    }
                }
            }
        }
    }

    /// Merge another config into this one
    fn merge(&mut self, other: &Config) {
        merge_tables(&mut self.root, &other.root);
    }

    /// Get all keys at root level
    fn keys(&self) -> Vec<&String> {
        self.root.keys().collect()
    }

    /// Get all section names
    fn sections(&self) -> Vec<&String> {
        self.root.iter()
            .filter(|(_, v)| matches!(v, Value::Table(_)))
            .map(|(k, _)| k)
            .collect()
    }
}

/// Recursively merge tables
fn merge_tables(target: &mut HashMap<String, Value>, source: &HashMap<String, Value>) {
    for (key, value) in source {
        match (target.get_mut(key), value) {
            (Some(Value::Table(t1)), Value::Table(t2)) => {
                merge_tables(t1, t2);
            },
            _ => {
                target.insert(key.clone(), value.clone());
            }
        }
    }
}

// ============================================================================
// Parser Effects
// ============================================================================

/// Effect for parse errors
effect ParseError {
    op error(msg: String, line: i32, column: i32) -> !;
    op warning(msg: String, line: i32, column: i32) -> ();
}

/// Effect for environment variable access
effect Env {
    op get_var(name: &str) -> Option<String>;
}

/// Effect for file inclusion
effect FileSystem {
    op read_file(path: &str) -> Option<String>;
}

// ============================================================================
// Lexer
// ============================================================================

/// Token types
enum TokenKind {
    // Literals
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Identifier(String),

    // Punctuation
    Equals,          // =
    Dot,             // .
    Comma,           // ,
    LeftBracket,     // [
    RightBracket,    // ]
    LeftBrace,       // {
    RightBrace,      // }
    Newline,

    // Special
    Include,         // @include directive
    Eof,
}

struct Token {
    kind: TokenKind,
    line: i32,
    column: i32,
}

/// Lexer state
struct Lexer {
    input: String,
    pos: usize,
    line: i32,
    column: i32,
}

impl Lexer {
    fn new(input: String) -> Lexer {
        Lexer {
            input: input,
            pos: 0,
            line: 1,
            column: 1,
        }
    }

    fn is_eof(&self) -> bool {
        self.pos >= self.input.len()
    }

    fn peek(&self) -> Option<char> {
        self.input.chars().nth(self.pos)
    }

    fn peek_next(&self) -> Option<char> {
        self.input.chars().nth(self.pos + 1)
    }

    fn advance(&mut self) -> Option<char> {
        let ch = self.peek();
        if let Some(c) = ch {
            self.pos += 1;
            if c == '\n' {
                self.line += 1;
                self.column = 1;
            } else {
                self.column += 1;
            }
        }
        ch
    }

    fn skip_whitespace(&mut self) {
        while let Some(ch) = self.peek() {
            if ch == ' ' || ch == '\t' || ch == '\r' {
                self.advance();
            } else {
                break;
            }
        }
    }

    fn skip_comment(&mut self) {
        // Skip # or // comments
        if self.peek() == Some('#') ||
           (self.peek() == Some('/') && self.peek_next() == Some('/')) {
            while let Some(ch) = self.peek() {
                if ch == '\n' {
                    break;
                }
                self.advance();
            }
        }
    }

    fn skip_whitespace_and_comments(&mut self) {
        loop {
            self.skip_whitespace();
            if self.peek() == Some('#') ||
               (self.peek() == Some('/') && self.peek_next() == Some('/')) {
                self.skip_comment();
            } else {
                break;
            }
        }
    }

    /// Get next token
    fn next_token(&mut self) -> Token / {ParseError} {
        self.skip_whitespace_and_comments();

        let line = self.line;
        let column = self.column;

        if self.is_eof() {
            return Token { kind: TokenKind::Eof, line: line, column: column };
        }

        let ch = self.peek().unwrap();

        // Newline
        if ch == '\n' {
            self.advance();
            return Token { kind: TokenKind::Newline, line: line, column: column };
        }

        // Punctuation
        match ch {
            '=' => {
                self.advance();
                return Token { kind: TokenKind::Equals, line: line, column: column };
            },
            '.' => {
                self.advance();
                return Token { kind: TokenKind::Dot, line: line, column: column };
            },
            ',' => {
                self.advance();
                return Token { kind: TokenKind::Comma, line: line, column: column };
            },
            '[' => {
                self.advance();
                return Token { kind: TokenKind::LeftBracket, line: line, column: column };
            },
            ']' => {
                self.advance();
                return Token { kind: TokenKind::RightBracket, line: line, column: column };
            },
            '{' => {
                self.advance();
                return Token { kind: TokenKind::LeftBrace, line: line, column: column };
            },
            '}' => {
                self.advance();
                return Token { kind: TokenKind::RightBrace, line: line, column: column };
            },
            _ => {}
        }

        // String
        if ch == '"' || ch == '\'' {
            return self.scan_string(ch);
        }

        // Number
        if ch.is_digit(10) || (ch == '-' && self.peek_next().map(|c| c.is_digit(10)).unwrap_or(false)) {
            return self.scan_number();
        }

        // Identifier or keyword
        if ch.is_alphabetic() || ch == '_' || ch == '@' {
            return self.scan_identifier();
        }

        perform ParseError.error(
            format!("Unexpected character: '{}'", ch),
            line, column
        )
    }

    fn scan_string(&mut self, quote: char) -> Token / {ParseError} {
        let line = self.line;
        let column = self.column;

        self.advance();  // Skip opening quote

        let mut value = String::new();
        let mut escaped = false;

        // Check for multi-line string (triple quotes)
        let multi_line = if self.peek() == Some(quote) && self.peek_next() == Some(quote) {
            self.advance();
            self.advance();
            true
        } else {
            false
        };

        while !self.is_eof() {
            let ch = self.advance().unwrap();

            if escaped {
                match ch {
                    'n' => value.push('\n'),
                    't' => value.push('\t'),
                    'r' => value.push('\r'),
                    '\\' => value.push('\\'),
                    '"' => value.push('"'),
                    '\'' => value.push('\''),
                    _ => {
                        value.push('\\');
                        value.push(ch);
                    }
                }
                escaped = false;
            } else if ch == '\\' {
                escaped = true;
            } else if ch == quote {
                if multi_line {
                    if self.peek() == Some(quote) && self.peek_next() == Some(quote) {
                        self.advance();
                        self.advance();
                        break;
                    } else {
                        value.push(ch);
                    }
                } else {
                    break;
                }
            } else {
                value.push(ch);
            }
        }

        Token { kind: TokenKind::String(value), line: line, column: column }
    }

    fn scan_number(&mut self) -> Token / {ParseError} {
        let line = self.line;
        let column = self.column;

        let mut num_str = String::new();
        let mut is_float = false;

        // Handle negative
        if self.peek() == Some('-') {
            num_str.push('-');
            self.advance();
        }

        // Integer part
        while let Some(ch) = self.peek() {
            if ch.is_digit(10) || ch == '_' {
                if ch != '_' {
                    num_str.push(ch);
                }
                self.advance();
            } else {
                break;
            }
        }

        // Decimal part
        if self.peek() == Some('.') && self.peek_next().map(|c| c.is_digit(10)).unwrap_or(false) {
            is_float = true;
            num_str.push('.');
            self.advance();

            while let Some(ch) = self.peek() {
                if ch.is_digit(10) || ch == '_' {
                    if ch != '_' {
                        num_str.push(ch);
                    }
                    self.advance();
                } else {
                    break;
                }
            }
        }

        // Exponent
        if let Some(ch) = self.peek() {
            if ch == 'e' || ch == 'E' {
                is_float = true;
                num_str.push('e');
                self.advance();

                if self.peek() == Some('+') || self.peek() == Some('-') {
                    num_str.push(self.advance().unwrap());
                }

                while let Some(ch) = self.peek() {
                    if ch.is_digit(10) {
                        num_str.push(ch);
                        self.advance();
                    } else {
                        break;
                    }
                }
            }
        }

        if is_float {
            match num_str.parse::<f64>() {
                Ok(f) => Token { kind: TokenKind::Float(f), line: line, column: column },
                Err(_) => perform ParseError.error(
                    format!("Invalid float: {}", num_str),
                    line, column
                ),
            }
        } else {
            match num_str.parse::<i64>() {
                Ok(i) => Token { kind: TokenKind::Integer(i), line: line, column: column },
                Err(_) => perform ParseError.error(
                    format!("Invalid integer: {}", num_str),
                    line, column
                ),
            }
        }
    }

    fn scan_identifier(&mut self) -> Token / {ParseError} {
        let line = self.line;
        let column = self.column;

        let mut ident = String::new();

        while let Some(ch) = self.peek() {
            if ch.is_alphanumeric() || ch == '_' || ch == '-' || ch == '@' {
                ident.push(ch);
                self.advance();
            } else {
                break;
            }
        }

        // Check for keywords
        let kind = match ident.as_str() {
            "true" => TokenKind::Boolean(true),
            "false" => TokenKind::Boolean(false),
            "yes" => TokenKind::Boolean(true),
            "no" => TokenKind::Boolean(false),
            "on" => TokenKind::Boolean(true),
            "off" => TokenKind::Boolean(false),
            "@include" => TokenKind::Include,
            _ => TokenKind::Identifier(ident),
        };

        Token { kind: kind, line: line, column: column }
    }
}

// ============================================================================
// Parser
// ============================================================================

/// Configuration parser
struct Parser {
    lexer: Lexer,
    current: Token,
    peeked: Option<Token>,
}

impl Parser {
    fn new(input: String) -> Parser / {ParseError} {
        let mut lexer = Lexer::new(input);
        let current = lexer.next_token();
        Parser {
            lexer: lexer,
            current: current,
            peeked: None,
        }
    }

    fn advance(&mut self) / {ParseError} {
        if let Some(token) = self.peeked.take() {
            self.current = token;
        } else {
            self.current = self.lexer.next_token();
        }
    }

    fn peek(&mut self) -> &Token / {ParseError} {
        if self.peeked.is_none() {
            self.peeked = Some(self.lexer.next_token());
        }
        self.peeked.as_ref().unwrap()
    }

    fn skip_newlines(&mut self) / {ParseError} {
        while matches!(self.current.kind, TokenKind::Newline) {
            self.advance();
        }
    }

    fn expect_newline_or_eof(&mut self) / {ParseError} {
        match &self.current.kind {
            TokenKind::Newline => { self.advance(); },
            TokenKind::Eof => {},
            _ => {
                perform ParseError.error(
                    format!("Expected newline, got {:?}", self.current.kind),
                    self.current.line,
                    self.current.column
                );
            }
        }
    }

    /// Parse the configuration file
    fn parse(&mut self) -> Config / {ParseError, Env, FileSystem} {
        let mut config = Config::new();
        let mut current_section: Option<String> = None;

        self.skip_newlines();

        while !matches!(self.current.kind, TokenKind::Eof) {
            match &self.current.kind {
                // Section header: [section] or [section.subsection]
                TokenKind::LeftBracket => {
                    current_section = Some(self.parse_section_header()?);
                },

                // Include directive
                TokenKind::Include => {
                    self.advance();
                    self.skip_newlines();

                    let path = match &self.current.kind {
                        TokenKind::String(s) => s.clone(),
                        _ => perform ParseError.error(
                            "Expected file path after @include".to_string(),
                            self.current.line,
                            self.current.column
                        ),
                    };
                    self.advance();

                    // Load and parse included file
                    if let Some(content) = perform FileSystem.read_file(&path) {
                        let mut included_parser = Parser::new(content)?;
                        let included_config = included_parser.parse()?;
                        config.merge(&included_config);
                    } else {
                        perform ParseError.warning(
                            format!("Could not include file: {}", path),
                            self.current.line,
                            self.current.column
                        );
                    }
                },

                // Key-value pair
                TokenKind::Identifier(_) => {
                    let (key, value) = self.parse_key_value()?;

                    let full_key = match &current_section {
                        Some(section) => format!("{}.{}", section, key),
                        None => key,
                    };

                    config.set(&full_key, value);
                },

                TokenKind::Newline => {
                    self.advance();
                },

                _ => {
                    perform ParseError.error(
                        format!("Unexpected token: {:?}", self.current.kind),
                        self.current.line,
                        self.current.column
                    );
                }
            }
        }

        config
    }

    fn parse_section_header(&mut self) -> String / {ParseError} {
        // Skip [
        self.advance();

        let mut section_name = String::new();

        loop {
            match &self.current.kind {
                TokenKind::Identifier(name) => {
                    section_name.push_str(name);
                    self.advance();
                },
                TokenKind::Dot => {
                    section_name.push('.');
                    self.advance();
                },
                TokenKind::RightBracket => {
                    self.advance();
                    break;
                },
                _ => {
                    perform ParseError.error(
                        "Invalid section header".to_string(),
                        self.current.line,
                        self.current.column
                    );
                }
            }
        }

        self.skip_newlines();

        section_name
    }

    fn parse_key_value(&mut self) -> (String, Value) / {ParseError, Env} {
        // Parse key (possibly dotted)
        let mut key = String::new();

        loop {
            match &self.current.kind {
                TokenKind::Identifier(name) => {
                    key.push_str(name);
                    self.advance();
                },
                TokenKind::Dot => {
                    key.push('.');
                    self.advance();
                },
                TokenKind::Equals => {
                    self.advance();
                    break;
                },
                _ => {
                    perform ParseError.error(
                        "Expected '=' after key".to_string(),
                        self.current.line,
                        self.current.column
                    );
                }
            }
        }

        // Skip whitespace after =
        self.skip_newlines();

        // Parse value
        let value = self.parse_value()?;

        // Expect newline or EOF after value
        self.skip_newlines();

        (key, value)
    }

    fn parse_value(&mut self) -> Value / {ParseError, Env} {
        match &self.current.kind {
            TokenKind::String(s) => {
                let value = self.interpolate_string(s)?;
                self.advance();
                Value::String(value)
            },
            TokenKind::Integer(i) => {
                let value = *i;
                self.advance();
                Value::Integer(value)
            },
            TokenKind::Float(f) => {
                let value = *f;
                self.advance();
                Value::Float(value)
            },
            TokenKind::Boolean(b) => {
                let value = *b;
                self.advance();
                Value::Boolean(value)
            },
            TokenKind::LeftBracket => {
                self.parse_array()
            },
            TokenKind::LeftBrace => {
                self.parse_inline_table()
            },
            _ => {
                perform ParseError.error(
                    format!("Expected value, got {:?}", self.current.kind),
                    self.current.line,
                    self.current.column
                );
            }
        }
    }

    fn parse_array(&mut self) -> Value / {ParseError, Env} {
        // Skip [
        self.advance();
        self.skip_newlines();

        let mut values = Vec::new();

        while !matches!(self.current.kind, TokenKind::RightBracket | TokenKind::Eof) {
            values.push(self.parse_value()?);

            self.skip_newlines();

            // Optional comma
            if matches!(self.current.kind, TokenKind::Comma) {
                self.advance();
                self.skip_newlines();
            }
        }

        // Skip ]
        if matches!(self.current.kind, TokenKind::RightBracket) {
            self.advance();
        }

        Value::Array(values)
    }

    fn parse_inline_table(&mut self) -> Value / {ParseError, Env} {
        // Skip {
        self.advance();
        self.skip_newlines();

        let mut table = HashMap::new();

        while !matches!(self.current.kind, TokenKind::RightBrace | TokenKind::Eof) {
            let (key, value) = self.parse_key_value()?;
            table.insert(key, value);

            // Optional comma
            if matches!(self.current.kind, TokenKind::Comma) {
                self.advance();
                self.skip_newlines();
            }
        }

        // Skip }
        if matches!(self.current.kind, TokenKind::RightBrace) {
            self.advance();
        }

        Value::Table(table)
    }

    /// Interpolate environment variables in string
    fn interpolate_string(&self, s: &str) -> String / {Env} {
        let mut result = String::new();
        let mut chars = s.chars().peekable();

        while let Some(ch) = chars.next() {
            if ch == '$' && chars.peek() == Some(&'{') {
                chars.next();  // Skip {

                // Collect variable name
                let mut var_name = String::new();
                let mut default_value: Option<String> = None;
                let mut in_default = false;

                while let Some(&c) = chars.peek() {
                    if c == '}' {
                        chars.next();
                        break;
                    } else if c == ':' && chars.peek() == Some(&'-').into() {
                        chars.next();  // Skip :
                        chars.next();  // Skip -
                        in_default = true;
                        default_value = Some(String::new());
                    } else {
                        chars.next();
                        if in_default {
                            if let Some(ref mut dv) = default_value {
                                dv.push(c);
                            }
                        } else {
                            var_name.push(c);
                        }
                    }
                }

                // Look up environment variable
                if let Some(value) = perform Env.get_var(&var_name) {
                    result.push_str(&value);
                } else if let Some(dv) = default_value {
                    result.push_str(&dv);
                }
            } else {
                result.push(ch);
            }
        }

        result
    }
}

// ============================================================================
// Validation
// ============================================================================

/// Configuration validator
struct Validator {
    errors: Vec<String>,
    warnings: Vec<String>,
}

impl Validator {
    fn new() -> Validator {
        Validator {
            errors: Vec::new(),
            warnings: Vec::new(),
        }
    }

    /// Require a key exists
    fn require(&mut self, config: &Config, key: &str) {
        if !config.contains(key) {
            self.errors.push(format!("Missing required key: {}", key));
        }
    }

    /// Require a key has specific type
    fn require_type(&mut self, config: &Config, key: &str, expected: &str) {
        if let Some(value) = config.get(key) {
            if value.type_name() != expected {
                self.errors.push(format!(
                    "Key '{}' expected type '{}', got '{}'",
                    key, expected, value.type_name()
                ));
            }
        }
    }

    /// Require integer in range
    fn require_range(&mut self, config: &Config, key: &str, min: i64, max: i64) {
        if let Some(value) = config.get_integer(key) {
            if value < min || value > max {
                self.errors.push(format!(
                    "Key '{}' value {} out of range [{}, {}]",
                    key, value, min, max
                ));
            }
        }
    }

    /// Warn if deprecated key is used
    fn deprecate(&mut self, config: &Config, old_key: &str, new_key: &str) {
        if config.contains(old_key) {
            self.warnings.push(format!(
                "Key '{}' is deprecated, use '{}' instead",
                old_key, new_key
            ));
        }
    }

    /// Check if validation passed
    fn is_valid(&self) -> bool {
        self.errors.is_empty()
    }

    /// Get all errors
    fn errors(&self) -> &[String] {
        &self.errors
    }

    /// Get all warnings
    fn warnings(&self) -> &[String] {
        &self.warnings
    }
}

// ============================================================================
// Serialization
// ============================================================================

/// Serialize config back to TOML-like format
fn serialize(config: &Config) -> String {
    let mut output = String::new();

    // First, output non-table values at root level
    for (key, value) in &config.root {
        if !matches!(value, Value::Table(_)) {
            output.push_str(&format!("{} = {}\n", key, serialize_value(value)));
        }
    }

    if !output.is_empty() {
        output.push('\n');
    }

    // Then, output sections
    for (key, value) in &config.root {
        if let Value::Table(table) = value {
            serialize_section(&mut output, key, table, "");
        }
    }

    output
}

fn serialize_section(output: &mut String, name: &str, table: &HashMap<String, Value>, prefix: &str) {
    let full_name = if prefix.is_empty() {
        name.to_string()
    } else {
        format!("{}.{}", prefix, name)
    };

    // Output section header
    output.push_str(&format!("[{}]\n", full_name));

    // Output non-table values
    for (key, value) in table {
        if !matches!(value, Value::Table(_)) {
            output.push_str(&format!("{} = {}\n", key, serialize_value(value)));
        }
    }

    output.push('\n');

    // Recursively output sub-sections
    for (key, value) in table {
        if let Value::Table(sub_table) = value {
            serialize_section(output, key, sub_table, &full_name);
        }
    }
}

fn serialize_value(value: &Value) -> String {
    match value {
        Value::String(s) => {
            if s.contains('\n') {
                format!("'''\n{}'''", s)
            } else if s.contains('"') {
                format!("'{}'", s)
            } else {
                format!("\"{}\"", s)
            }
        },
        Value::Integer(i) => format!("{}", i),
        Value::Float(f) => format!("{}", f),
        Value::Boolean(b) => if *b { "true" } else { "false" }.to_string(),
        Value::Array(arr) => {
            let items: Vec<String> = arr.iter().map(serialize_value).collect();
            format!("[{}]", items.join(", "))
        },
        Value::Table(table) => {
            let items: Vec<String> = table.iter()
                .map(|(k, v)| format!("{} = {}", k, serialize_value(v)))
                .collect();
            format!("{{ {} }}", items.join(", "))
        },
        Value::Null => "null".to_string(),
    }
}

// ============================================================================
// Convenience Functions
// ============================================================================

/// Parse configuration from string
fn parse_config(input: &str) -> Config / {ParseError, Env, FileSystem} {
    let mut parser = Parser::new(input.to_string())?;
    parser.parse()
}

/// Parse configuration from string with default handlers
fn parse_config_simple(input: &str) -> Result<Config, String> {
    try {
        let mut parser = Parser::new(input.to_string())?;
        parser.parse()
    } with {
        ParseError::error(msg, line, col) => {
            return Err(format!("Parse error at {}:{}: {}", line, col, msg));
        },
        ParseError::warning(msg, line, col) => {
            // Ignore warnings in simple mode
            resume(())
        },
        Env::get_var(name) => {
            resume(std::env::var(name).ok())
        },
        FileSystem::read_file(path) => {
            resume(std::fs::read_to_string(path).ok())
        },
    }
}

// ============================================================================
// Example Usage
// ============================================================================

fn main() -> i32 / {IO} {
    print("=== Blood Configuration Parser ===\n");

    // Example configuration
    let config_str = r#"
# Application configuration
name = "MyApp"
version = "1.0.0"
debug = true

# Server settings
[server]
host = "localhost"
port = 8080
timeout = 30

# Database configuration
[database]
driver = "postgres"
host = "${DB_HOST:-localhost}"
port = 5432
name = "myapp_db"
max_connections = 10

# Multiple array items
[server.allowed_origins]
origins = ["http://localhost:3000", "https://example.com"]

# Nested configuration
[logging]
level = "info"
format = "json"

[logging.file]
enabled = true
path = "/var/log/myapp.log"
max_size = 10485760
rotate = true

# Feature flags
[features]
enable_cache = true
cache_ttl = 3600
beta_features = false
"#;

    // Parse the configuration
    print("Parsing configuration...\n");

    let config = try {
        parse_config(config_str)
    } with {
        ParseError::error(msg, line, col) => {
            print("Parse error at line {}:{}: {}", line, col, msg);
            return 1;
        },
        ParseError::warning(msg, line, col) => {
            print("Warning at line {}:{}: {}", line, col, msg);
            resume(())
        },
        Env::get_var(name) => {
            // Simulate environment variable lookup
            let value = match name {
                "DB_HOST" => Some("db.example.com".to_string()),
                _ => None,
            };
            print("  ENV lookup: {} = {:?}", name, value);
            resume(value)
        },
        FileSystem::read_file(path) => {
            print("  Include: {} (not found)", path);
            resume(None)
        },
    };

    print("\n=== Parsed Configuration ===\n");

    // Access values
    print("Application:");
    print("  Name: {}", config.get_string_or("name", "unknown"));
    print("  Version: {}", config.get_string_or("version", "0.0.0"));
    print("  Debug: {}", config.get_boolean_or("debug", false));

    print("\nServer:");
    print("  Host: {}", config.get_string_or("server.host", "127.0.0.1"));
    print("  Port: {}", config.get_integer_or("server.port", 80));
    print("  Timeout: {}s", config.get_integer_or("server.timeout", 60));

    print("\nDatabase:");
    print("  Driver: {}", config.get_string_or("database.driver", "sqlite"));
    print("  Host: {}", config.get_string_or("database.host", "localhost"));
    print("  Port: {}", config.get_integer_or("database.port", 5432));
    print("  Database: {}", config.get_string_or("database.name", "app"));
    print("  Max Connections: {}", config.get_integer_or("database.max_connections", 5));

    print("\nLogging:");
    print("  Level: {}", config.get_string_or("logging.level", "info"));
    print("  Format: {}", config.get_string_or("logging.format", "text"));
    print("  File Enabled: {}", config.get_boolean_or("logging.file.enabled", false));
    print("  File Path: {}", config.get_string_or("logging.file.path", "/tmp/app.log"));

    print("\nFeatures:");
    print("  Cache: {}", config.get_boolean_or("features.enable_cache", false));
    print("  Cache TTL: {}s", config.get_integer_or("features.cache_ttl", 300));
    print("  Beta: {}", config.get_boolean_or("features.beta_features", false));

    // Validate configuration
    print("\n=== Validation ===\n");

    let mut validator = Validator::new();
    validator.require(&config, "name");
    validator.require(&config, "server.host");
    validator.require(&config, "server.port");
    validator.require_type(&config, "server.port", "integer");
    validator.require_range(&config, "server.port", 1, 65535);
    validator.require_range(&config, "database.max_connections", 1, 100);

    if validator.is_valid() {
        print("Configuration is valid!");
    } else {
        print("Configuration errors:");
        for error in validator.errors() {
            print("  - {}", error);
        }
    }

    for warning in validator.warnings() {
        print("Warning: {}", warning);
    }

    // Serialize back
    print("\n=== Serialized Output ===\n");
    let serialized = serialize(&config);
    print("{}", serialized);

    // Demonstrate programmatic config building
    print("\n=== Programmatic Config ===\n");

    let mut new_config = Config::new();
    new_config.set("app.name", Value::String("NewApp".to_string()));
    new_config.set("app.version", Value::String("2.0.0".to_string()));
    new_config.set("server.host", Value::String("0.0.0.0".to_string()));
    new_config.set("server.port", Value::Integer(9000));
    new_config.set("server.ssl", Value::Boolean(true));
    new_config.set("server.workers", Value::Integer(4));

    print("Programmatic config:");
    print("  app.name = {}", new_config.get_string_or("app.name", ""));
    print("  server.host = {}", new_config.get_string_or("server.host", ""));
    print("  server.port = {}", new_config.get_integer_or("server.port", 0));
    print("  server.ssl = {}", new_config.get_boolean_or("server.ssl", false));

    // Merge configs
    print("\n=== Merged Configuration ===\n");

    let mut merged = Config::new();
    // Set defaults
    merged.set("server.host", Value::String("localhost".to_string()));
    merged.set("server.port", Value::Integer(8080));
    merged.set("server.ssl", Value::Boolean(false));

    // Merge with user config (overrides)
    merged.merge(&new_config);

    print("After merge:");
    print("  server.host = {}", merged.get_string_or("server.host", ""));
    print("  server.port = {}", merged.get_integer_or("server.port", 0));
    print("  server.ssl = {}", merged.get_boolean_or("server.ssl", false));
    print("  app.name = {}", merged.get_string_or("app.name", ""));

    print("\n=== All tests passed! ===");
    0
}
