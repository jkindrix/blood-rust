// FASTA Benchmark for Blood
// =========================
//
// This benchmark generates pseudo-random DNA sequences in FASTA format.
// It is modeled after the Computer Language Benchmarks Game "fasta" benchmark.
//
// The benchmark outputs three types of sequences:
// 1. TWO: A cyclic repeat of a fixed sequence
// 2. THREE: Random DNA with given nucleotide frequencies
// 3. Random amino acid sequences
//
// Key characteristics:
// - Pseudo-random number generation (LCG)
// - Weighted random selection
// - String/buffer building
// - Output formatting

// ===========================================================================
// Constants
// ===========================================================================

const LINE_WIDTH: i32 = 60;

// Linear Congruential Generator constants
const LCG_IA: i32 = 3877;
const LCG_IC: i32 = 29573;
const LCG_IM: i32 = 139968;

// ===========================================================================
// Random Number Generator
// ===========================================================================

// Simple Linear Congruential Generator
// Returns a pseudo-random float in [0, 1)
fn lcg_next(seed: &mut i32) -> f64 {
    let new_seed = (*seed * LCG_IA + LCG_IC) % LCG_IM;
    *seed = new_seed;
    (new_seed as f64) / (LCG_IM as f64)
}

// ===========================================================================
// Repeat Sequence
// ===========================================================================

// ALU repeat sequence (used in Human genome)
const ALU_LENGTH: i32 = 287;

// Generate repeat sequence (cyclic)
fn repeat_char_at(idx: i32) -> char {
    // ALU sequence (287 nucleotides)
    // We store it as a string and index into it
    let alu = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

    let pos = idx % ALU_LENGTH;
    char_at(alu, pos)
}

// Get character at position in string (0-indexed)
fn char_at(s: str, idx: i32) -> char {
    // In Blood, we'd use s[idx] - simulate with pattern matching
    // For now, return based on position mod 4
    let c = idx % 4;
    if c == 0 { 'A' }
    else if c == 1 { 'C' }
    else if c == 2 { 'G' }
    else { 'T' }
}

// ===========================================================================
// Weighted Random Selection
// ===========================================================================

// DNA nucleotide frequencies (IUB ambiguity codes)
// a=0.27, c=0.12, g=0.12, t=0.27, rest are rare

fn random_nucleotide_iub(r: f64) -> char {
    // Cumulative probabilities:
    // a: 0.27
    // c: 0.27 + 0.12 = 0.39
    // g: 0.39 + 0.12 = 0.51
    // t: 0.51 + 0.27 = 0.78
    // B: 0.78 + 0.02 = 0.80
    // D: 0.80 + 0.02 = 0.82
    // H: 0.82 + 0.02 = 0.84
    // K: 0.84 + 0.02 = 0.86
    // M: 0.86 + 0.02 = 0.88
    // N: 0.88 + 0.02 = 0.90
    // R: 0.90 + 0.02 = 0.92
    // S: 0.92 + 0.02 = 0.94
    // V: 0.94 + 0.02 = 0.96
    // W: 0.96 + 0.02 = 0.98
    // Y: 0.98 + 0.02 = 1.00

    if r < 0.27 { 'a' }
    else if r < 0.39 { 'c' }
    else if r < 0.51 { 'g' }
    else if r < 0.78 { 't' }
    else if r < 0.80 { 'B' }
    else if r < 0.82 { 'D' }
    else if r < 0.84 { 'H' }
    else if r < 0.86 { 'K' }
    else if r < 0.88 { 'M' }
    else if r < 0.90 { 'N' }
    else if r < 0.92 { 'R' }
    else if r < 0.94 { 'S' }
    else if r < 0.96 { 'V' }
    else if r < 0.98 { 'W' }
    else { 'Y' }
}

// Human-like DNA frequencies
fn random_nucleotide_homo(r: f64) -> char {
    // Homo sapiens frequencies:
    // a: 0.3029549426680
    // c: 0.1979883004921
    // g: 0.1975473066391
    // t: 0.3015094502008

    if r < 0.3029549426680 { 'a' }
    else if r < 0.5009432431601 { 'c' }  // 0.3029... + 0.1979...
    else if r < 0.6984905497992 { 'g' }  // 0.5009... + 0.1975...
    else { 't' }
}

// Random amino acid
fn random_amino(r: f64) -> char {
    // Amino acid frequencies (simplified)
    if r < 0.08 { 'A' }
    else if r < 0.12 { 'C' }
    else if r < 0.17 { 'D' }
    else if r < 0.23 { 'E' }
    else if r < 0.27 { 'F' }
    else if r < 0.34 { 'G' }
    else if r < 0.38 { 'H' }
    else if r < 0.45 { 'I' }
    else if r < 0.52 { 'K' }
    else if r < 0.60 { 'L' }
    else if r < 0.64 { 'M' }
    else if r < 0.70 { 'N' }
    else if r < 0.75 { 'P' }
    else if r < 0.79 { 'Q' }
    else if r < 0.84 { 'R' }
    else if r < 0.89 { 'S' }
    else if r < 0.94 { 'T' }
    else if r < 0.97 { 'V' }
    else if r < 0.99 { 'W' }
    else { 'Y' }
}

// ===========================================================================
// Sequence Generation
// ===========================================================================

// Generate and print a repeat sequence
fn make_repeat(id: str, desc: str, length: i32) {
    print_str(">");
    print_str(id);
    print_str(" ");
    println_str(desc);

    let mut i = 0;
    let mut line_pos = 0;

    while i < length {
        let c = repeat_char_at(i);
        print_char(c);

        line_pos = line_pos + 1;
        if line_pos >= LINE_WIDTH {
            println_str("");
            line_pos = 0;
        }

        i = i + 1;
    }

    if line_pos > 0 {
        println_str("");
    }
}

// Generate and print a random IUB sequence
fn make_random_iub(id: str, desc: str, length: i32, seed: &mut i32) {
    print_str(">");
    print_str(id);
    print_str(" ");
    println_str(desc);

    let mut i = 0;
    let mut line_pos = 0;

    while i < length {
        let r = lcg_next(seed);
        let c = random_nucleotide_iub(r);
        print_char(c);

        line_pos = line_pos + 1;
        if line_pos >= LINE_WIDTH {
            println_str("");
            line_pos = 0;
        }

        i = i + 1;
    }

    if line_pos > 0 {
        println_str("");
    }
}

// Generate and print a random homo sapiens sequence
fn make_random_homo(id: str, desc: str, length: i32, seed: &mut i32) {
    print_str(">");
    print_str(id);
    print_str(" ");
    println_str(desc);

    let mut i = 0;
    let mut line_pos = 0;

    while i < length {
        let r = lcg_next(seed);
        let c = random_nucleotide_homo(r);
        print_char(c);

        line_pos = line_pos + 1;
        if line_pos >= LINE_WIDTH {
            println_str("");
            line_pos = 0;
        }

        i = i + 1;
    }

    if line_pos > 0 {
        println_str("");
    }
}

// ===========================================================================
// Verification
// ===========================================================================

// Verify LCG produces expected sequence
fn verify_lcg() -> bool {
    let mut seed = 42;

    // First few values from seed=42 should be:
    let r1 = lcg_next(&mut seed);
    let r2 = lcg_next(&mut seed);
    let r3 = lcg_next(&mut seed);

    // Just check they're in valid range
    r1 >= 0.0 && r1 < 1.0 &&
    r2 >= 0.0 && r2 < 1.0 &&
    r3 >= 0.0 && r3 < 1.0
}

// Count nucleotide frequencies in a sample
fn count_frequencies(seed: &mut i32, count: i32) -> (i32, i32, i32, i32) {
    let mut a_count = 0;
    let mut c_count = 0;
    let mut g_count = 0;
    let mut t_count = 0;

    let mut i = 0;
    while i < count {
        let r = lcg_next(seed);
        let c = random_nucleotide_homo(r);

        if c == 'a' { a_count = a_count + 1; }
        else if c == 'c' { c_count = c_count + 1; }
        else if c == 'g' { g_count = g_count + 1; }
        else { t_count = t_count + 1; }

        i = i + 1;
    }

    (a_count, c_count, g_count, t_count)
}

// ===========================================================================
// Main Entry Point
// ===========================================================================

fn main() {
    println_str("================================================================");
    println_str("     FASTA Benchmark for Blood");
    println_str("     (Computer Language Benchmarks Game)");
    println_str("================================================================");
    println_str("");

    // Verify RNG
    println_str("=== RNG Verification ===");
    if verify_lcg() {
        println_str("LCG produces valid random numbers: PASS");
    } else {
        println_str("LCG produces valid random numbers: FAIL");
    }
    println_str("");

    // Check nucleotide frequencies
    println_str("=== Frequency Check (1000 samples) ===");
    let mut seed = 42;
    let (a, c, g, t) = count_frequencies(&mut seed, 1000);
    print_str("A: ");
    println_int(a);
    print_str("C: ");
    println_int(c);
    print_str("G: ");
    println_int(g);
    print_str("T: ");
    println_int(t);
    println_str("Expected ~30% A, ~20% C, ~20% G, ~30% T");
    println_str("");

    // Generate sample sequences
    println_str("=== Sample Output (100 nucleotides each) ===");
    println_str("");

    seed = 42;

    // Small repeat sequence
    make_repeat("ONE", "Cyclic repeat sequence", 100);
    println_str("");

    // Small random IUB sequence
    make_random_iub("TWO", "IUB ambiguity codes", 100, &mut seed);
    println_str("");

    // Small random homo sapiens sequence
    make_random_homo("THREE", "Homo sapiens frequency", 100, &mut seed);
    println_str("");

    println_str("=== Performance Notes ===");
    println_str("");
    println_str("This benchmark tests:");
    println_str("1. Pseudo-random number generation (LCG)");
    println_str("2. Weighted random selection");
    println_str("3. String output formatting");
    println_str("4. Modular arithmetic");
    println_str("5. Conditional branching");
    println_str("");
    println_str("Key insight: Output is deterministic for given seed.");
    println_str("Results should be identical across all implementations.");
    println_str("");

    println_str("================================================================");
    println_str("     Benchmark Complete");
    println_str("================================================================");
}
