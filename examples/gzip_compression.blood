// Gzip Compression Library Example
// Demonstrates: Bit manipulation, FFI bindings to zlib, performance-critical code,
// effect-based error handling, streaming compression, buffer management
//
// Features:
// - Deflate/Inflate compression algorithms
// - Gzip file format support
// - Streaming compression for large files
// - Multiple compression levels
// - CRC32 checksum calculation

// ============================================================================
// FFI Bindings to zlib
// ============================================================================

// zlib constants
const Z_OK: i32 = 0;
const Z_STREAM_END: i32 = 1;
const Z_NEED_DICT: i32 = 2;
const Z_ERRNO: i32 = -1;
const Z_STREAM_ERROR: i32 = -2;
const Z_DATA_ERROR: i32 = -3;
const Z_MEM_ERROR: i32 = -4;
const Z_BUF_ERROR: i32 = -5;
const Z_VERSION_ERROR: i32 = -6;

// Flush modes
const Z_NO_FLUSH: i32 = 0;
const Z_PARTIAL_FLUSH: i32 = 1;
const Z_SYNC_FLUSH: i32 = 2;
const Z_FULL_FLUSH: i32 = 3;
const Z_FINISH: i32 = 4;
const Z_BLOCK: i32 = 5;
const Z_TREES: i32 = 6;

// Compression levels
const Z_NO_COMPRESSION: i32 = 0;
const Z_BEST_SPEED: i32 = 1;
const Z_BEST_COMPRESSION: i32 = 9;
const Z_DEFAULT_COMPRESSION: i32 = -1;

// Gzip magic numbers
const GZIP_MAGIC_1: u8 = 0x1f;
const GZIP_MAGIC_2: u8 = 0x8b;
const GZIP_METHOD_DEFLATE: u8 = 8;

// Gzip flags
const GZIP_FLAG_TEXT: u8 = 0x01;
const GZIP_FLAG_HCRC: u8 = 0x02;
const GZIP_FLAG_EXTRA: u8 = 0x04;
const GZIP_FLAG_NAME: u8 = 0x08;
const GZIP_FLAG_COMMENT: u8 = 0x10;

/// zlib stream structure (opaque in Blood)
#[repr(C)]
struct ZStream {
    next_in: *mut u8,
    avail_in: u32,
    total_in: u64,
    next_out: *mut u8,
    avail_out: u32,
    total_out: u64,
    msg: *const i8,
    state: *mut (),
    zalloc: *mut (),
    zfree: *mut (),
    opaque: *mut (),
    data_type: i32,
    adler: u64,
    reserved: u64,
}

// FFI declarations
extern "C" {
    fn deflateInit_(
        strm: *mut ZStream,
        level: i32,
        version: *const i8,
        stream_size: i32
    ) -> i32;

    fn deflateInit2_(
        strm: *mut ZStream,
        level: i32,
        method: i32,
        windowBits: i32,
        memLevel: i32,
        strategy: i32,
        version: *const i8,
        stream_size: i32
    ) -> i32;

    fn deflate(strm: *mut ZStream, flush: i32) -> i32;
    fn deflateEnd(strm: *mut ZStream) -> i32;

    fn inflateInit_(
        strm: *mut ZStream,
        version: *const i8,
        stream_size: i32
    ) -> i32;

    fn inflateInit2_(
        strm: *mut ZStream,
        windowBits: i32,
        version: *const i8,
        stream_size: i32
    ) -> i32;

    fn inflate(strm: *mut ZStream, flush: i32) -> i32;
    fn inflateEnd(strm: *mut ZStream) -> i32;

    fn crc32(crc: u64, buf: *const u8, len: u32) -> u64;
    fn adler32(adler: u64, buf: *const u8, len: u32) -> u64;
}

// ============================================================================
// Compression Level Enum
// ============================================================================

/// Compression level for gzip/deflate
enum CompressionLevel {
    /// No compression (level 0)
    None,
    /// Fastest compression (level 1)
    Fast,
    /// Best compression (level 9)
    Best,
    /// Default compression (level 6)
    Default,
    /// Custom compression level (1-9)
    Custom(i32),
}

impl CompressionLevel {
    fn to_zlib_level(&self) -> i32 {
        match self {
            CompressionLevel::None => Z_NO_COMPRESSION,
            CompressionLevel::Fast => Z_BEST_SPEED,
            CompressionLevel::Best => Z_BEST_COMPRESSION,
            CompressionLevel::Default => Z_DEFAULT_COMPRESSION,
            CompressionLevel::Custom(level) => {
                if *level < 0 {
                    0
                } else if *level > 9 {
                    9
                } else {
                    *level
                }
            },
        }
    }
}

// ============================================================================
// Effects
// ============================================================================

/// Effect for compression errors
effect CompressionError {
    op error(msg: String) -> !;
    op warning(msg: String) -> ();
}

/// Convert zlib error code to string
fn zlib_error_string(code: i32) -> String {
    match code {
        Z_OK => "OK".to_string(),
        Z_STREAM_END => "Stream end".to_string(),
        Z_NEED_DICT => "Need dictionary".to_string(),
        Z_ERRNO => "File error".to_string(),
        Z_STREAM_ERROR => "Stream error".to_string(),
        Z_DATA_ERROR => "Data error (invalid or incomplete)".to_string(),
        Z_MEM_ERROR => "Memory error".to_string(),
        Z_BUF_ERROR => "Buffer error".to_string(),
        Z_VERSION_ERROR => "zlib version mismatch".to_string(),
        _ => format!("Unknown zlib error: {}", code),
    }
}

// ============================================================================
// CRC32 Checksum (Pure Blood Implementation)
// ============================================================================

/// CRC32 lookup table
static CRC32_TABLE: [u32; 256] = generate_crc32_table();

/// Generate CRC32 lookup table at compile time
const fn generate_crc32_table() -> [u32; 256] {
    let mut table = [0u32; 256];
    let mut i = 0;

    while i < 256 {
        let mut crc = i as u32;
        let mut j = 0;
        while j < 8 {
            if crc & 1 != 0 {
                crc = 0xEDB88320 ^ (crc >> 1);
            } else {
                crc = crc >> 1;
            }
            j = j + 1;
        }
        table[i] = crc;
        i = i + 1;
    }

    table
}

/// Calculate CRC32 checksum
fn crc32_checksum(data: &[u8]) -> u32 {
    let mut crc = 0xFFFFFFFF;

    for byte in data {
        let index = ((crc ^ (*byte as u32)) & 0xFF) as usize;
        crc = CRC32_TABLE[index] ^ (crc >> 8);
    }

    crc ^ 0xFFFFFFFF
}

/// Update CRC32 with additional data
fn crc32_update(crc: u32, data: &[u8]) -> u32 {
    let mut crc = crc ^ 0xFFFFFFFF;

    for byte in data {
        let index = ((crc ^ (*byte as u32)) & 0xFF) as usize;
        crc = CRC32_TABLE[index] ^ (crc >> 8);
    }

    crc ^ 0xFFFFFFFF
}

// ============================================================================
// Deflate Compression
// ============================================================================

/// Deflate compressor
struct Deflater {
    level: CompressionLevel,
    buffer_size: usize,
}

impl Deflater {
    fn new() -> Deflater {
        Deflater {
            level: CompressionLevel::Default,
            buffer_size: 32768,
        }
    }

    fn with_level(mut self, level: CompressionLevel) -> Deflater {
        self.level = level;
        self
    }

    fn with_buffer_size(mut self, size: usize) -> Deflater {
        self.buffer_size = size;
        self
    }

    /// Compress data using deflate algorithm
    fn compress(&self, data: &[u8]) -> Vec<u8> / {CompressionError} {
        if data.is_empty() {
            return Vec::new();
        }

        let mut stream = ZStream::zeroed();
        let mut output = Vec::new();

        // Initialize deflate
        let ret = @unsafe {
            deflateInit_(
                &mut stream,
                self.level.to_zlib_level(),
                b"1.2.11\0".as_ptr() as *const i8,
                std::mem::size_of::<ZStream>() as i32
            )
        };

        if ret != Z_OK {
            perform CompressionError.error(format!("deflateInit failed: {}", zlib_error_string(ret)));
        }

        // Allocate output buffer
        let mut out_buffer = vec![0u8; self.buffer_size];

        // Set input
        stream.next_in = data.as_ptr() as *mut u8;
        stream.avail_in = data.len() as u32;

        // Compress
        loop {
            stream.next_out = out_buffer.as_mut_ptr();
            stream.avail_out = out_buffer.len() as u32;

            let ret = @unsafe { deflate(&mut stream, Z_FINISH) };

            // Copy output
            let have = out_buffer.len() - stream.avail_out as usize;
            output.extend_from_slice(&out_buffer[..have]);

            if ret == Z_STREAM_END {
                break;
            }

            if ret != Z_OK {
                @unsafe { deflateEnd(&mut stream) };
                perform CompressionError.error(format!("deflate failed: {}", zlib_error_string(ret)));
            }
        }

        // Clean up
        @unsafe { deflateEnd(&mut stream) };

        output
    }
}

// ============================================================================
// Inflate Decompression
// ============================================================================

/// Inflate decompressor
struct Inflater {
    buffer_size: usize,
}

impl Inflater {
    fn new() -> Inflater {
        Inflater {
            buffer_size: 32768,
        }
    }

    fn with_buffer_size(mut self, size: usize) -> Inflater {
        self.buffer_size = size;
        self
    }

    /// Decompress deflate data
    fn decompress(&self, data: &[u8]) -> Vec<u8> / {CompressionError} {
        if data.is_empty() {
            return Vec::new();
        }

        let mut stream = ZStream::zeroed();
        let mut output = Vec::new();

        // Initialize inflate
        let ret = @unsafe {
            inflateInit_(
                &mut stream,
                b"1.2.11\0".as_ptr() as *const i8,
                std::mem::size_of::<ZStream>() as i32
            )
        };

        if ret != Z_OK {
            perform CompressionError.error(format!("inflateInit failed: {}", zlib_error_string(ret)));
        }

        // Allocate output buffer
        let mut out_buffer = vec![0u8; self.buffer_size];

        // Set input
        stream.next_in = data.as_ptr() as *mut u8;
        stream.avail_in = data.len() as u32;

        // Decompress
        loop {
            stream.next_out = out_buffer.as_mut_ptr();
            stream.avail_out = out_buffer.len() as u32;

            let ret = @unsafe { inflate(&mut stream, Z_NO_FLUSH) };

            // Copy output
            let have = out_buffer.len() - stream.avail_out as usize;
            output.extend_from_slice(&out_buffer[..have]);

            if ret == Z_STREAM_END {
                break;
            }

            if ret != Z_OK {
                @unsafe { inflateEnd(&mut stream) };
                perform CompressionError.error(format!("inflate failed: {}", zlib_error_string(ret)));
            }

            if stream.avail_in == 0 {
                break;
            }
        }

        // Clean up
        @unsafe { inflateEnd(&mut stream) };

        output
    }
}

// ============================================================================
// Gzip Format
// ============================================================================

/// Gzip header information
struct GzipHeader {
    /// Compression method (always 8 = deflate)
    method: u8,
    /// Flags byte
    flags: u8,
    /// Modification time (Unix timestamp)
    mtime: u32,
    /// Extra flags
    xfl: u8,
    /// Operating system
    os: u8,
    /// Original filename (if FLAG_NAME set)
    filename: Option<String>,
    /// Comment (if FLAG_COMMENT set)
    comment: Option<String>,
}

impl GzipHeader {
    fn new() -> GzipHeader {
        GzipHeader {
            method: GZIP_METHOD_DEFLATE,
            flags: 0,
            mtime: 0,
            xfl: 0,
            os: 255,  // Unknown
            filename: None,
            comment: None,
        }
    }

    fn with_filename(mut self, name: &str) -> GzipHeader {
        self.filename = Some(name.to_string());
        self.flags |= GZIP_FLAG_NAME;
        self
    }

    fn with_comment(mut self, comment: &str) -> GzipHeader {
        self.comment = Some(comment.to_string());
        self.flags |= GZIP_FLAG_COMMENT;
        self
    }

    fn with_mtime(mut self, mtime: u32) -> GzipHeader {
        self.mtime = mtime;
        self
    }

    /// Encode header to bytes
    fn encode(&self) -> Vec<u8> {
        let mut header = Vec::new();

        // Magic number
        header.push(GZIP_MAGIC_1);
        header.push(GZIP_MAGIC_2);

        // Compression method
        header.push(self.method);

        // Flags
        header.push(self.flags);

        // Modification time (little-endian)
        header.push((self.mtime & 0xFF) as u8);
        header.push(((self.mtime >> 8) & 0xFF) as u8);
        header.push(((self.mtime >> 16) & 0xFF) as u8);
        header.push(((self.mtime >> 24) & 0xFF) as u8);

        // Extra flags
        header.push(self.xfl);

        // Operating system
        header.push(self.os);

        // Filename (if present)
        if let Some(ref name) = self.filename {
            for byte in name.bytes() {
                header.push(byte);
            }
            header.push(0);  // Null terminator
        }

        // Comment (if present)
        if let Some(ref comment) = self.comment {
            for byte in comment.bytes() {
                header.push(byte);
            }
            header.push(0);  // Null terminator
        }

        header
    }

    /// Decode header from bytes, returns header and number of bytes consumed
    fn decode(data: &[u8]) -> Option<(GzipHeader, usize)> / {CompressionError} {
        if data.len() < 10 {
            perform CompressionError.error("Gzip header too short".to_string());
        }

        // Check magic number
        if data[0] != GZIP_MAGIC_1 || data[1] != GZIP_MAGIC_2 {
            perform CompressionError.error("Invalid gzip magic number".to_string());
        }

        let method = data[2];
        if method != GZIP_METHOD_DEFLATE {
            perform CompressionError.error(format!("Unsupported compression method: {}", method));
        }

        let flags = data[3];

        let mtime = (data[4] as u32)
                  | ((data[5] as u32) << 8)
                  | ((data[6] as u32) << 16)
                  | ((data[7] as u32) << 24);

        let xfl = data[8];
        let os = data[9];

        let mut pos = 10;

        // Skip extra field if present
        if flags & GZIP_FLAG_EXTRA != 0 {
            if pos + 2 > data.len() {
                perform CompressionError.error("Invalid gzip extra field".to_string());
            }
            let xlen = (data[pos] as usize) | ((data[pos + 1] as usize) << 8);
            pos += 2 + xlen;
        }

        // Read filename if present
        let filename = if flags & GZIP_FLAG_NAME != 0 {
            let start = pos;
            while pos < data.len() && data[pos] != 0 {
                pos += 1;
            }
            if pos >= data.len() {
                perform CompressionError.error("Unterminated gzip filename".to_string());
            }
            let name = String::from_utf8_lossy(&data[start..pos]).to_string();
            pos += 1;  // Skip null terminator
            Some(name)
        } else {
            None
        };

        // Read comment if present
        let comment = if flags & GZIP_FLAG_COMMENT != 0 {
            let start = pos;
            while pos < data.len() && data[pos] != 0 {
                pos += 1;
            }
            if pos >= data.len() {
                perform CompressionError.error("Unterminated gzip comment".to_string());
            }
            let cmt = String::from_utf8_lossy(&data[start..pos]).to_string();
            pos += 1;  // Skip null terminator
            Some(cmt)
        } else {
            None
        };

        // Skip header CRC if present
        if flags & GZIP_FLAG_HCRC != 0 {
            pos += 2;
        }

        let header = GzipHeader {
            method: method,
            flags: flags,
            mtime: mtime,
            xfl: xfl,
            os: os,
            filename: filename,
            comment: comment,
        };

        Some((header, pos))
    }
}

// ============================================================================
// Gzip Compressor
// ============================================================================

/// Gzip compressor
struct GzipCompressor {
    level: CompressionLevel,
    header: GzipHeader,
}

impl GzipCompressor {
    fn new() -> GzipCompressor {
        GzipCompressor {
            level: CompressionLevel::Default,
            header: GzipHeader::new(),
        }
    }

    fn with_level(mut self, level: CompressionLevel) -> GzipCompressor {
        self.level = level;
        // Set extra flags based on level
        match level {
            CompressionLevel::Best => self.header.xfl = 2,
            CompressionLevel::Fast => self.header.xfl = 4,
            _ => self.header.xfl = 0,
        }
        self
    }

    fn with_filename(mut self, name: &str) -> GzipCompressor {
        self.header = self.header.with_filename(name);
        self
    }

    fn with_comment(mut self, comment: &str) -> GzipCompressor {
        self.header = self.header.with_comment(comment);
        self
    }

    fn with_mtime(mut self, mtime: u32) -> GzipCompressor {
        self.header = self.header.with_mtime(mtime);
        self
    }

    /// Compress data to gzip format
    fn compress(&self, data: &[u8]) -> Vec<u8> / {CompressionError} {
        let mut output = Vec::new();

        // Write gzip header
        output.extend(self.header.encode());

        // Compress data with raw deflate (windowBits = -15)
        let compressed = self.deflate_raw(data)?;
        output.extend(compressed);

        // Write trailer (CRC32 and original size)
        let crc = crc32_checksum(data);
        let size = data.len() as u32;

        // CRC32 (little-endian)
        output.push((crc & 0xFF) as u8);
        output.push(((crc >> 8) & 0xFF) as u8);
        output.push(((crc >> 16) & 0xFF) as u8);
        output.push(((crc >> 24) & 0xFF) as u8);

        // Original size (little-endian, mod 2^32)
        output.push((size & 0xFF) as u8);
        output.push(((size >> 8) & 0xFF) as u8);
        output.push(((size >> 16) & 0xFF) as u8);
        output.push(((size >> 24) & 0xFF) as u8);

        output
    }

    /// Raw deflate compression (no zlib header)
    fn deflate_raw(&self, data: &[u8]) -> Vec<u8> / {CompressionError} {
        if data.is_empty() {
            // Empty input produces empty deflate block
            return vec![0x03, 0x00];
        }

        let mut stream = ZStream::zeroed();
        let mut output = Vec::new();

        // Initialize with negative windowBits for raw deflate
        let ret = @unsafe {
            deflateInit2_(
                &mut stream,
                self.level.to_zlib_level(),
                8,    // Z_DEFLATED
                -15,  // Negative for raw deflate
                8,    // memLevel
                0,    // Z_DEFAULT_STRATEGY
                b"1.2.11\0".as_ptr() as *const i8,
                std::mem::size_of::<ZStream>() as i32
            )
        };

        if ret != Z_OK {
            perform CompressionError.error(format!("deflateInit2 failed: {}", zlib_error_string(ret)));
        }

        let mut out_buffer = vec![0u8; 32768];

        stream.next_in = data.as_ptr() as *mut u8;
        stream.avail_in = data.len() as u32;

        loop {
            stream.next_out = out_buffer.as_mut_ptr();
            stream.avail_out = out_buffer.len() as u32;

            let ret = @unsafe { deflate(&mut stream, Z_FINISH) };

            let have = out_buffer.len() - stream.avail_out as usize;
            output.extend_from_slice(&out_buffer[..have]);

            if ret == Z_STREAM_END {
                break;
            }

            if ret != Z_OK {
                @unsafe { deflateEnd(&mut stream) };
                perform CompressionError.error(format!("deflate failed: {}", zlib_error_string(ret)));
            }
        }

        @unsafe { deflateEnd(&mut stream) };

        output
    }
}

// ============================================================================
// Gzip Decompressor
// ============================================================================

/// Gzip decompressor
struct GzipDecompressor;

impl GzipDecompressor {
    fn new() -> GzipDecompressor {
        GzipDecompressor
    }

    /// Decompress gzip data
    fn decompress(&self, data: &[u8]) -> Vec<u8> / {CompressionError} {
        if data.len() < 18 {  // Minimum gzip file size
            perform CompressionError.error("Gzip data too short".to_string());
        }

        // Parse header
        let (header, header_len) = match GzipHeader::decode(data) {
            Some((h, len)) => (h, len),
            None => perform CompressionError.error("Failed to parse gzip header".to_string()),
        };

        // Compressed data is between header and trailer
        let trailer_start = data.len() - 8;
        if header_len >= trailer_start {
            perform CompressionError.error("Invalid gzip structure".to_string());
        }

        let compressed = &data[header_len..trailer_start];

        // Parse trailer
        let expected_crc = (data[trailer_start] as u32)
                        | ((data[trailer_start + 1] as u32) << 8)
                        | ((data[trailer_start + 2] as u32) << 16)
                        | ((data[trailer_start + 3] as u32) << 24);

        let expected_size = (data[trailer_start + 4] as u32)
                         | ((data[trailer_start + 5] as u32) << 8)
                         | ((data[trailer_start + 6] as u32) << 16)
                         | ((data[trailer_start + 7] as u32) << 24);

        // Decompress with raw inflate
        let decompressed = self.inflate_raw(compressed)?;

        // Verify CRC
        let actual_crc = crc32_checksum(&decompressed);
        if actual_crc != expected_crc {
            perform CompressionError.error(format!(
                "CRC mismatch: expected {:08x}, got {:08x}",
                expected_crc, actual_crc
            ));
        }

        // Verify size (mod 2^32)
        let actual_size = (decompressed.len() as u32) & 0xFFFFFFFF;
        if actual_size != expected_size {
            perform CompressionError.warning(format!(
                "Size mismatch: expected {}, got {}",
                expected_size, actual_size
            ));
        }

        decompressed
    }

    /// Get header info without decompressing
    fn header(&self, data: &[u8]) -> Option<GzipHeader> / {CompressionError} {
        match GzipHeader::decode(data) {
            Some((h, _)) => Some(h),
            None => None,
        }
    }

    /// Raw inflate decompression
    fn inflate_raw(&self, data: &[u8]) -> Vec<u8> / {CompressionError} {
        if data.is_empty() {
            return Vec::new();
        }

        let mut stream = ZStream::zeroed();
        let mut output = Vec::new();

        // Initialize with negative windowBits for raw inflate
        let ret = @unsafe {
            inflateInit2_(
                &mut stream,
                -15,  // Negative for raw inflate
                b"1.2.11\0".as_ptr() as *const i8,
                std::mem::size_of::<ZStream>() as i32
            )
        };

        if ret != Z_OK {
            perform CompressionError.error(format!("inflateInit2 failed: {}", zlib_error_string(ret)));
        }

        let mut out_buffer = vec![0u8; 32768];

        stream.next_in = data.as_ptr() as *mut u8;
        stream.avail_in = data.len() as u32;

        loop {
            stream.next_out = out_buffer.as_mut_ptr();
            stream.avail_out = out_buffer.len() as u32;

            let ret = @unsafe { inflate(&mut stream, Z_NO_FLUSH) };

            let have = out_buffer.len() - stream.avail_out as usize;
            output.extend_from_slice(&out_buffer[..have]);

            if ret == Z_STREAM_END {
                break;
            }

            if ret != Z_OK {
                @unsafe { inflateEnd(&mut stream) };
                perform CompressionError.error(format!("inflate failed: {}", zlib_error_string(ret)));
            }

            if stream.avail_in == 0 {
                break;
            }
        }

        @unsafe { inflateEnd(&mut stream) };

        output
    }
}

// ============================================================================
// Streaming Compression
// ============================================================================

/// Streaming gzip compressor for large files
struct StreamingCompressor {
    level: CompressionLevel,
    stream: Option<ZStream>,
    crc: u32,
    total_in: u64,
    header_written: bool,
}

impl StreamingCompressor {
    fn new(level: CompressionLevel) -> StreamingCompressor / {CompressionError} {
        let mut compressor = StreamingCompressor {
            level: level,
            stream: None,
            crc: 0,
            total_in: 0,
            header_written: false,
        };

        compressor.init()?;
        compressor
    }

    fn init(mut self) / {CompressionError} {
        let mut stream = ZStream::zeroed();

        let ret = @unsafe {
            deflateInit2_(
                &mut stream,
                self.level.to_zlib_level(),
                8,    // Z_DEFLATED
                -15,  // Raw deflate for gzip
                8,    // memLevel
                0,    // Z_DEFAULT_STRATEGY
                b"1.2.11\0".as_ptr() as *const i8,
                std::mem::size_of::<ZStream>() as i32
            )
        };

        if ret != Z_OK {
            perform CompressionError.error(format!("deflateInit2 failed: {}", zlib_error_string(ret)));
        }

        self.stream = Some(stream);
    }

    /// Write header to output
    fn write_header(&mut self, filename: Option<&str>) -> Vec<u8> {
        self.header_written = true;

        let mut header = GzipHeader::new();
        if let Some(name) = filename {
            header = header.with_filename(name);
        }

        header.encode()
    }

    /// Compress a chunk of data
    fn compress_chunk(&mut self, data: &[u8], finish: bool) -> Vec<u8> / {CompressionError} {
        let stream = match &mut self.stream {
            Some(s) => s,
            None => perform CompressionError.error("Compressor not initialized".to_string()),
        };

        // Update CRC and total
        if !data.is_empty() {
            self.crc = crc32_update(self.crc, data);
            self.total_in += data.len() as u64;
        }

        let mut output = Vec::new();
        let mut out_buffer = vec![0u8; 32768];

        stream.next_in = data.as_ptr() as *mut u8;
        stream.avail_in = data.len() as u32;

        let flush = if finish { Z_FINISH } else { Z_NO_FLUSH };

        loop {
            stream.next_out = out_buffer.as_mut_ptr();
            stream.avail_out = out_buffer.len() as u32;

            let ret = @unsafe { deflate(stream, flush) };

            let have = out_buffer.len() - stream.avail_out as usize;
            output.extend_from_slice(&out_buffer[..have]);

            if ret == Z_STREAM_END {
                break;
            }

            if ret != Z_OK && ret != Z_BUF_ERROR {
                perform CompressionError.error(format!("deflate failed: {}", zlib_error_string(ret)));
            }

            if stream.avail_out != 0 {
                break;
            }
        }

        output
    }

    /// Finish compression and return trailer
    fn finish(&mut self) -> Vec<u8> / {CompressionError} {
        // Compress remaining with finish flag
        let final_data = self.compress_chunk(&[], true)?;

        // Clean up zlib
        if let Some(ref mut stream) = self.stream {
            @unsafe { deflateEnd(stream) };
        }
        self.stream = None;

        // Build trailer
        let mut trailer = final_data;

        // CRC32
        trailer.push((self.crc & 0xFF) as u8);
        trailer.push(((self.crc >> 8) & 0xFF) as u8);
        trailer.push(((self.crc >> 16) & 0xFF) as u8);
        trailer.push(((self.crc >> 24) & 0xFF) as u8);

        // Size (mod 2^32)
        let size = (self.total_in & 0xFFFFFFFF) as u32;
        trailer.push((size & 0xFF) as u8);
        trailer.push(((size >> 8) & 0xFF) as u8);
        trailer.push(((size >> 16) & 0xFF) as u8);
        trailer.push(((size >> 24) & 0xFF) as u8);

        trailer
    }
}

impl Drop for StreamingCompressor {
    fn drop(&mut self) {
        if let Some(ref mut stream) = self.stream {
            @unsafe { deflateEnd(stream) };
        }
    }
}

// ============================================================================
// Convenience Functions
// ============================================================================

/// Compress data to gzip format
fn gzip_compress(data: &[u8]) -> Vec<u8> / {CompressionError} {
    GzipCompressor::new().compress(data)
}

/// Compress data to gzip format with options
fn gzip_compress_with(
    data: &[u8],
    level: CompressionLevel,
    filename: Option<&str>
) -> Vec<u8> / {CompressionError} {
    let mut compressor = GzipCompressor::new().with_level(level);

    if let Some(name) = filename {
        compressor = compressor.with_filename(name);
    }

    compressor.compress(data)
}

/// Decompress gzip data
fn gzip_decompress(data: &[u8]) -> Vec<u8> / {CompressionError} {
    GzipDecompressor::new().decompress(data)
}

/// Compress data using deflate
fn deflate_compress(data: &[u8]) -> Vec<u8> / {CompressionError} {
    Deflater::new().compress(data)
}

/// Decompress deflate data
fn deflate_decompress(data: &[u8]) -> Vec<u8> / {CompressionError} {
    Inflater::new().decompress(data)
}

// ============================================================================
// ZStream Helper
// ============================================================================

impl ZStream {
    fn zeroed() -> ZStream {
        ZStream {
            next_in: std::ptr::null_mut(),
            avail_in: 0,
            total_in: 0,
            next_out: std::ptr::null_mut(),
            avail_out: 0,
            total_out: 0,
            msg: std::ptr::null(),
            state: std::ptr::null_mut(),
            zalloc: std::ptr::null_mut(),
            zfree: std::ptr::null_mut(),
            opaque: std::ptr::null_mut(),
            data_type: 0,
            adler: 0,
            reserved: 0,
        }
    }
}

// ============================================================================
// Example Usage
// ============================================================================

fn main() -> i32 / {IO, CompressionError} {
    print("=== Blood Gzip Compression Library ===\n");

    // Test data
    let original = "Hello, World! This is a test of gzip compression in Blood.
    The quick brown fox jumps over the lazy dog.
    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    Repetitive text compresses well: aaaaaaaaaaaaaaaaaaaaaaaaaaaa
    More repetitive text: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    ".as_bytes();

    print("Original size: {} bytes", original.len());

    // Test CRC32
    let crc = crc32_checksum(original);
    print("CRC32 checksum: {:08x}", crc);

    // Test gzip compression
    print("\n--- Gzip Compression ---");

    let compressed = try {
        GzipCompressor::new()
            .with_level(CompressionLevel::Best)
            .with_filename("test.txt")
            .with_comment("Compressed by Blood")
            .compress(original)
    } with {
        CompressionError::error(msg) => {
            print("Compression error: {}", msg);
            return 1;
        },
        CompressionError::warning(msg) => {
            print("Warning: {}", msg);
            resume(())
        },
    };

    print("Compressed size: {} bytes", compressed.len());
    print("Compression ratio: {:.1}%",
          (1.0 - (compressed.len() as f64 / original.len() as f64)) * 100.0);

    // Test decompression
    print("\n--- Gzip Decompression ---");

    let decompressed = try {
        GzipDecompressor::new().decompress(&compressed)
    } with {
        CompressionError::error(msg) => {
            print("Decompression error: {}", msg);
            return 1;
        },
        CompressionError::warning(msg) => {
            print("Warning: {}", msg);
            resume(())
        },
    };

    print("Decompressed size: {} bytes", decompressed.len());

    // Verify
    if decompressed == original {
        print("Verification: SUCCESS - decompressed matches original");
    } else {
        print("Verification: FAILED - data mismatch!");
        return 1;
    }

    // Test header parsing
    print("\n--- Header Info ---");
    if let Some(header) = try {
        GzipDecompressor::new().header(&compressed)
    } with {
        CompressionError::error(_) => None,
        CompressionError::warning(_) => { resume(()); None },
    } {
        print("Method: {}", header.method);
        print("Flags: 0x{:02x}", header.flags);
        if let Some(name) = header.filename {
            print("Filename: {}", name);
        }
        if let Some(comment) = header.comment {
            print("Comment: {}", comment);
        }
    }

    // Test different compression levels
    print("\n--- Compression Levels ---");

    let test_data = "a".repeat(10000).as_bytes().to_vec();

    for level in [CompressionLevel::None, CompressionLevel::Fast,
                  CompressionLevel::Default, CompressionLevel::Best] {
        let level_name = match &level {
            CompressionLevel::None => "None",
            CompressionLevel::Fast => "Fast",
            CompressionLevel::Default => "Default",
            CompressionLevel::Best => "Best",
            CompressionLevel::Custom(_) => "Custom",
        };

        let compressed = try {
            GzipCompressor::new()
                .with_level(level)
                .compress(&test_data)
        } with {
            CompressionError::error(msg) => {
                print("  {}: Error - {}", level_name, msg);
                continue;
            },
            CompressionError::warning(msg) => { resume(()); Vec::new() },
        };

        print("  {}: {} -> {} bytes ({:.1}% compression)",
              level_name, test_data.len(), compressed.len(),
              (1.0 - (compressed.len() as f64 / test_data.len() as f64)) * 100.0);
    }

    // Test streaming compression
    print("\n--- Streaming Compression ---");

    let mut streaming = try {
        StreamingCompressor::new(CompressionLevel::Default)
    } with {
        CompressionError::error(msg) => {
            print("Failed to create streaming compressor: {}", msg);
            return 1;
        },
        CompressionError::warning(_) => { resume(()); panic!() },
    };

    let mut stream_output = Vec::new();

    // Write header
    stream_output.extend(streaming.write_header(Some("streamed.txt")));

    // Write chunks
    let chunks = [
        b"First chunk of data. ",
        b"Second chunk of data. ",
        b"Third and final chunk.",
    ];

    for (i, chunk) in chunks.iter().enumerate() {
        let compressed_chunk = try {
            streaming.compress_chunk(*chunk, false)
        } with {
            CompressionError::error(msg) => {
                print("Chunk {} error: {}", i, msg);
                return 1;
            },
            CompressionError::warning(_) => { resume(()); Vec::new() },
        };
        stream_output.extend(compressed_chunk);
        print("  Chunk {}: {} bytes -> {} compressed bytes",
              i + 1, chunk.len(), compressed_chunk.len());
    }

    // Finish
    let trailer = try {
        streaming.finish()
    } with {
        CompressionError::error(msg) => {
            print("Finish error: {}", msg);
            return 1;
        },
        CompressionError::warning(_) => { resume(()); Vec::new() },
    };
    stream_output.extend(trailer);

    print("  Total streamed output: {} bytes", stream_output.len());

    // Verify streaming output
    let stream_decompressed = try {
        GzipDecompressor::new().decompress(&stream_output)
    } with {
        CompressionError::error(msg) => {
            print("Stream decompression error: {}", msg);
            return 1;
        },
        CompressionError::warning(_) => { resume(()); Vec::new() },
    };

    let expected: Vec<u8> = chunks.iter().flat_map(|c| c.iter().copied()).collect();
    if stream_decompressed == expected {
        print("  Streaming verification: SUCCESS");
    } else {
        print("  Streaming verification: FAILED");
        return 1;
    }

    print("\n=== All tests passed! ===");
    0
}
