// HTTP Server in Blood
// A complete HTTP/1.1 server demonstrating Blood's effect system,
// concurrency primitives, and routing capabilities.
//
// This example shows:
// - TCP server via the Net effect
// - HTTP/1.1 protocol parsing and response generation
// - Router with path matching and HTTP methods
// - Middleware pattern using effect handlers
// - Concurrent request handling with fibers
// - Effect-based error handling
// - Resource management for connections

// ===========================================================================
// 1. HTTP Types (shared with http_client.blood)
// ===========================================================================

/// HTTP request method
enum HttpMethod {
    Get,
    Post,
    Put,
    Delete,
    Patch,
    Head,
    Options,
}

impl HttpMethod {
    fn as_str(&self) -> &str / pure {
        match self {
            HttpMethod::Get => "GET",
            HttpMethod::Post => "POST",
            HttpMethod::Put => "PUT",
            HttpMethod::Delete => "DELETE",
            HttpMethod::Patch => "PATCH",
            HttpMethod::Head => "HEAD",
            HttpMethod::Options => "OPTIONS",
        }
    }

    fn from_str(s: &str) -> Option<HttpMethod> / pure {
        match s {
            "GET" => Some(HttpMethod::Get),
            "POST" => Some(HttpMethod::Post),
            "PUT" => Some(HttpMethod::Put),
            "DELETE" => Some(HttpMethod::Delete),
            "PATCH" => Some(HttpMethod::Patch),
            "HEAD" => Some(HttpMethod::Head),
            "OPTIONS" => Some(HttpMethod::Options),
            _ => None,
        }
    }
}

/// HTTP header
struct Header {
    name: String,
    value: String,
}

impl Header {
    fn new(name: &str, value: &str) -> Header / pure {
        Header {
            name: name.to_string(),
            value: value.to_string(),
        }
    }

    fn to_line(&self) -> String / pure {
        format!("{}: {}\r\n", self.name, self.value)
    }
}

/// Incoming HTTP request
struct Request {
    method: HttpMethod,
    path: String,
    query: Option<String>,
    headers: Vec<Header>,
    body: Vec<u8>,
    remote_addr: SocketAddr,
}

impl Request {
    /// Get a header value by name (case-insensitive)
    fn get_header(&self, name: &str) -> Option<&str> / pure {
        let name_lower = name.to_lowercase();
        for header in &self.headers {
            if header.name.to_lowercase() == name_lower {
                return Some(&header.value);
            }
        }
        None
    }

    /// Get body as string (assumes UTF-8)
    fn body_text(&self) -> Result<String, ServerError> / pure {
        String::from_utf8(self.body.clone())
            .map_err(|_| ServerError::InvalidRequest("body is not valid UTF-8"))
    }

    /// Get query parameter by name
    fn query_param(&self, name: &str) -> Option<String> / pure {
        let query = self.query.as_ref()?;
        for pair in query.split('&') {
            if let Some(eq_idx) = pair.find('=') {
                let key = &pair[..eq_idx];
                let value = &pair[eq_idx + 1..];
                if key == name {
                    return Some(url_decode(value));
                }
            }
        }
        None
    }

    /// Get path segments
    fn path_segments(&self) -> Vec<&str> / pure {
        self.path.split('/')
            .filter(|s| !s.is_empty())
            .collect()
    }
}

/// HTTP response builder
struct Response {
    status_code: u16,
    status_text: String,
    headers: Vec<Header>,
    body: Vec<u8>,
}

impl Response {
    /// Create a new response with status code
    fn new(status_code: u16) -> Response / pure {
        let status_text = match status_code {
            200 => "OK",
            201 => "Created",
            204 => "No Content",
            301 => "Moved Permanently",
            302 => "Found",
            304 => "Not Modified",
            400 => "Bad Request",
            401 => "Unauthorized",
            403 => "Forbidden",
            404 => "Not Found",
            405 => "Method Not Allowed",
            500 => "Internal Server Error",
            502 => "Bad Gateway",
            503 => "Service Unavailable",
            _ => "Unknown",
        };

        Response {
            status_code,
            status_text: status_text.to_string(),
            headers: Vec::new(),
            body: Vec::new(),
        }
    }

    /// Create 200 OK response
    fn ok() -> Response / pure {
        Response::new(200)
    }

    /// Create 201 Created response
    fn created() -> Response / pure {
        Response::new(201)
    }

    /// Create 204 No Content response
    fn no_content() -> Response / pure {
        Response::new(204)
    }

    /// Create 400 Bad Request response
    fn bad_request() -> Response / pure {
        Response::new(400)
    }

    /// Create 404 Not Found response
    fn not_found() -> Response / pure {
        Response::new(404)
    }

    /// Create 405 Method Not Allowed response
    fn method_not_allowed() -> Response / pure {
        Response::new(405)
    }

    /// Create 500 Internal Server Error response
    fn internal_error() -> Response / pure {
        Response::new(500)
    }

    /// Add a header
    fn header(mut self, name: &str, value: &str) -> Response / pure {
        self.headers.push(Header::new(name, value));
        self
    }

    /// Set body as bytes
    fn body(mut self, data: Vec<u8>) -> Response / pure {
        self.body = data;
        self
    }

    /// Set body as text with Content-Type: text/plain
    fn text(mut self, text: &str) -> Response / pure {
        self.body = text.as_bytes().to_vec();
        self.headers.push(Header::new("Content-Type", "text/plain; charset=utf-8"));
        self
    }

    /// Set body as HTML with Content-Type: text/html
    fn html(mut self, html: &str) -> Response / pure {
        self.body = html.as_bytes().to_vec();
        self.headers.push(Header::new("Content-Type", "text/html; charset=utf-8"));
        self
    }

    /// Set body as JSON with Content-Type: application/json
    fn json(mut self, json: &str) -> Response / pure {
        self.body = json.as_bytes().to_vec();
        self.headers.push(Header::new("Content-Type", "application/json"));
        self
    }

    /// Redirect to another URL
    fn redirect(url: &str) -> Response / pure {
        Response::new(302)
            .header("Location", url)
    }

    /// Serialize response to bytes
    fn to_bytes(&self) -> Vec<u8> / pure {
        let mut buf = String::new();

        // Status line
        buf.push_str(&format!("HTTP/1.1 {} {}\r\n", self.status_code, self.status_text));

        // Content-Length header
        buf.push_str(&format!("Content-Length: {}\r\n", self.body.len()));

        // Custom headers
        for header in &self.headers {
            buf.push_str(&header.to_line());
        }

        // Connection header
        buf.push_str("Connection: close\r\n");

        // End of headers
        buf.push_str("\r\n");

        let mut bytes = buf.into_bytes();
        bytes.extend_from_slice(&self.body);
        bytes
    }
}

/// Server errors
enum ServerError {
    InvalidRequest(&str),
    IoError(IoError),
    BindFailed(String),
    HandlerPanic(String),
}

impl ServerError {
    fn to_string(&self) -> String / pure {
        match self {
            ServerError::InvalidRequest(msg) => format!("Invalid request: {}", msg),
            ServerError::IoError(e) => format!("IO error: {:?}", e),
            ServerError::BindFailed(msg) => format!("Bind failed: {}", msg),
            ServerError::HandlerPanic(msg) => format!("Handler panic: {}", msg),
        }
    }
}

// ===========================================================================
// 2. Router
// ===========================================================================

/// Route pattern for matching requests
struct Route {
    method: HttpMethod,
    pattern: String,
    handler_id: u32,
}

impl Route {
    fn new(method: HttpMethod, pattern: &str, handler_id: u32) -> Route / pure {
        Route {
            method,
            pattern: pattern.to_string(),
            handler_id,
        }
    }

    /// Check if this route matches the request
    fn matches(&self, req: &Request) -> Option<RouteParams> / pure {
        // Check method
        if req.method.as_str() != self.method.as_str() {
            return None;
        }

        // Match pattern against path
        self.match_pattern(&req.path)
    }

    /// Match pattern against path, extracting parameters
    fn match_pattern(&self, path: &str) -> Option<RouteParams> / pure {
        let pattern_parts: Vec<&str> = self.pattern.split('/').filter(|s| !s.is_empty()).collect();
        let path_parts: Vec<&str> = path.split('/').filter(|s| !s.is_empty()).collect();

        if pattern_parts.len() != path_parts.len() {
            // Check for wildcard at end
            if !self.pattern.ends_with("*") {
                return None;
            }
        }

        let mut params = RouteParams::new();

        for (i, pattern_part) in pattern_parts.iter().enumerate() {
            if pattern_part.starts_with(':') {
                // Parameter capture
                let param_name = &pattern_part[1..];
                if i < path_parts.len() {
                    params.insert(param_name, path_parts[i]);
                }
            } else if *pattern_part == "*" {
                // Wildcard matches rest
                if i < path_parts.len() {
                    let rest = path_parts[i..].join("/");
                    params.insert("*", &rest);
                }
                break;
            } else {
                // Literal match
                if i >= path_parts.len() || *pattern_part != path_parts[i] {
                    return None;
                }
            }
        }

        Some(params)
    }
}

/// Route parameters extracted from URL
struct RouteParams {
    params: Vec<(String, String)>,
}

impl RouteParams {
    fn new() -> RouteParams / pure {
        RouteParams { params: Vec::new() }
    }

    fn insert(&mut self, key: &str, value: &str) / pure {
        self.params.push((key.to_string(), value.to_string()));
    }

    fn get(&self, key: &str) -> Option<&str> / pure {
        for (k, v) in &self.params {
            if k == key {
                return Some(v);
            }
        }
        None
    }
}

/// Router for dispatching requests to handlers
struct Router {
    routes: Vec<Route>,
    next_handler_id: u32,
}

impl Router {
    fn new() -> Router / pure {
        Router {
            routes: Vec::new(),
            next_handler_id: 0,
        }
    }

    /// Register a GET route
    fn get(&mut self, pattern: &str) -> u32 / pure {
        let id = self.next_handler_id;
        self.next_handler_id += 1;
        self.routes.push(Route::new(HttpMethod::Get, pattern, id));
        id
    }

    /// Register a POST route
    fn post(&mut self, pattern: &str) -> u32 / pure {
        let id = self.next_handler_id;
        self.next_handler_id += 1;
        self.routes.push(Route::new(HttpMethod::Post, pattern, id));
        id
    }

    /// Register a PUT route
    fn put(&mut self, pattern: &str) -> u32 / pure {
        let id = self.next_handler_id;
        self.next_handler_id += 1;
        self.routes.push(Route::new(HttpMethod::Put, pattern, id));
        id
    }

    /// Register a DELETE route
    fn delete(&mut self, pattern: &str) -> u32 / pure {
        let id = self.next_handler_id;
        self.next_handler_id += 1;
        self.routes.push(Route::new(HttpMethod::Delete, pattern, id));
        id
    }

    /// Find matching route for request
    fn find_route(&self, req: &Request) -> Option<(u32, RouteParams)> / pure {
        for route in &self.routes {
            if let Some(params) = route.matches(req) {
                return Some((route.handler_id, params));
            }
        }
        None
    }
}

// ===========================================================================
// 3. Request Handling Effect
// ===========================================================================

/// Effect for handling HTTP requests
effect HandleRequest {
    /// Called when a request matches a route
    op handle(handler_id: u32, req: Request, params: RouteParams) -> Response;
}

/// Effect for server lifecycle
effect ServerControl {
    /// Log a message
    op log(level: LogLevel, message: &str) -> ();

    /// Called when server starts
    op on_start(addr: SocketAddr) -> ();

    /// Called when a request is received (before routing)
    op on_request(req: &Request) -> ();

    /// Called when a response is sent
    op on_response(req: &Request, res: &Response, duration_ms: u64) -> ();

    /// Called on error
    op on_error(err: &ServerError) -> ();
}

enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

impl LogLevel {
    fn as_str(&self) -> &str / pure {
        match self {
            LogLevel::Debug => "DEBUG",
            LogLevel::Info => "INFO",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
        }
    }
}

// ===========================================================================
// 4. HTTP Server
// ===========================================================================

/// HTTP server configuration
struct ServerConfig {
    host: String,
    port: u16,
    max_connections: u32,
    read_timeout_ms: u32,
    write_timeout_ms: u32,
}

impl ServerConfig {
    fn default() -> ServerConfig / pure {
        ServerConfig {
            host: "127.0.0.1".to_string(),
            port: 8080,
            max_connections: 1024,
            read_timeout_ms: 30000,
            write_timeout_ms: 30000,
        }
    }

    fn with_port(mut self, port: u16) -> ServerConfig / pure {
        self.port = port;
        self
    }

    fn with_host(mut self, host: &str) -> ServerConfig / pure {
        self.host = host.to_string();
        self
    }
}

/// HTTP server
struct HttpServer {
    config: ServerConfig,
    router: Router,
}

impl HttpServer {
    /// Create a new HTTP server
    fn new(config: ServerConfig) -> HttpServer / pure {
        HttpServer {
            config,
            router: Router::new(),
        }
    }

    /// Get mutable reference to router for configuration
    fn router(&mut self) -> &mut Router / pure {
        &mut self.router
    }

    /// Start the server (blocking)
    fn run(&self) -> Result<(), ServerError> / {Net, HandleRequest, ServerControl} {
        let addr = SocketAddr::new(
            self.config.host.parse().map_err(|_| ServerError::BindFailed("invalid host"))?,
            self.config.port
        );

        // Bind to address
        let listener = TcpListener::bind(&addr)
            .map_err(|e| ServerError::BindFailed(format!("{:?}", e)))?;

        perform ServerControl.on_start(addr);
        perform ServerControl.log(LogLevel::Info, &format!("Server listening on {}", addr));

        // Accept connections in a loop
        loop {
            match listener.accept() {
                Ok((stream, remote_addr)) => {
                    // Handle connection in a new fiber for concurrency
                    spawn {
                        self.handle_connection(stream, remote_addr);
                    };
                }
                Err(e) => {
                    perform ServerControl.log(LogLevel::Error, &format!("Accept error: {:?}", e));
                }
            }
        }
    }

    /// Handle a single connection
    fn handle_connection(&self, mut stream: TcpStream, remote_addr: SocketAddr) / {Net, HandleRequest, ServerControl} {
        // Set timeouts
        let _ = stream.set_read_timeout(Some(Duration::from_millis(self.config.read_timeout_ms as u64)));
        let _ = stream.set_write_timeout(Some(Duration::from_millis(self.config.write_timeout_ms as u64)));

        // Read request
        match self.read_request(&mut stream, remote_addr) {
            Ok(req) => {
                let start_time = Instant::now();
                perform ServerControl.on_request(&req);

                // Route request
                let response = match self.router.find_route(&req) {
                    Some((handler_id, params)) => {
                        perform HandleRequest.handle(handler_id, req.clone(), params)
                    }
                    None => {
                        Response::not_found().text("404 Not Found")
                    }
                };

                // Send response
                let response_bytes = response.to_bytes();
                if let Err(e) = stream.write_all(&response_bytes) {
                    perform ServerControl.on_error(&ServerError::IoError(e));
                } else {
                    let duration = start_time.elapsed().as_millis() as u64;
                    perform ServerControl.on_response(&req, &response, duration);
                }
            }
            Err(e) => {
                perform ServerControl.on_error(&e);
                // Send error response
                let response = Response::bad_request().text(&e.to_string());
                let _ = stream.write_all(&response.to_bytes());
            }
        }
    }

    /// Read and parse HTTP request from stream
    fn read_request(&self, stream: &mut TcpStream, remote_addr: SocketAddr) -> Result<Request, ServerError> / {Net} {
        let mut buf = Vec::new();
        let mut temp = [0u8; 4096];

        // Read until we have complete headers
        loop {
            match stream.read(&mut temp) {
                Ok(0) => return Err(ServerError::InvalidRequest("connection closed")),
                Ok(n) => {
                    buf.extend_from_slice(&temp[..n]);

                    // Check for header terminator
                    if buf.windows(4).any(|w| w == b"\r\n\r\n") {
                        break;
                    }

                    // Prevent unlimited reads
                    if buf.len() > 65536 {
                        return Err(ServerError::InvalidRequest("headers too large"));
                    }
                }
                Err(e) => return Err(ServerError::IoError(e)),
            }
        }

        // Parse request
        self.parse_request(&buf, remote_addr)
    }

    /// Parse HTTP request bytes
    fn parse_request(&self, data: &[u8], remote_addr: SocketAddr) -> Result<Request, ServerError> / pure {
        let request_str = String::from_utf8_lossy(data);

        // Find header/body separator
        let header_end = request_str.find("\r\n\r\n")
            .ok_or(ServerError::InvalidRequest("missing header terminator"))?;

        let header_section = &request_str[..header_end];
        let body_start = header_end + 4;

        // Parse request line
        let first_line_end = header_section.find("\r\n")
            .ok_or(ServerError::InvalidRequest("missing request line"))?;
        let request_line = &header_section[..first_line_end];

        // Parse "GET /path HTTP/1.1"
        let parts: Vec<&str> = request_line.split(' ').collect();
        if parts.len() < 2 {
            return Err(ServerError::InvalidRequest("invalid request line"));
        }

        let method = HttpMethod::from_str(parts[0])
            .ok_or(ServerError::InvalidRequest("unknown HTTP method"))?;

        let path_query = parts[1];
        let (path, query) = match path_query.find('?') {
            Some(idx) => (
                path_query[..idx].to_string(),
                Some(path_query[idx + 1..].to_string())
            ),
            None => (path_query.to_string(), None),
        };

        // Parse headers
        let headers_section = &header_section[first_line_end + 2..];
        let mut headers = Vec::new();

        for line in headers_section.split("\r\n") {
            if line.is_empty() {
                continue;
            }

            if let Some(colon_idx) = line.find(':') {
                let name = line[..colon_idx].trim();
                let value = line[colon_idx + 1..].trim();
                headers.push(Header::new(name, value));
            }
        }

        // Extract body
        let body = data[body_start..].to_vec();

        Ok(Request {
            method,
            path,
            query,
            headers,
            body,
            remote_addr,
        })
    }
}

// ===========================================================================
// 5. Middleware Handlers
// ===========================================================================

/// Simple logging handler for ServerControl
deep handler LoggingHandler for ServerControl {
    return(x) { x }

    op log(level, message) {
        println!("[{}] {}", level.as_str(), message);
        resume(())
    }

    op on_start(addr) {
        println!("=== Server Started ===");
        println!("Listening on: {}", addr);
        println!("Press Ctrl+C to stop");
        println!("");
        resume(())
    }

    op on_request(req) {
        println!("--> {} {}", req.method.as_str(), req.path);
        resume(())
    }

    op on_response(req, res, duration_ms) {
        println!("<-- {} {} {} ({}ms)",
            req.method.as_str(),
            req.path,
            res.status_code,
            duration_ms
        );
        resume(())
    }

    op on_error(err) {
        println!("[ERROR] {}", err.to_string());
        resume(())
    }
}

/// Quiet handler that suppresses all logging
deep handler QuietHandler for ServerControl {
    return(x) { x }
    op log(_, _) { resume(()) }
    op on_start(_) { resume(()) }
    op on_request(_) { resume(()) }
    op on_response(_, _, _) { resume(()) }
    op on_error(_) { resume(()) }
}

// ===========================================================================
// 6. Utility Functions
// ===========================================================================

/// URL-decode a string
fn url_decode(s: &str) -> String / pure {
    let mut result = String::new();
    let mut chars = s.chars().peekable();

    while let Some(c) = chars.next() {
        match c {
            '%' => {
                let mut hex = String::new();
                if let Some(h1) = chars.next() {
                    hex.push(h1);
                }
                if let Some(h2) = chars.next() {
                    hex.push(h2);
                }
                if let Ok(byte) = u8::from_str_radix(&hex, 16) {
                    result.push(byte as char);
                }
            }
            '+' => {
                result.push(' ');
            }
            _ => {
                result.push(c);
            }
        }
    }
    result
}

// ===========================================================================
// 7. Example Application
// ===========================================================================

/// In-memory "database" for demo
struct UserStore {
    users: Vec<User>,
    next_id: u64,
}

struct User {
    id: u64,
    name: String,
    email: String,
}

impl UserStore {
    fn new() -> UserStore / pure {
        UserStore {
            users: Vec::new(),
            next_id: 1,
        }
    }

    fn add(&mut self, name: &str, email: &str) -> User / pure {
        let user = User {
            id: self.next_id,
            name: name.to_string(),
            email: email.to_string(),
        };
        self.next_id += 1;
        self.users.push(user.clone());
        user
    }

    fn get(&self, id: u64) -> Option<&User> / pure {
        self.users.iter().find(|u| u.id == id)
    }

    fn list(&self) -> &[User] / pure {
        &self.users
    }

    fn delete(&mut self, id: u64) -> bool / pure {
        if let Some(idx) = self.users.iter().position(|u| u.id == id) {
            self.users.remove(idx);
            true
        } else {
            false
        }
    }
}

impl User {
    fn to_json(&self) -> String / pure {
        format!(r#"{{"id": {}, "name": "{}", "email": "{}"}}"#,
            self.id, self.name, self.email)
    }
}

/// Route IDs for our application
const ROUTE_INDEX: u32 = 0;
const ROUTE_HEALTH: u32 = 1;
const ROUTE_LIST_USERS: u32 = 2;
const ROUTE_GET_USER: u32 = 3;
const ROUTE_CREATE_USER: u32 = 4;
const ROUTE_DELETE_USER: u32 = 5;
const ROUTE_STATIC: u32 = 6;

/// Main function demonstrating HTTP server usage
fn main() -> i32 / {Net, IO} {
    println!("Blood HTTP Server Example");
    println!("=========================\n");

    // Create server with configuration
    let config = ServerConfig::default().with_port(8080);
    let mut server = HttpServer::new(config);

    // Configure routes
    {
        let router = server.router();

        // Basic routes
        let _ = router.get("/");                    // ROUTE_INDEX
        let _ = router.get("/health");              // ROUTE_HEALTH

        // User API routes
        let _ = router.get("/api/users");           // ROUTE_LIST_USERS
        let _ = router.get("/api/users/:id");       // ROUTE_GET_USER
        let _ = router.post("/api/users");          // ROUTE_CREATE_USER
        let _ = router.delete("/api/users/:id");    // ROUTE_DELETE_USER

        // Static files (wildcard)
        let _ = router.get("/static/*");            // ROUTE_STATIC
    }

    // Initialize user store
    let mut store = UserStore::new();
    store.add("Alice", "alice@example.com");
    store.add("Bob", "bob@example.com");

    // Run server with handlers
    with LoggingHandler handle {
        with AppHandler { store: &mut store } handle {
            match server.run() {
                Ok(()) => 0,
                Err(e) => {
                    println!("Server error: {}", e.to_string());
                    1
                }
            }
        }
    }
}

/// Application request handler
deep handler AppHandler for HandleRequest {
    let store: &mut UserStore

    return(x) { x }

    op handle(handler_id, req, params) {
        let response = match handler_id {
            ROUTE_INDEX => {
                Response::ok().html(r#"
                    <!DOCTYPE html>
                    <html>
                    <head><title>Blood HTTP Server</title></head>
                    <body>
                        <h1>Welcome to Blood HTTP Server</h1>
                        <ul>
                            <li><a href="/health">Health Check</a></li>
                            <li><a href="/api/users">User API</a></li>
                        </ul>
                    </body>
                    </html>
                "#)
            }

            ROUTE_HEALTH => {
                Response::ok().json(r#"{"status": "healthy", "version": "0.5.2"}"#)
            }

            ROUTE_LIST_USERS => {
                let users = store.list();
                let mut json = String::from("[");
                for (i, user) in users.iter().enumerate() {
                    if i > 0 {
                        json.push_str(", ");
                    }
                    json.push_str(&user.to_json());
                }
                json.push(']');
                Response::ok().json(&json)
            }

            ROUTE_GET_USER => {
                if let Some(id_str) = params.get("id") {
                    if let Ok(id) = id_str.parse::<u64>() {
                        if let Some(user) = store.get(id) {
                            Response::ok().json(&user.to_json())
                        } else {
                            Response::not_found().json(r#"{"error": "user not found"}"#)
                        }
                    } else {
                        Response::bad_request().json(r#"{"error": "invalid user id"}"#)
                    }
                } else {
                    Response::bad_request().json(r#"{"error": "missing user id"}"#)
                }
            }

            ROUTE_CREATE_USER => {
                // Parse JSON body (simplified)
                if let Ok(body) = req.body_text() {
                    // Very simple JSON parsing for demo
                    let name = extract_json_field(&body, "name").unwrap_or("Unknown");
                    let email = extract_json_field(&body, "email").unwrap_or("unknown@example.com");
                    let user = store.add(name, email);
                    Response::created().json(&user.to_json())
                } else {
                    Response::bad_request().json(r#"{"error": "invalid request body"}"#)
                }
            }

            ROUTE_DELETE_USER => {
                if let Some(id_str) = params.get("id") {
                    if let Ok(id) = id_str.parse::<u64>() {
                        if store.delete(id) {
                            Response::no_content()
                        } else {
                            Response::not_found().json(r#"{"error": "user not found"}"#)
                        }
                    } else {
                        Response::bad_request().json(r#"{"error": "invalid user id"}"#)
                    }
                } else {
                    Response::bad_request().json(r#"{"error": "missing user id"}"#)
                }
            }

            ROUTE_STATIC => {
                // Serve static file (simplified - just echo path)
                let file_path = params.get("*").unwrap_or("index.html");
                Response::ok().text(&format!("Would serve static file: {}", file_path))
            }

            _ => {
                Response::not_found().text("404 Not Found")
            }
        };

        resume(response)
    }
}

/// Helper to extract JSON field (very simplified)
fn extract_json_field<'a>(json: &'a str, field: &str) -> Option<&'a str> / pure {
    let pattern = format!("\"{}\":", field);
    let start = json.find(&pattern)?;
    let rest = &json[start + pattern.len()..];

    // Skip whitespace
    let rest = rest.trim_start();

    if rest.starts_with('"') {
        // String value
        let value_start = 1;
        let value_end = rest[1..].find('"')? + 1;
        Some(&rest[value_start..value_end])
    } else {
        // Number or other value
        let end = rest.find(|c| c == ',' || c == '}' || c == ' ')?;
        Some(&rest[..end])
    }
}

// ===========================================================================
// 8. Tests
// ===========================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_route_matching_simple() {
        let route = Route::new(HttpMethod::Get, "/users", 0);
        let req = Request {
            method: HttpMethod::Get,
            path: "/users".to_string(),
            query: None,
            headers: Vec::new(),
            body: Vec::new(),
            remote_addr: SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0),
        };
        assert!(route.matches(&req).is_some());
    }

    #[test]
    fn test_route_matching_with_param() {
        let route = Route::new(HttpMethod::Get, "/users/:id", 0);
        let req = Request {
            method: HttpMethod::Get,
            path: "/users/123".to_string(),
            query: None,
            headers: Vec::new(),
            body: Vec::new(),
            remote_addr: SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0),
        };
        let params = route.matches(&req).unwrap();
        assert_eq!(params.get("id"), Some("123"));
    }

    #[test]
    fn test_route_method_mismatch() {
        let route = Route::new(HttpMethod::Get, "/users", 0);
        let req = Request {
            method: HttpMethod::Post,
            path: "/users".to_string(),
            query: None,
            headers: Vec::new(),
            body: Vec::new(),
            remote_addr: SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 0),
        };
        assert!(route.matches(&req).is_none());
    }

    #[test]
    fn test_response_builder() {
        let response = Response::ok()
            .header("X-Custom", "test")
            .json(r#"{"key": "value"}"#);

        assert_eq!(response.status_code, 200);
        assert!(!response.body.is_empty());
    }

    #[test]
    fn test_url_decode() {
        assert_eq!(url_decode("hello%20world"), "hello world");
        assert_eq!(url_decode("a+b"), "a b");
        assert_eq!(url_decode("test%2Fpath"), "test/path");
    }

    #[test]
    fn test_user_store() {
        let mut store = UserStore::new();
        let user = store.add("Test", "test@example.com");
        assert_eq!(user.id, 1);
        assert!(store.get(1).is_some());
        assert!(store.delete(1));
        assert!(store.get(1).is_none());
    }

    #[test]
    fn test_extract_json_field() {
        let json = r#"{"name": "Alice", "age": 30}"#;
        assert_eq!(extract_json_field(json, "name"), Some("Alice"));
    }
}
