// Multiple Dispatch in Blood
//
// This example demonstrates Blood's multiple dispatch system:
//
// - Open methods: New implementations can be added without modifying originals
// - Type-stable dispatch: Return type determined by input types at compile time
// - Ambiguity detection: Conflicting methods caught at compile time
// - SAME FUNCTION NAME: Functions can have the same name but dispatch on types
//
// Blood supports Julia-style multiple dispatch where the same function name
// can be defined multiple times with different parameter types. The compiler
// selects the most specific implementation at compile time.
//
// See DISPATCH.md for the full specification.

// ===========================================================================
// Part 1: Struct Types for Dispatch Demonstration
// ===========================================================================

// Different struct types that would participate in multiple dispatch.
// In full dispatch, a single `area` method would dispatch to different
// implementations based on the shape type.

struct Rectangle {
    width: i32,
    height: i32,
}

struct Circle {
    radius: i32,
}

struct Triangle {
    base: i32,
    height: i32,
}

// 2D and 3D points for dimensionality-based dispatch
struct Point2D {
    x: i32,
    y: i32,
}

struct Point3D {
    x: i32,
    y: i32,
    z: i32,
}

// ===========================================================================
// Part 2: Multiple Dispatch with Same Function Name
// ===========================================================================

// Blood supports ACTUAL multiple dispatch - the same function name
// can be defined multiple times with different parameter types.
// The compiler dispatches to the correct implementation based on
// the argument types at compile time.

// Area for Rectangle: width * height
fn area(r: Rectangle) -> i32 {
    r.width * r.height
}

// Area for Circle: pi * r^2 (approximated as 3 * r^2 for integers)
fn area(c: Circle) -> i32 {
    3 * c.radius * c.radius
}

// Area for Triangle: (base * height) / 2
fn area(t: Triangle) -> i32 {
    (t.base * t.height) / 2
}

// ===========================================================================
// Part 3: Multi-Argument Dispatch
// ===========================================================================

// Blood's multiple dispatch considers ALL argument types, not just the first.
// Same function name dispatches based on dimensionality of points.

// Manhattan distance for 2D points
fn manhattan(p: Point2D) -> i32 {
    let mut dx: i32 = p.x;
    let mut dy: i32 = p.y;
    if dx < 0 { dx = 0 - dx; }
    if dy < 0 { dy = 0 - dy; }
    dx + dy
}

// Manhattan distance for 3D points - same function name, different type
fn manhattan(p: Point3D) -> i32 {
    let mut dx: i32 = p.x;
    let mut dy: i32 = p.y;
    let mut dz: i32 = p.z;
    if dx < 0 { dx = 0 - dx; }
    if dy < 0 { dy = 0 - dy; }
    if dz < 0 { dz = 0 - dz; }
    dx + dy + dz
}

// Distance between two 2D points
fn distance(p1: Point2D, p2: Point2D) -> i32 {
    let mut dx: i32 = p2.x - p1.x;
    let mut dy: i32 = p2.y - p1.y;
    if dx < 0 { dx = 0 - dx; }
    if dy < 0 { dy = 0 - dy; }
    dx + dy
}

// Distance between two 3D points - same function name, different types
fn distance(p1: Point3D, p2: Point3D) -> i32 {
    let mut dx: i32 = p2.x - p1.x;
    let mut dy: i32 = p2.y - p1.y;
    let mut dz: i32 = p2.z - p1.z;
    if dx < 0 { dx = 0 - dx; }
    if dy < 0 { dy = 0 - dy; }
    if dz < 0 { dz = 0 - dz; }
    dx + dy + dz
}

// ===========================================================================
// Part 4: Specificity Ordering
// ===========================================================================

// In multiple dispatch, when multiple methods could apply, the MOST SPECIFIC
// wins. Specificity is determined by the type hierarchy.

// Base animal operations
struct Animal {
    legs: i32,
}

struct Dog {
    legs: i32,
    breed_code: i32,
}

struct Cat {
    legs: i32,
    lives: i32,
}

// Multiple dispatch automatically selects the correct implementation
// based on the actual type of the argument.

fn legs(a: Animal) -> i32 {
    a.legs
}

fn legs(d: Dog) -> i32 {
    // Dogs: return legs plus breed code marker
    d.legs + d.breed_code
}

fn legs(c: Cat) -> i32 {
    // Cats: return legs times lives
    c.legs * c.lives
}

// ===========================================================================
// Part 5: Numeric Type Operations
// ===========================================================================

// Dispatch based on numeric types

fn double_i32(x: i32) -> i32 {
    x * 2
}

fn clamp_i32(value: i32, min: i32, max: i32) -> i32 {
    if value < min {
        min
    } else if value > max {
        max
    } else {
        value
    }
}

// ===========================================================================
// Part 6: Type Stability Demonstration
// ===========================================================================

// Blood requires TYPE STABILITY: the return type must be determinable from
// the input types at compile time. This enables zero-cost dispatch.

// Type-stable: return type is always i32 regardless of input VALUE
fn abs_value(x: i32) -> i32 {
    if x < 0 { 0 - x } else { x }
}

// Type-stable: return type determined by parameter type
// Same function name, different types - dispatch selects the right one
fn identity(x: i32) -> i32 {
    x
}

fn identity(x: bool) -> bool {
    x
}

// ===========================================================================
// Part 7: Binary Dispatch Patterns
// ===========================================================================

// Operations that dispatch on TWO or more argument types.
// Blood dispatches based on ALL argument types, not just the first.

// Add two i32 values
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// Boolean combination (count of true values) - same name as int add, different types
fn combine(a: bool, b: bool) -> i32 {
    let mut count: i32 = 0;
    if a { count = count + 1; }
    if b { count = count + 1; }
    count
}

// Mixed types: int + bool (treat bool as 0/1)
// Dispatch selects based on both argument types
fn add(a: i32, b: bool) -> i32 {
    if b { a + 1 } else { a }
}

fn add(a: bool, b: i32) -> i32 {
    if a { b + 1 } else { b }
}

// ===========================================================================
// Test Functions
// ===========================================================================

fn test_area_dispatch() {
    println_str("=== Area Dispatch Tests ===");
    println_str("(Same function name 'area' dispatches by shape type)");

    let rect: Rectangle = Rectangle { width: 4, height: 5 };
    let circ: Circle = Circle { radius: 3 };
    let tri: Triangle = Triangle { base: 6, height: 4 };

    print_str("area(Rectangle{4,5}) = ");
    println_int(area(rect));  // 20

    print_str("area(Circle{r=3}) ~ ");
    println_int(area(circ));  // 27

    print_str("area(Triangle{6,4}) = ");
    println_int(area(tri));  // 12

    println_str("");
}

fn test_point_dispatch() {
    println_str("=== Point Dimension Dispatch Tests ===");
    println_str("(Same 'manhattan' and 'distance' names dispatch by point type)");

    let p2: Point2D = Point2D { x: 3, y: 4 };
    let p3: Point3D = Point3D { x: 1, y: 2, z: 3 };

    print_str("manhattan(Point2D{3,4}) = ");
    println_int(manhattan(p2));  // 7

    print_str("manhattan(Point3D{1,2,3}) = ");
    println_int(manhattan(p3));  // 6

    let a2: Point2D = Point2D { x: 0, y: 0 };
    let b2: Point2D = Point2D { x: 3, y: 4 };
    let a3: Point3D = Point3D { x: 0, y: 0, z: 0 };
    let b3: Point3D = Point3D { x: 1, y: 2, z: 3 };

    print_str("distance(2D: origin to (3,4)) = ");
    println_int(distance(a2, b2));  // 7

    print_str("distance(3D: origin to (1,2,3)) = ");
    println_int(distance(a3, b3));  // 6

    println_str("");
}

fn test_specificity() {
    println_str("=== Specificity Ordering Tests ===");
    println_str("(Same 'legs' function dispatches by animal type)");

    let animal: Animal = Animal { legs: 4 };
    let dog: Dog = Dog { legs: 4, breed_code: 100 };
    let cat: Cat = Cat { legs: 4, lives: 9 };

    print_str("legs(Animal{4}) = ");
    println_int(legs(animal));  // 4

    print_str("legs(Dog{4, breed=100}) = ");
    println_int(legs(dog));  // 104

    print_str("legs(Cat{4, lives=9}) = ");
    println_int(legs(cat));  // 36

    println_str("");
}

fn test_numeric_dispatch() {
    println_str("=== Numeric Type Dispatch Tests ===");

    print_str("double(21: i32) = ");
    println_int(double_i32(21));  // 42  (kept as single impl)

    print_str("clamp(150, 0, 100) = ");
    println_int(clamp_i32(150, 0, 100));  // 100

    print_str("clamp(-50, 0, 100) = ");
    println_int(clamp_i32(-50, 0, 100));  // 0

    print_str("clamp(50, 0, 100) = ");
    println_int(clamp_i32(50, 0, 100));  // 50

    println_str("");
}

fn test_binary_dispatch() {
    println_str("=== Binary (Two-Argument) Dispatch Tests ===");
    println_str("(Same 'add' function dispatches based on BOTH argument types)");

    print_str("add(10, 20) = ");
    println_int(add(10, 20));  // 30

    print_str("combine(true, true) = ");
    println_int(combine(true, true));  // 2

    print_str("combine(true, false) = ");
    println_int(combine(true, false));  // 1

    print_str("add(5, true) = ");
    println_int(add(5, true));  // 6

    print_str("add(false, 7) = ");
    println_int(add(false, 7));  // 7

    println_str("");
}

fn test_type_stability() {
    println_str("=== Type Stability Tests ===");
    println_str("(Same 'identity' name, return type matches argument type)");

    print_str("abs_value(5) = ");
    println_int(abs_value(5));  // 5

    print_str("abs_value(-5) = ");
    println_int(abs_value(-5));  // 5 (same return TYPE)

    print_str("identity(42: i32) = ");
    println_int(identity(42));  // 42 - dispatches to i32 version

    print_str("identity(true: bool) = ");
    if identity(true) { println_str("true"); } else { println_str("false"); }

    println_str("");
}

// ===========================================================================
// Main Entry Point
// ===========================================================================

fn main() {
    println_str("======================================================");
    println_str("  Blood Multiple Dispatch (ACTUAL, Not Simulated!)");
    println_str("======================================================");
    println_str("");
    println_str("This example demonstrates REAL multiple dispatch:");
    println_str("- SAME function name dispatches to type-specific code");
    println_str("- Dispatch based on ALL argument types");
    println_str("- Specificity ordering (most specific type wins)");
    println_str("- Type stability (return type from input types)");
    println_str("");
    println_str("See DISPATCH.md for the full specification.");
    println_str("");

    test_area_dispatch();
    test_point_dispatch();
    test_specificity();
    test_numeric_dispatch();
    test_binary_dispatch();
    test_type_stability();

    println_str("======================================================");
    println_str("  All dispatch concept tests completed!");
    println_str("======================================================");
}
