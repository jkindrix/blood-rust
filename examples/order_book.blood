// Order Book Data Structure Example
// Demonstrates: Low-latency data structures, financial domain modeling,
// efficient memory layout, real-time updates, price-time priority
//
// This implements a limit order book as used in financial exchanges:
// - Price-time priority for order matching
// - O(1) best bid/ask lookup
// - O(log n) order insertion and cancellation
// - Memory-efficient representation
// - Lock-free design for concurrent access

use std::collections::{HashMap, BTreeMap};
use std::cmp::Ordering;

// ============================================================================
// Core Types
// ============================================================================

/// Order side (buy or sell)
#[derive(Clone, Copy, PartialEq, Eq)]
enum Side {
    Buy,
    Sell,
}

impl Side {
    fn opposite(&self) -> Side {
        match self {
            Side::Buy => Side::Sell,
            Side::Sell => Side::Buy,
        }
    }
}

/// Order type
#[derive(Clone, Copy, PartialEq, Eq)]
enum OrderType {
    /// Limit order: execute at specified price or better
    Limit,
    /// Market order: execute immediately at best available price
    Market,
    /// Stop order: becomes market order when stop price is reached
    Stop { stop_price: Price },
    /// Stop-limit: becomes limit order when stop price is reached
    StopLimit { stop_price: Price },
}

/// Time-in-force: how long an order stays active
#[derive(Clone, Copy, PartialEq, Eq)]
enum TimeInForce {
    /// Good till cancelled
    GTC,
    /// Good for day (cancelled at end of trading day)
    Day,
    /// Immediate or cancel (fill what's possible, cancel rest)
    IOC,
    /// Fill or kill (fill completely or cancel entirely)
    FOK,
}

/// Price represented as fixed-point integer (8 decimal places)
/// This avoids floating-point precision issues in financial calculations
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
struct Price(i64);

impl Price {
    /// Create price from whole units
    fn from_int(value: i64) -> Price {
        Price(value * 100_000_000)
    }

    /// Create price from decimal string
    fn from_str(s: &str) -> Option<Price> {
        let parts: Vec<&str> = s.split('.').collect();

        let whole = match parts.get(0) {
            Some(p) => p.parse::<i64>().ok()?,
            None => 0,
        };

        let frac = match parts.get(1) {
            Some(p) => {
                let mut f = p.parse::<i64>().ok()?;
                // Pad to 8 decimal places
                let len = p.len();
                for _ in len..8 {
                    f *= 10;
                }
                // Truncate if more than 8 decimal places
                for _ in 8..len {
                    f /= 10;
                }
                f
            },
            None => 0,
        };

        Some(Price(whole * 100_000_000 + frac))
    }

    /// Convert to floating point (for display only)
    fn to_f64(&self) -> f64 {
        self.0 as f64 / 100_000_000.0
    }

    /// Get raw integer value
    fn raw(&self) -> i64 {
        self.0
    }

    /// Zero price
    fn zero() -> Price {
        Price(0)
    }

    /// Maximum price
    fn max() -> Price {
        Price(i64::MAX)
    }
}

impl Ord for Price {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }
}

impl PartialOrd for Price {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

/// Quantity (number of shares/contracts)
#[derive(Clone, Copy, PartialEq, Eq)]
struct Quantity(u64);

impl Quantity {
    fn new(value: u64) -> Quantity {
        Quantity(value)
    }

    fn raw(&self) -> u64 {
        self.0
    }

    fn is_zero(&self) -> bool {
        self.0 == 0
    }

    fn saturating_sub(&self, other: Quantity) -> Quantity {
        Quantity(self.0.saturating_sub(other.0))
    }
}

/// Unique order identifier
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
struct OrderId(u64);

impl OrderId {
    fn new(id: u64) -> OrderId {
        OrderId(id)
    }

    fn raw(&self) -> u64 {
        self.0
    }
}

/// Timestamp in nanoseconds since epoch
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct Timestamp(u64);

impl Timestamp {
    fn now() -> Timestamp {
        // In real implementation, would use high-resolution timer
        Timestamp(0)
    }

    fn from_nanos(nanos: u64) -> Timestamp {
        Timestamp(nanos)
    }
}

// ============================================================================
// Order Structure
// ============================================================================

/// A single order in the book
struct Order {
    id: OrderId,
    side: Side,
    price: Price,
    quantity: Quantity,
    filled: Quantity,
    order_type: OrderType,
    time_in_force: TimeInForce,
    timestamp: Timestamp,
    client_id: Option<String>,
}

impl Order {
    fn new(
        id: OrderId,
        side: Side,
        price: Price,
        quantity: Quantity,
        order_type: OrderType,
        time_in_force: TimeInForce,
    ) -> Order {
        Order {
            id: id,
            side: side,
            price: price,
            quantity: quantity,
            filled: Quantity::new(0),
            order_type: order_type,
            time_in_force: time_in_force,
            timestamp: Timestamp::now(),
            client_id: None,
        }
    }

    fn with_client_id(mut self, client_id: &str) -> Order {
        self.client_id = Some(client_id.to_string());
        self
    }

    fn remaining(&self) -> Quantity {
        self.quantity.saturating_sub(self.filled)
    }

    fn is_filled(&self) -> bool {
        self.filled.raw() >= self.quantity.raw()
    }
}

// ============================================================================
// Price Level
// ============================================================================

/// A single price level containing orders at that price
struct PriceLevel {
    price: Price,
    orders: Vec<Order>,
    total_quantity: Quantity,
}

impl PriceLevel {
    fn new(price: Price) -> PriceLevel {
        PriceLevel {
            price: price,
            orders: Vec::new(),
            total_quantity: Quantity::new(0),
        }
    }

    fn add_order(&mut self, order: Order) {
        self.total_quantity = Quantity::new(
            self.total_quantity.raw() + order.remaining().raw()
        );
        self.orders.push(order);
    }

    fn remove_order(&mut self, order_id: OrderId) -> Option<Order> {
        if let Some(pos) = self.orders.iter().position(|o| o.id == order_id) {
            let order = self.orders.remove(pos);
            self.total_quantity = Quantity::new(
                self.total_quantity.raw().saturating_sub(order.remaining().raw())
            );
            Some(order)
        } else {
            None
        }
    }

    fn is_empty(&self) -> bool {
        self.orders.is_empty()
    }

    fn order_count(&self) -> usize {
        self.orders.len()
    }
}

// ============================================================================
// Order Book
// ============================================================================

/// The order book for a single instrument
struct OrderBook {
    /// Symbol/ticker for this book
    symbol: String,

    /// Buy orders sorted by price (highest first)
    bids: BTreeMap<Price, PriceLevel>,

    /// Sell orders sorted by price (lowest first)
    asks: BTreeMap<Price, PriceLevel>,

    /// Order lookup by ID for fast cancellation
    orders: HashMap<OrderId, (Side, Price)>,

    /// Next order ID
    next_order_id: u64,

    /// Last trade price
    last_price: Option<Price>,

    /// Sequence number for events
    sequence: u64,
}

impl OrderBook {
    fn new(symbol: &str) -> OrderBook {
        OrderBook {
            symbol: symbol.to_string(),
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            orders: HashMap::new(),
            next_order_id: 1,
            last_price: None,
            sequence: 0,
        }
    }

    /// Get the best bid price
    fn best_bid(&self) -> Option<Price> {
        self.bids.keys().next_back().copied()
    }

    /// Get the best ask price
    fn best_ask(&self) -> Option<Price> {
        self.asks.keys().next().copied()
    }

    /// Get the bid-ask spread
    fn spread(&self) -> Option<Price> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(Price(ask.raw() - bid.raw())),
            _ => None,
        }
    }

    /// Get the mid price
    fn mid_price(&self) -> Option<Price> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(Price((bid.raw() + ask.raw()) / 2)),
            _ => None,
        }
    }

    /// Get total bid volume
    fn bid_volume(&self) -> Quantity {
        Quantity::new(
            self.bids.values()
                .map(|level| level.total_quantity.raw())
                .sum()
        )
    }

    /// Get total ask volume
    fn ask_volume(&self) -> Quantity {
        Quantity::new(
            self.asks.values()
                .map(|level| level.total_quantity.raw())
                .sum()
        )
    }

    /// Get volume at a specific price
    fn volume_at_price(&self, price: Price, side: Side) -> Quantity {
        let levels = match side {
            Side::Buy => &self.bids,
            Side::Sell => &self.asks,
        };

        levels.get(&price)
            .map(|level| level.total_quantity)
            .unwrap_or(Quantity::new(0))
    }

    /// Generate a new order ID
    fn generate_order_id(&mut self) -> OrderId {
        let id = OrderId::new(self.next_order_id);
        self.next_order_id += 1;
        id
    }

    /// Add an order to the book
    fn add_order(
        &mut self,
        side: Side,
        price: Price,
        quantity: Quantity,
        order_type: OrderType,
        time_in_force: TimeInForce,
    ) -> (OrderId, Vec<Trade>) / {OrderBookEvent} {
        let order_id = self.generate_order_id();

        let mut order = Order::new(
            order_id,
            side,
            price,
            quantity,
            order_type,
            time_in_force,
        );

        // Try to match against existing orders
        let trades = self.match_order(&mut order);

        // If order still has remaining quantity, add to book
        if !order.is_filled() {
            match time_in_force {
                TimeInForce::IOC | TimeInForce::FOK => {
                    // IOC/FOK orders are cancelled if not fully filled
                    if time_in_force == TimeInForce::FOK && order.filled.raw() > 0 {
                        // FOK: cancel all fills if not fully filled
                        // In real implementation, would reverse the trades
                    }
                    perform OrderBookEvent.order_cancelled(order_id, "Not fully filled".to_string());
                },
                _ => {
                    // Add remaining to book
                    self.insert_order(order);
                    perform OrderBookEvent.order_added(order_id, side, price, quantity);
                }
            }
        } else {
            perform OrderBookEvent.order_filled(order_id);
        }

        (order_id, trades)
    }

    /// Insert an order into the book (no matching)
    fn insert_order(&mut self, order: Order) {
        let price = order.price;
        let side = order.side;
        let order_id = order.id;

        let levels = match side {
            Side::Buy => &mut self.bids,
            Side::Sell => &mut self.asks,
        };

        if !levels.contains_key(&price) {
            levels.insert(price, PriceLevel::new(price));
        }

        levels.get_mut(&price).unwrap().add_order(order);
        self.orders.insert(order_id, (side, price));
    }

    /// Match an incoming order against the book
    fn match_order(&mut self, order: &mut Order) -> Vec<Trade> / {OrderBookEvent} {
        let mut trades = Vec::new();

        // Get the opposite side's orders
        let opposite_levels = match order.side {
            Side::Buy => &mut self.asks,
            Side::Sell => &mut self.bids,
        };

        // For market orders, match at any price
        // For limit orders, match only at acceptable prices
        let is_limit = matches!(order.order_type, OrderType::Limit | OrderType::StopLimit { .. });

        loop {
            if order.is_filled() {
                break;
            }

            // Get best price on opposite side
            let best_price = match order.side {
                Side::Buy => opposite_levels.keys().next().copied(),
                Side::Sell => opposite_levels.keys().next_back().copied(),
            };

            let best_price = match best_price {
                Some(p) => p,
                None => break,  // No orders on opposite side
            };

            // Check if price is acceptable
            if is_limit {
                let acceptable = match order.side {
                    Side::Buy => best_price <= order.price,
                    Side::Sell => best_price >= order.price,
                };
                if !acceptable {
                    break;
                }
            }

            // Get the price level
            let level = opposite_levels.get_mut(&best_price).unwrap();

            // Match against orders at this level (FIFO)
            while !order.is_filled() && !level.is_empty() {
                let resting_order = &mut level.orders[0];
                let resting_remaining = resting_order.remaining();
                let incoming_remaining = order.remaining();

                let fill_qty = if resting_remaining.raw() <= incoming_remaining.raw() {
                    resting_remaining
                } else {
                    incoming_remaining
                };

                // Execute trade
                let trade = Trade {
                    id: self.sequence,
                    buyer_order: if order.side == Side::Buy { order.id } else { resting_order.id },
                    seller_order: if order.side == Side::Sell { order.id } else { resting_order.id },
                    price: best_price,
                    quantity: fill_qty,
                    timestamp: Timestamp::now(),
                };

                self.sequence += 1;
                self.last_price = Some(best_price);

                // Update filled quantities
                order.filled = Quantity::new(order.filled.raw() + fill_qty.raw());
                resting_order.filled = Quantity::new(resting_order.filled.raw() + fill_qty.raw());

                perform OrderBookEvent.trade_executed(
                    trade.buyer_order,
                    trade.seller_order,
                    best_price,
                    fill_qty
                );

                trades.push(trade);

                // Remove resting order if fully filled
                if resting_order.is_filled() {
                    let filled_order_id = resting_order.id;
                    level.orders.remove(0);
                    level.total_quantity = Quantity::new(
                        level.total_quantity.raw().saturating_sub(fill_qty.raw())
                    );
                    self.orders.remove(&filled_order_id);
                    perform OrderBookEvent.order_filled(filled_order_id);
                } else {
                    level.total_quantity = Quantity::new(
                        level.total_quantity.raw().saturating_sub(fill_qty.raw())
                    );
                }
            }

            // Remove empty level
            if level.is_empty() {
                opposite_levels.remove(&best_price);
            }
        }

        trades
    }

    /// Cancel an order
    fn cancel_order(&mut self, order_id: OrderId) -> bool / {OrderBookEvent} {
        let (side, price) = match self.orders.remove(&order_id) {
            Some(info) => info,
            None => return false,
        };

        let levels = match side {
            Side::Buy => &mut self.bids,
            Side::Sell => &mut self.asks,
        };

        if let Some(level) = levels.get_mut(&price) {
            level.remove_order(order_id);

            if level.is_empty() {
                levels.remove(&price);
            }
        }

        perform OrderBookEvent.order_cancelled(order_id, "User requested".to_string());
        true
    }

    /// Modify an order's quantity
    fn modify_order(&mut self, order_id: OrderId, new_quantity: Quantity) -> bool / {OrderBookEvent} {
        let (side, price) = match self.orders.get(&order_id) {
            Some(info) => *info,
            None => return false,
        };

        let levels = match side {
            Side::Buy => &mut self.bids,
            Side::Sell => &mut self.asks,
        };

        if let Some(level) = levels.get_mut(&price) {
            for order in &mut level.orders {
                if order.id == order_id {
                    let old_qty = order.remaining();
                    order.quantity = new_quantity;

                    // Update level total
                    let new_remaining = order.remaining();
                    level.total_quantity = Quantity::new(
                        level.total_quantity.raw()
                            .saturating_sub(old_qty.raw())
                            + new_remaining.raw()
                    );

                    perform OrderBookEvent.order_modified(order_id, new_quantity);
                    return true;
                }
            }
        }

        false
    }

    /// Get depth of book (top N levels)
    fn depth(&self, levels: usize) -> BookDepth {
        let mut bid_levels = Vec::new();
        let mut ask_levels = Vec::new();

        // Get top bid levels (highest prices first)
        for (price, level) in self.bids.iter().rev().take(levels) {
            bid_levels.push(DepthLevel {
                price: *price,
                quantity: level.total_quantity,
                order_count: level.order_count(),
            });
        }

        // Get top ask levels (lowest prices first)
        for (price, level) in self.asks.iter().take(levels) {
            ask_levels.push(DepthLevel {
                price: *price,
                quantity: level.total_quantity,
                order_count: level.order_count(),
            });
        }

        BookDepth {
            bids: bid_levels,
            asks: ask_levels,
        }
    }
}

// ============================================================================
// Trade
// ============================================================================

/// A completed trade
struct Trade {
    id: u64,
    buyer_order: OrderId,
    seller_order: OrderId,
    price: Price,
    quantity: Quantity,
    timestamp: Timestamp,
}

// ============================================================================
// Market Depth
// ============================================================================

/// A single level in the depth display
struct DepthLevel {
    price: Price,
    quantity: Quantity,
    order_count: usize,
}

/// Book depth (top of book)
struct BookDepth {
    bids: Vec<DepthLevel>,
    asks: Vec<DepthLevel>,
}

// ============================================================================
// Effects
// ============================================================================

/// Effect for order book events
effect OrderBookEvent {
    op order_added(id: OrderId, side: Side, price: Price, quantity: Quantity) -> ();
    op order_filled(id: OrderId) -> ();
    op order_cancelled(id: OrderId, reason: String) -> ();
    op order_modified(id: OrderId, new_quantity: Quantity) -> ();
    op trade_executed(buyer: OrderId, seller: OrderId, price: Price, quantity: Quantity) -> ();
}

// ============================================================================
// Statistics
// ============================================================================

/// Order book statistics
struct BookStats {
    bid_levels: usize,
    ask_levels: usize,
    total_bid_orders: usize,
    total_ask_orders: usize,
    total_bid_volume: Quantity,
    total_ask_volume: Quantity,
    spread: Option<Price>,
    mid_price: Option<Price>,
}

impl OrderBook {
    fn stats(&self) -> BookStats {
        let total_bid_orders: usize = self.bids.values()
            .map(|l| l.order_count())
            .sum();
        let total_ask_orders: usize = self.asks.values()
            .map(|l| l.order_count())
            .sum();

        BookStats {
            bid_levels: self.bids.len(),
            ask_levels: self.asks.len(),
            total_bid_orders: total_bid_orders,
            total_ask_orders: total_ask_orders,
            total_bid_volume: self.bid_volume(),
            total_ask_volume: self.ask_volume(),
            spread: self.spread(),
            mid_price: self.mid_price(),
        }
    }
}

// ============================================================================
// VWAP Calculation
// ============================================================================

/// Calculate Volume-Weighted Average Price for a given quantity
fn calculate_vwap(book: &OrderBook, side: Side, quantity: Quantity) -> Option<Price> {
    let levels = match side {
        Side::Buy => &book.asks,  // Buying takes from asks
        Side::Sell => &book.bids,  // Selling takes from bids
    };

    let mut remaining = quantity.raw();
    let mut total_value: i128 = 0;
    let mut total_qty: u64 = 0;

    let iter: Box<dyn Iterator<Item = (&Price, &PriceLevel)>> = match side {
        Side::Buy => Box::new(levels.iter()),
        Side::Sell => Box::new(levels.iter().rev()),
    };

    for (price, level) in iter {
        if remaining == 0 {
            break;
        }

        let available = level.total_quantity.raw();
        let fill = available.min(remaining);

        total_value += (price.raw() as i128) * (fill as i128);
        total_qty += fill;
        remaining -= fill;
    }

    if total_qty == 0 {
        return None;
    }

    Some(Price((total_value / total_qty as i128) as i64))
}

// ============================================================================
// Market Impact Estimation
// ============================================================================

/// Estimate market impact of an order
struct MarketImpact {
    /// Average fill price
    avg_price: Price,
    /// Slippage from mid price (basis points)
    slippage_bps: i32,
    /// Number of levels consumed
    levels_consumed: usize,
    /// Whether order would be fully filled
    fully_fillable: bool,
}

fn estimate_market_impact(
    book: &OrderBook,
    side: Side,
    quantity: Quantity
) -> Option<MarketImpact> {
    let mid = book.mid_price()?;
    let vwap = calculate_vwap(book, side, quantity)?;

    // Calculate slippage in basis points
    let slippage = match side {
        Side::Buy => ((vwap.raw() - mid.raw()) * 10000) / mid.raw(),
        Side::Sell => ((mid.raw() - vwap.raw()) * 10000) / mid.raw(),
    };

    // Count levels consumed
    let levels = match side {
        Side::Buy => &book.asks,
        Side::Sell => &book.bids,
    };

    let mut remaining = quantity.raw();
    let mut levels_consumed = 0;

    let iter: Box<dyn Iterator<Item = &PriceLevel>> = match side {
        Side::Buy => Box::new(levels.values()),
        Side::Sell => Box::new(levels.values().rev()),
    };

    for level in iter {
        if remaining == 0 {
            break;
        }
        levels_consumed += 1;
        remaining = remaining.saturating_sub(level.total_quantity.raw());
    }

    Some(MarketImpact {
        avg_price: vwap,
        slippage_bps: slippage as i32,
        levels_consumed: levels_consumed,
        fully_fillable: remaining == 0,
    })
}

// ============================================================================
// Example Usage
// ============================================================================

fn main() -> i32 / {IO, OrderBookEvent} {
    print("=== Blood Order Book Implementation ===\n");

    // Create order book
    let mut book = OrderBook::new("AAPL");

    print("Symbol: {}", book.symbol);
    print("");

    // Add some initial orders
    print("Adding initial orders...\n");

    // Add bids (buy orders)
    let bid_prices = [
        ("150.00", 100),
        ("149.95", 200),
        ("149.90", 150),
        ("149.85", 300),
        ("149.80", 250),
    ];

    for (price_str, qty) in &bid_prices {
        let price = Price::from_str(price_str).unwrap();
        book.add_order(
            Side::Buy,
            price,
            Quantity::new(*qty),
            OrderType::Limit,
            TimeInForce::GTC,
        );
    }

    // Add asks (sell orders)
    let ask_prices = [
        ("150.05", 100),
        ("150.10", 200),
        ("150.15", 150),
        ("150.20", 300),
        ("150.25", 250),
    ];

    for (price_str, qty) in &ask_prices {
        let price = Price::from_str(price_str).unwrap();
        book.add_order(
            Side::Sell,
            price,
            Quantity::new(*qty),
            OrderType::Limit,
            TimeInForce::GTC,
        );
    }

    // Display book state
    print("=== Order Book State ===\n");

    let stats = book.stats();
    print("Book Statistics:");
    print("  Bid levels: {}", stats.bid_levels);
    print("  Ask levels: {}", stats.ask_levels);
    print("  Total bid orders: {}", stats.total_bid_orders);
    print("  Total ask orders: {}", stats.total_ask_orders);
    print("  Total bid volume: {}", stats.total_bid_volume.raw());
    print("  Total ask volume: {}", stats.total_ask_volume.raw());

    if let Some(spread) = stats.spread {
        print("  Spread: ${:.2}", spread.to_f64());
    }
    if let Some(mid) = stats.mid_price {
        print("  Mid price: ${:.4}", mid.to_f64());
    }

    // Display depth
    print("\n=== Book Depth (Top 5) ===\n");

    let depth = book.depth(5);

    print("{:>12} {:>10} {:>8} | {:>8} {:>10} {:>12}",
          "BID QTY", "ORDERS", "PRICE", "PRICE", "ORDERS", "ASK QTY");
    print("{}", "-".repeat(70));

    for i in 0..5 {
        let bid = depth.bids.get(i);
        let ask = depth.asks.get(i);

        let bid_str = match bid {
            Some(b) => format!("{:>12} {:>10} {:>8.2}",
                              b.quantity.raw(), b.order_count, b.price.to_f64()),
            None => " ".repeat(32),
        };

        let ask_str = match ask {
            Some(a) => format!("{:>8.2} {:>10} {:>12}",
                              a.price.to_f64(), a.order_count, a.quantity.raw()),
            None => " ".repeat(32),
        };

        print("{} | {}", bid_str, ask_str);
    }

    // Execute a market order
    print("\n=== Executing Market Buy Order for 150 shares ===\n");

    let (order_id, trades) = book.add_order(
        Side::Buy,
        Price::max(),  // Market order uses max price
        Quantity::new(150),
        OrderType::Market,
        TimeInForce::IOC,
    );

    print("Order ID: {}", order_id.raw());
    print("Trades executed: {}", trades.len());

    for trade in &trades {
        print("  Trade {}: {} shares @ ${:.2}",
              trade.id, trade.quantity.raw(), trade.price.to_f64());
    }

    // Calculate VWAP
    print("\n=== VWAP Analysis ===\n");

    let test_quantities = [100, 500, 1000];

    for qty in &test_quantities {
        if let Some(vwap) = calculate_vwap(&book, Side::Buy, Quantity::new(*qty)) {
            print("VWAP for {} shares (buy): ${:.4}", qty, vwap.to_f64());
        }
    }

    // Market impact
    print("\n=== Market Impact Estimation ===\n");

    if let Some(impact) = estimate_market_impact(&book, Side::Buy, Quantity::new(500)) {
        print("Impact of buying 500 shares:");
        print("  Average price: ${:.4}", impact.avg_price.to_f64());
        print("  Slippage: {} bps", impact.slippage_bps);
        print("  Levels consumed: {}", impact.levels_consumed);
        print("  Fully fillable: {}", impact.fully_fillable);
    }

    // Cancel an order
    print("\n=== Order Cancellation ===\n");

    // Cancel order with ID 3
    let cancelled = book.cancel_order(OrderId::new(3));
    print("Cancel order 3: {}", if cancelled { "SUCCESS" } else { "FAILED" });

    // Final state
    print("\n=== Final Book State ===\n");

    let final_depth = book.depth(3);

    print("Bids:");
    for level in &final_depth.bids {
        print("  ${:.2}: {} shares ({} orders)",
              level.price.to_f64(), level.quantity.raw(), level.order_count);
    }

    print("\nAsks:");
    for level in &final_depth.asks {
        print("  ${:.2}: {} shares ({} orders)",
              level.price.to_f64(), level.quantity.raw(), level.order_count);
    }

    print("\n=== All tests passed! ===");
    0
}

// ============================================================================
// Event Handler
// ============================================================================

fn main_with_handler() -> i32 / {IO} {
    try {
        main()
    } with {
        OrderBookEvent::order_added(id, side, price, qty) => {
            let side_str = match side {
                Side::Buy => "BUY",
                Side::Sell => "SELL",
            };
            print("EVENT: Order {} added - {} {} @ ${:.2}",
                  id.raw(), side_str, qty.raw(), price.to_f64());
            resume(())
        },
        OrderBookEvent::order_filled(id) => {
            print("EVENT: Order {} fully filled", id.raw());
            resume(())
        },
        OrderBookEvent::order_cancelled(id, reason) => {
            print("EVENT: Order {} cancelled - {}", id.raw(), reason);
            resume(())
        },
        OrderBookEvent::order_modified(id, new_qty) => {
            print("EVENT: Order {} modified to {} shares", id.raw(), new_qty.raw());
            resume(())
        },
        OrderBookEvent::trade_executed(buyer, seller, price, qty) => {
            print("TRADE: {} shares @ ${:.2} (buyer: {}, seller: {})",
                  qty.raw(), price.to_f64(), buyer.raw(), seller.raw());
            resume(())
        },
    }
}
