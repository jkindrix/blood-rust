// Test: Effect Row Polymorphism
// Verifies that a function with a row variable can call any effectful function

effect Emit<T> {
    op emit(value: T) -> ();
}

// A function that uses the Emit effect
fn emit_one() / {Emit<i32>} {
    perform Emit.emit(42);
}

// A function with a row variable 'e': it can call any effectful function
// The effects from callees are "absorbed" by the row variable
fn wrapper() / e {
    // This should work because 'e' absorbs Emit<i32>
    emit_one();
}

// A pure wrapper - this should FAIL if effect polymorphism isn't working
// because emit_one() uses Emit<i32> which isn't declared or handled
// fn pure_wrapper() {
//     emit_one();  // ERROR: Emit<i32> not handled
// }

fn main() {
    // Can't test wrapper() without an inline handler, but the type checking
    // should succeed if effect row polymorphism is working
}
