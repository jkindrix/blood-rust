// Spectral Norm Benchmark for Blood
// ==================================
//
// This benchmark computes the spectral norm of an infinite matrix A.
// It is modeled after the Computer Language Benchmarks Game "spectral-norm" benchmark.
//
// The spectral norm is the largest singular value, computed via power iteration:
//   spectral_norm(A) = sqrt(lambda_max(A^T * A))
//
// Key characteristics:
// - Dense matrix operations (element access patterns)
// - O(n²) per iteration (matrix-vector multiply)
// - Demonstrates Blood's floating-point and loop handling
// - Memory-efficient: uses vectors not full matrices

// ===========================================================================
// Matrix Element Function
// ===========================================================================

// Element A[i,j] of the infinite matrix
// A[i,j] = 1.0 / ((i+j)*(i+j+1)/2 + i + 1)
fn matrix_element(i: i32, j: i32) -> f64 {
    let sum = i + j;
    let denom = (sum * (sum + 1)) / 2 + i + 1;
    1.0 / (denom as f64)
}

// ===========================================================================
// Vector Operations
// ===========================================================================

// Square root using Newton-Raphson
fn sqrt(x: f64) -> f64 {
    if x <= 0.0 {
        return 0.0;
    }

    let mut guess = x / 2.0;
    if guess < 1.0 {
        guess = 1.0;
    }

    let mut i = 0;
    while i < 15 {
        guess = (guess + x / guess) / 2.0;
        i = i + 1;
    }

    guess
}

// ===========================================================================
// Power Iteration (Fixed Size for Simplicity)
// ===========================================================================

// For a small fixed N, we implement the spectral norm computation.
// In a real implementation, this would use dynamic arrays.

// Spectral norm for N=5 (demonstrating the algorithm)
fn spectral_norm_5() -> f64 {
    // Initialize u and v vectors (size 5)
    let mut u0: f64 = 1.0;
    let mut u1: f64 = 1.0;
    let mut u2: f64 = 1.0;
    let mut u3: f64 = 1.0;
    let mut u4: f64 = 1.0;

    let mut v0: f64 = 0.0;
    let mut v1: f64 = 0.0;
    let mut v2: f64 = 0.0;
    let mut v3: f64 = 0.0;
    let mut v4: f64 = 0.0;

    // Power iteration: 10 iterations
    let mut iter = 0;
    while iter < 10 {
        // v = A^T * (A * u)
        // First compute A * u -> temp
        let t0 = matrix_element(0, 0) * u0 + matrix_element(0, 1) * u1 +
                 matrix_element(0, 2) * u2 + matrix_element(0, 3) * u3 +
                 matrix_element(0, 4) * u4;
        let t1 = matrix_element(1, 0) * u0 + matrix_element(1, 1) * u1 +
                 matrix_element(1, 2) * u2 + matrix_element(1, 3) * u3 +
                 matrix_element(1, 4) * u4;
        let t2 = matrix_element(2, 0) * u0 + matrix_element(2, 1) * u1 +
                 matrix_element(2, 2) * u2 + matrix_element(2, 3) * u3 +
                 matrix_element(2, 4) * u4;
        let t3 = matrix_element(3, 0) * u0 + matrix_element(3, 1) * u1 +
                 matrix_element(3, 2) * u2 + matrix_element(3, 3) * u3 +
                 matrix_element(3, 4) * u4;
        let t4 = matrix_element(4, 0) * u0 + matrix_element(4, 1) * u1 +
                 matrix_element(4, 2) * u2 + matrix_element(4, 3) * u3 +
                 matrix_element(4, 4) * u4;

        // Then compute A^T * temp -> v
        v0 = matrix_element(0, 0) * t0 + matrix_element(1, 0) * t1 +
             matrix_element(2, 0) * t2 + matrix_element(3, 0) * t3 +
             matrix_element(4, 0) * t4;
        v1 = matrix_element(0, 1) * t0 + matrix_element(1, 1) * t1 +
             matrix_element(2, 1) * t2 + matrix_element(3, 1) * t3 +
             matrix_element(4, 1) * t4;
        v2 = matrix_element(0, 2) * t0 + matrix_element(1, 2) * t1 +
             matrix_element(2, 2) * t2 + matrix_element(3, 2) * t3 +
             matrix_element(4, 2) * t4;
        v3 = matrix_element(0, 3) * t0 + matrix_element(1, 3) * t1 +
             matrix_element(2, 3) * t2 + matrix_element(3, 3) * t3 +
             matrix_element(4, 3) * t4;
        v4 = matrix_element(0, 4) * t0 + matrix_element(1, 4) * t1 +
             matrix_element(2, 4) * t2 + matrix_element(3, 4) * t3 +
             matrix_element(4, 4) * t4;

        // u = A^T * (A * v)
        // First compute A * v -> temp
        let s0 = matrix_element(0, 0) * v0 + matrix_element(0, 1) * v1 +
                 matrix_element(0, 2) * v2 + matrix_element(0, 3) * v3 +
                 matrix_element(0, 4) * v4;
        let s1 = matrix_element(1, 0) * v0 + matrix_element(1, 1) * v1 +
                 matrix_element(1, 2) * v2 + matrix_element(1, 3) * v3 +
                 matrix_element(1, 4) * v4;
        let s2 = matrix_element(2, 0) * v0 + matrix_element(2, 1) * v1 +
                 matrix_element(2, 2) * v2 + matrix_element(2, 3) * v3 +
                 matrix_element(2, 4) * v4;
        let s3 = matrix_element(3, 0) * v0 + matrix_element(3, 1) * v1 +
                 matrix_element(3, 2) * v2 + matrix_element(3, 3) * v3 +
                 matrix_element(3, 4) * v4;
        let s4 = matrix_element(4, 0) * v0 + matrix_element(4, 1) * v1 +
                 matrix_element(4, 2) * v2 + matrix_element(4, 3) * v3 +
                 matrix_element(4, 4) * v4;

        // Then compute A^T * temp -> u
        u0 = matrix_element(0, 0) * s0 + matrix_element(1, 0) * s1 +
             matrix_element(2, 0) * s2 + matrix_element(3, 0) * s3 +
             matrix_element(4, 0) * s4;
        u1 = matrix_element(0, 1) * s0 + matrix_element(1, 1) * s1 +
             matrix_element(2, 1) * s2 + matrix_element(3, 1) * s3 +
             matrix_element(4, 1) * s4;
        u2 = matrix_element(0, 2) * s0 + matrix_element(1, 2) * s1 +
             matrix_element(2, 2) * s2 + matrix_element(3, 2) * s3 +
             matrix_element(4, 2) * s4;
        u3 = matrix_element(0, 3) * s0 + matrix_element(1, 3) * s1 +
             matrix_element(2, 3) * s2 + matrix_element(3, 3) * s3 +
             matrix_element(4, 3) * s4;
        u4 = matrix_element(0, 4) * s0 + matrix_element(1, 4) * s1 +
             matrix_element(2, 4) * s2 + matrix_element(3, 4) * s3 +
             matrix_element(4, 4) * s4;

        iter = iter + 1;
    }

    // Compute sqrt((u · v) / (v · v))
    let uv = u0 * v0 + u1 * v1 + u2 * v2 + u3 * v3 + u4 * v4;
    let vv = v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3 + v4 * v4;

    sqrt(uv / vv)
}

// Spectral norm for N=10 (larger test)
fn spectral_norm_10() -> f64 {
    // Initialize u vector (size 10, all 1.0)
    let mut u: [f64; 10] = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0];
    let mut v: [f64; 10] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    let mut temp: [f64; 10] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];

    // Power iteration: 10 iterations
    let mut iter = 0;
    while iter < 10 {
        // v = A^T * (A * u)
        mult_Av_10(&u, &mut temp);
        mult_Atv_10(&temp, &mut v);

        // u = A^T * (A * v)
        mult_Av_10(&v, &mut temp);
        mult_Atv_10(&temp, &mut u);

        iter = iter + 1;
    }

    // Compute sqrt((u · v) / (v · v))
    let mut uv: f64 = 0.0;
    let mut vv: f64 = 0.0;
    let mut i = 0;
    while i < 10 {
        uv = uv + u[i] * v[i];
        vv = vv + v[i] * v[i];
        i = i + 1;
    }

    sqrt(uv / vv)
}

// Multiply A * v for N=10
fn mult_Av_10(v: &[f64; 10], result: &mut [f64; 10]) {
    let mut i = 0;
    while i < 10 {
        let mut sum: f64 = 0.0;
        let mut j = 0;
        while j < 10 {
            sum = sum + matrix_element(i, j) * v[j];
            j = j + 1;
        }
        result[i] = sum;
        i = i + 1;
    }
}

// Multiply A^T * v for N=10
fn mult_Atv_10(v: &[f64; 10], result: &mut [f64; 10]) {
    let mut i = 0;
    while i < 10 {
        let mut sum: f64 = 0.0;
        let mut j = 0;
        while j < 10 {
            sum = sum + matrix_element(j, i) * v[j];
            j = j + 1;
        }
        result[i] = sum;
        i = i + 1;
    }
}

// ===========================================================================
// Verification
// ===========================================================================

// Expected spectral norm for different N values (from reference implementations)
// N=5:   ~1.2619...
// N=10:  ~1.2738...
// N=100: ~1.274219...
// N=5500: ~1.274224153...

fn verify_spectral_norm(n: i32, computed: f64, expected_min: f64, expected_max: f64) -> bool {
    computed >= expected_min && computed <= expected_max
}

// ===========================================================================
// Main Entry Point
// ===========================================================================

fn main() {
    println_str("================================================================");
    println_str("     Spectral Norm Benchmark for Blood");
    println_str("     (Computer Language Benchmarks Game)");
    println_str("================================================================");
    println_str("");

    println_str("Computing spectral norm of infinite matrix A");
    println_str("A[i,j] = 1.0 / ((i+j)*(i+j+1)/2 + i + 1)");
    println_str("");

    // Test N=5
    println_str("=== N=5 ===");
    let result5 = spectral_norm_5();
    print_str("Spectral norm: ");
    println_f64(result5);
    print_str("Expected range: 1.26 - 1.27");
    println_str("");
    if verify_spectral_norm(5, result5, 1.26, 1.27) {
        println_str("Verification: PASS");
    } else {
        println_str("Verification: FAIL");
    }
    println_str("");

    // Test N=10
    println_str("=== N=10 ===");
    let result10 = spectral_norm_10();
    print_str("Spectral norm: ");
    println_f64(result10);
    print_str("Expected range: 1.27 - 1.28");
    println_str("");
    if verify_spectral_norm(10, result10, 1.27, 1.28) {
        println_str("Verification: PASS");
    } else {
        println_str("Verification: FAIL");
    }
    println_str("");

    println_str("=== Performance Notes ===");
    println_str("");
    println_str("This benchmark tests:");
    println_str("1. Floating-point arithmetic (many multiplications)");
    println_str("2. Array indexing patterns");
    println_str("3. Nested loop performance");
    println_str("4. Function call overhead (matrix_element)");
    println_str("");
    println_str("Key insight: Spectral norm converges quickly.");
    println_str("10 iterations typically sufficient for 9 digits.");
    println_str("");

    println_str("================================================================");
    println_str("     Benchmark Complete");
    println_str("================================================================");
}
