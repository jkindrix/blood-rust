// SQLite Database Driver in Blood
// ================================
//
// A complete SQLite database driver demonstrating Blood's FFI capabilities,
// effect system, and resource management patterns.
//
// This example shows:
// - FFI bindings to SQLite C library
// - Effect-based database operations
// - Resource management with RAII patterns
// - Type-safe query building
// - Prepared statements
// - Transaction support
// - Connection pooling

// ===========================================================================
// 1. FFI Declarations for SQLite
// ===========================================================================

/// SQLite return codes
const SQLITE_OK: i32 = 0;
const SQLITE_ERROR: i32 = 1;
const SQLITE_BUSY: i32 = 5;
const SQLITE_LOCKED: i32 = 6;
const SQLITE_NOMEM: i32 = 7;
const SQLITE_READONLY: i32 = 8;
const SQLITE_CONSTRAINT: i32 = 19;
const SQLITE_MISMATCH: i32 = 20;
const SQLITE_MISUSE: i32 = 21;
const SQLITE_ROW: i32 = 100;
const SQLITE_DONE: i32 = 101;

/// SQLite column types
const SQLITE_INTEGER: i32 = 1;
const SQLITE_FLOAT: i32 = 2;
const SQLITE_TEXT: i32 = 3;
const SQLITE_BLOB: i32 = 4;
const SQLITE_NULL: i32 = 5;

/// Opaque pointer types for SQLite handles
type SqliteDb = *mut c_void;
type SqliteStmt = *mut c_void;

/// FFI bindings to SQLite C library
extern "C" {
    fn sqlite3_open(filename: *const c_char, ppDb: *mut SqliteDb) -> i32;
    fn sqlite3_close(db: SqliteDb) -> i32;
    fn sqlite3_exec(
        db: SqliteDb,
        sql: *const c_char,
        callback: *const c_void,
        arg: *mut c_void,
        errmsg: *mut *mut c_char
    ) -> i32;
    fn sqlite3_prepare_v2(
        db: SqliteDb,
        sql: *const c_char,
        nByte: i32,
        ppStmt: *mut SqliteStmt,
        pzTail: *mut *const c_char
    ) -> i32;
    fn sqlite3_step(stmt: SqliteStmt) -> i32;
    fn sqlite3_reset(stmt: SqliteStmt) -> i32;
    fn sqlite3_finalize(stmt: SqliteStmt) -> i32;
    fn sqlite3_bind_int(stmt: SqliteStmt, index: i32, value: i32) -> i32;
    fn sqlite3_bind_int64(stmt: SqliteStmt, index: i32, value: i64) -> i32;
    fn sqlite3_bind_double(stmt: SqliteStmt, index: i32, value: f64) -> i32;
    fn sqlite3_bind_text(
        stmt: SqliteStmt,
        index: i32,
        value: *const c_char,
        n: i32,
        destructor: *const c_void
    ) -> i32;
    fn sqlite3_bind_blob(
        stmt: SqliteStmt,
        index: i32,
        value: *const c_void,
        n: i32,
        destructor: *const c_void
    ) -> i32;
    fn sqlite3_bind_null(stmt: SqliteStmt, index: i32) -> i32;
    fn sqlite3_column_count(stmt: SqliteStmt) -> i32;
    fn sqlite3_column_type(stmt: SqliteStmt, index: i32) -> i32;
    fn sqlite3_column_int(stmt: SqliteStmt, index: i32) -> i32;
    fn sqlite3_column_int64(stmt: SqliteStmt, index: i32) -> i64;
    fn sqlite3_column_double(stmt: SqliteStmt, index: i32) -> f64;
    fn sqlite3_column_text(stmt: SqliteStmt, index: i32) -> *const c_char;
    fn sqlite3_column_blob(stmt: SqliteStmt, index: i32) -> *const c_void;
    fn sqlite3_column_bytes(stmt: SqliteStmt, index: i32) -> i32;
    fn sqlite3_column_name(stmt: SqliteStmt, index: i32) -> *const c_char;
    fn sqlite3_errmsg(db: SqliteDb) -> *const c_char;
    fn sqlite3_changes(db: SqliteDb) -> i32;
    fn sqlite3_last_insert_rowid(db: SqliteDb) -> i64;
    fn sqlite3_free(ptr: *mut c_void);
}

// SQLITE_TRANSIENT constant for text/blob binding
const SQLITE_TRANSIENT: *const c_void = (-1) as *const c_void;

// ===========================================================================
// 2. Error Types
// ===========================================================================

/// Database errors
enum DbError {
    ConnectionFailed(String),
    QueryFailed(String),
    BindFailed(String),
    TypeMismatch(String),
    NotFound,
    Busy,
    Locked,
    Constraint(String),
    InvalidState(String),
}

impl DbError {
    fn to_string(&self) -> String / pure {
        match self {
            DbError::ConnectionFailed(msg) => format!("Connection failed: {}", msg),
            DbError::QueryFailed(msg) => format!("Query failed: {}", msg),
            DbError::BindFailed(msg) => format!("Bind failed: {}", msg),
            DbError::TypeMismatch(msg) => format!("Type mismatch: {}", msg),
            DbError::NotFound => "Not found".to_string(),
            DbError::Busy => "Database is busy".to_string(),
            DbError::Locked => "Database is locked".to_string(),
            DbError::Constraint(msg) => format!("Constraint violation: {}", msg),
            DbError::InvalidState(msg) => format!("Invalid state: {}", msg),
        }
    }

    fn from_sqlite_error(code: i32, msg: &str) -> DbError / pure {
        match code {
            SQLITE_BUSY => DbError::Busy,
            SQLITE_LOCKED => DbError::Locked,
            SQLITE_CONSTRAINT => DbError::Constraint(msg.to_string()),
            _ => DbError::QueryFailed(msg.to_string()),
        }
    }
}

/// Effect for database errors
effect DbErr {
    op error(err: DbError) -> !;
}

// ===========================================================================
// 3. Value Types
// ===========================================================================

/// A value that can be stored in SQLite
enum SqlValue {
    Null,
    Integer(i64),
    Real(f64),
    Text(String),
    Blob(Vec<u8>),
}

impl SqlValue {
    fn as_int(&self) -> Option<i64> / pure {
        match self {
            SqlValue::Integer(n) => Some(*n),
            SqlValue::Real(f) => Some(*f as i64),
            SqlValue::Text(s) => s.parse::<i64>().ok(),
            _ => None,
        }
    }

    fn as_float(&self) -> Option<f64> / pure {
        match self {
            SqlValue::Real(f) => Some(*f),
            SqlValue::Integer(n) => Some(*n as f64),
            SqlValue::Text(s) => s.parse::<f64>().ok(),
            _ => None,
        }
    }

    fn as_string(&self) -> Option<&String> / pure {
        match self {
            SqlValue::Text(s) => Some(s),
            _ => None,
        }
    }

    fn as_blob(&self) -> Option<&Vec<u8>> / pure {
        match self {
            SqlValue::Blob(b) => Some(b),
            _ => None,
        }
    }

    fn is_null(&self) -> bool / pure {
        matches!(self, SqlValue::Null)
    }

    fn to_string(&self) -> String / pure {
        match self {
            SqlValue::Null => "NULL".to_string(),
            SqlValue::Integer(n) => n.to_string(),
            SqlValue::Real(f) => f.to_string(),
            SqlValue::Text(s) => format!("'{}'", s),
            SqlValue::Blob(b) => format!("<blob {} bytes>", b.len()),
        }
    }
}

/// Trait for types that can be converted to SQL values
trait ToSql {
    fn to_sql(&self) -> SqlValue;
}

impl ToSql for i32 {
    fn to_sql(&self) -> SqlValue / pure {
        SqlValue::Integer(*self as i64)
    }
}

impl ToSql for i64 {
    fn to_sql(&self) -> SqlValue / pure {
        SqlValue::Integer(*self)
    }
}

impl ToSql for f64 {
    fn to_sql(&self) -> SqlValue / pure {
        SqlValue::Real(*self)
    }
}

impl ToSql for String {
    fn to_sql(&self) -> SqlValue / pure {
        SqlValue::Text(self.clone())
    }
}

impl ToSql for &str {
    fn to_sql(&self) -> SqlValue / pure {
        SqlValue::Text(self.to_string())
    }
}

impl ToSql for bool {
    fn to_sql(&self) -> SqlValue / pure {
        SqlValue::Integer(if *self { 1 } else { 0 })
    }
}

impl<T: ToSql> ToSql for Option<T> {
    fn to_sql(&self) -> SqlValue / pure {
        match self {
            Some(v) => v.to_sql(),
            None => SqlValue::Null,
        }
    }
}

// ===========================================================================
// 4. Row and Result Set
// ===========================================================================

/// A single row from a query result
struct Row {
    columns: Vec<String>,
    values: Vec<SqlValue>,
}

impl Row {
    fn new() -> Row / pure {
        Row {
            columns: Vec::new(),
            values: Vec::new(),
        }
    }

    /// Get value by column index
    fn get(&self, index: usize) -> Option<&SqlValue> / pure {
        self.values.get(index)
    }

    /// Get value by column name
    fn get_by_name(&self, name: &str) -> Option<&SqlValue> / pure {
        for (i, col) in self.columns.iter().enumerate() {
            if col == name {
                return self.values.get(i);
            }
        }
        None
    }

    /// Get integer by column index
    fn get_int(&self, index: usize) -> Option<i64> / pure {
        self.get(index).and_then(|v| v.as_int())
    }

    /// Get integer by column name
    fn get_int_by_name(&self, name: &str) -> Option<i64> / pure {
        self.get_by_name(name).and_then(|v| v.as_int())
    }

    /// Get float by column index
    fn get_float(&self, index: usize) -> Option<f64> / pure {
        self.get(index).and_then(|v| v.as_float())
    }

    /// Get string by column index
    fn get_string(&self, index: usize) -> Option<&String> / pure {
        self.get(index).and_then(|v| v.as_string())
    }

    /// Get string by column name
    fn get_string_by_name(&self, name: &str) -> Option<&String> / pure {
        self.get_by_name(name).and_then(|v| v.as_string())
    }

    /// Number of columns
    fn len(&self) -> usize / pure {
        self.values.len()
    }
}

/// Query result set
struct Rows {
    rows: Vec<Row>,
    current: usize,
}

impl Rows {
    fn new() -> Rows / pure {
        Rows {
            rows: Vec::new(),
            current: 0,
        }
    }

    /// Get next row
    fn next(&mut self) -> Option<&Row> / pure {
        if self.current < self.rows.len() {
            let row = &self.rows[self.current];
            self.current += 1;
            Some(row)
        } else {
            None
        }
    }

    /// Reset iteration
    fn reset(&mut self) / pure {
        self.current = 0;
    }

    /// Number of rows
    fn len(&self) -> usize / pure {
        self.rows.len()
    }

    /// Check if empty
    fn is_empty(&self) -> bool / pure {
        self.rows.is_empty()
    }

    /// Get all rows as slice
    fn all(&self) -> &[Row] / pure {
        &self.rows
    }

    /// Get first row
    fn first(&self) -> Option<&Row> / pure {
        self.rows.first()
    }
}

// ===========================================================================
// 5. Prepared Statement
// ===========================================================================

/// A prepared SQL statement
struct Statement {
    stmt: SqliteStmt,
    db: SqliteDb,
    sql: String,
    param_count: i32,
}

impl Statement {
    /// Bind an integer parameter
    fn bind_int(&mut self, index: i32, value: i64) -> Result<(), DbError> / pure {
        let rc = @unsafe { sqlite3_bind_int64(self.stmt, index, value) };
        if rc != SQLITE_OK {
            Err(DbError::BindFailed(format!("index {}", index)))
        } else {
            Ok(())
        }
    }

    /// Bind a float parameter
    fn bind_float(&mut self, index: i32, value: f64) -> Result<(), DbError> / pure {
        let rc = @unsafe { sqlite3_bind_double(self.stmt, index, value) };
        if rc != SQLITE_OK {
            Err(DbError::BindFailed(format!("index {}", index)))
        } else {
            Ok(())
        }
    }

    /// Bind a text parameter
    fn bind_text(&mut self, index: i32, value: &str) -> Result<(), DbError> / pure {
        let cstr = CString::new(value).unwrap();
        let rc = @unsafe {
            sqlite3_bind_text(self.stmt, index, cstr.as_ptr(), -1, SQLITE_TRANSIENT)
        };
        if rc != SQLITE_OK {
            Err(DbError::BindFailed(format!("index {}", index)))
        } else {
            Ok(())
        }
    }

    /// Bind a blob parameter
    fn bind_blob(&mut self, index: i32, value: &[u8]) -> Result<(), DbError> / pure {
        let rc = @unsafe {
            sqlite3_bind_blob(
                self.stmt,
                index,
                value.as_ptr() as *const c_void,
                value.len() as i32,
                SQLITE_TRANSIENT
            )
        };
        if rc != SQLITE_OK {
            Err(DbError::BindFailed(format!("index {}", index)))
        } else {
            Ok(())
        }
    }

    /// Bind a null parameter
    fn bind_null(&mut self, index: i32) -> Result<(), DbError> / pure {
        let rc = @unsafe { sqlite3_bind_null(self.stmt, index) };
        if rc != SQLITE_OK {
            Err(DbError::BindFailed(format!("index {}", index)))
        } else {
            Ok(())
        }
    }

    /// Bind a SqlValue
    fn bind(&mut self, index: i32, value: &SqlValue) -> Result<(), DbError> / pure {
        match value {
            SqlValue::Null => self.bind_null(index),
            SqlValue::Integer(n) => self.bind_int(index, *n),
            SqlValue::Real(f) => self.bind_float(index, *f),
            SqlValue::Text(s) => self.bind_text(index, s),
            SqlValue::Blob(b) => self.bind_blob(index, b),
        }
    }

    /// Execute the statement (for INSERT/UPDATE/DELETE)
    fn execute(&mut self) -> Result<i32, DbError> / pure {
        let rc = @unsafe { sqlite3_step(self.stmt) };
        match rc {
            SQLITE_DONE => {
                let changes = @unsafe { sqlite3_changes(self.db) };
                Ok(changes)
            }
            SQLITE_ROW => {
                // Statement returned rows unexpectedly
                Ok(0)
            }
            _ => {
                let errmsg = @unsafe {
                    let msg = sqlite3_errmsg(self.db);
                    CStr::from_ptr(msg).to_string_lossy().to_string()
                };
                Err(DbError::from_sqlite_error(rc, &errmsg))
            }
        }
    }

    /// Query and return rows
    fn query(&mut self) -> Result<Rows, DbError> / pure {
        let mut rows = Rows::new();
        let col_count = @unsafe { sqlite3_column_count(self.stmt) };

        // Get column names
        let mut column_names = Vec::new();
        for i in 0..col_count {
            let name = @unsafe {
                let ptr = sqlite3_column_name(self.stmt, i);
                CStr::from_ptr(ptr).to_string_lossy().to_string()
            };
            column_names.push(name);
        }

        // Fetch rows
        loop {
            let rc = @unsafe { sqlite3_step(self.stmt) };
            match rc {
                SQLITE_ROW => {
                    let mut row = Row {
                        columns: column_names.clone(),
                        values: Vec::new(),
                    };

                    for i in 0..col_count {
                        let col_type = @unsafe { sqlite3_column_type(self.stmt, i) };
                        let value = match col_type {
                            SQLITE_INTEGER => {
                                let n = @unsafe { sqlite3_column_int64(self.stmt, i) };
                                SqlValue::Integer(n)
                            }
                            SQLITE_FLOAT => {
                                let f = @unsafe { sqlite3_column_double(self.stmt, i) };
                                SqlValue::Real(f)
                            }
                            SQLITE_TEXT => {
                                let ptr = @unsafe { sqlite3_column_text(self.stmt, i) };
                                let s = @unsafe { CStr::from_ptr(ptr).to_string_lossy().to_string() };
                                SqlValue::Text(s)
                            }
                            SQLITE_BLOB => {
                                let ptr = @unsafe { sqlite3_column_blob(self.stmt, i) };
                                let len = @unsafe { sqlite3_column_bytes(self.stmt, i) };
                                let slice = @unsafe {
                                    std::slice::from_raw_parts(ptr as *const u8, len as usize)
                                };
                                SqlValue::Blob(slice.to_vec())
                            }
                            SQLITE_NULL | _ => SqlValue::Null,
                        };
                        row.values.push(value);
                    }

                    rows.rows.push(row);
                }
                SQLITE_DONE => break,
                _ => {
                    let errmsg = @unsafe {
                        let msg = sqlite3_errmsg(self.db);
                        CStr::from_ptr(msg).to_string_lossy().to_string()
                    };
                    return Err(DbError::from_sqlite_error(rc, &errmsg));
                }
            }
        }

        Ok(rows)
    }

    /// Reset the statement for reuse
    fn reset(&mut self) -> Result<(), DbError> / pure {
        let rc = @unsafe { sqlite3_reset(self.stmt) };
        if rc != SQLITE_OK {
            let errmsg = @unsafe {
                let msg = sqlite3_errmsg(self.db);
                CStr::from_ptr(msg).to_string_lossy().to_string()
            };
            Err(DbError::QueryFailed(errmsg))
        } else {
            Ok(())
        }
    }
}

impl Drop for Statement {
    fn drop(&mut self) {
        @unsafe { sqlite3_finalize(self.stmt) };
    }
}

// ===========================================================================
// 6. Database Connection
// ===========================================================================

/// SQLite database connection
struct Connection {
    db: SqliteDb,
    path: String,
}

impl Connection {
    /// Open a database connection
    fn open(path: &str) -> Result<Connection, DbError> / pure {
        let cpath = CString::new(path).unwrap();
        let mut db: SqliteDb = std::ptr::null_mut();

        let rc = @unsafe { sqlite3_open(cpath.as_ptr(), &mut db) };

        if rc != SQLITE_OK {
            let errmsg = if !db.is_null() {
                @unsafe {
                    let msg = sqlite3_errmsg(db);
                    let s = CStr::from_ptr(msg).to_string_lossy().to_string();
                    sqlite3_close(db);
                    s
                }
            } else {
                "Unknown error".to_string()
            };
            return Err(DbError::ConnectionFailed(errmsg));
        }

        Ok(Connection {
            db,
            path: path.to_string(),
        })
    }

    /// Open an in-memory database
    fn open_in_memory() -> Result<Connection, DbError> / pure {
        Connection::open(":memory:")
    }

    /// Execute a SQL statement directly
    fn execute(&self, sql: &str) -> Result<i32, DbError> / pure {
        let csql = CString::new(sql).unwrap();
        let mut errmsg: *mut c_char = std::ptr::null_mut();

        let rc = @unsafe {
            sqlite3_exec(self.db, csql.as_ptr(), std::ptr::null(), std::ptr::null_mut(), &mut errmsg)
        };

        if rc != SQLITE_OK {
            let msg = if !errmsg.is_null() {
                let s = @unsafe { CStr::from_ptr(errmsg).to_string_lossy().to_string() };
                @unsafe { sqlite3_free(errmsg as *mut c_void) };
                s
            } else {
                "Unknown error".to_string()
            };
            return Err(DbError::from_sqlite_error(rc, &msg));
        }

        let changes = @unsafe { sqlite3_changes(self.db) };
        Ok(changes)
    }

    /// Prepare a SQL statement
    fn prepare(&self, sql: &str) -> Result<Statement, DbError> / pure {
        let csql = CString::new(sql).unwrap();
        let mut stmt: SqliteStmt = std::ptr::null_mut();
        let mut tail: *const c_char = std::ptr::null();

        let rc = @unsafe {
            sqlite3_prepare_v2(self.db, csql.as_ptr(), -1, &mut stmt, &mut tail)
        };

        if rc != SQLITE_OK {
            let errmsg = @unsafe {
                let msg = sqlite3_errmsg(self.db);
                CStr::from_ptr(msg).to_string_lossy().to_string()
            };
            return Err(DbError::QueryFailed(errmsg));
        }

        Ok(Statement {
            stmt,
            db: self.db,
            sql: sql.to_string(),
            param_count: 0,  // Could query sqlite3_bind_parameter_count
        })
    }

    /// Query and return all rows
    fn query(&self, sql: &str) -> Result<Rows, DbError> / pure {
        let mut stmt = self.prepare(sql)?;
        stmt.query()
    }

    /// Query with parameters
    fn query_with(&self, sql: &str, params: &[SqlValue]) -> Result<Rows, DbError> / pure {
        let mut stmt = self.prepare(sql)?;
        for (i, param) in params.iter().enumerate() {
            stmt.bind((i + 1) as i32, param)?;
        }
        stmt.query()
    }

    /// Execute with parameters
    fn execute_with(&self, sql: &str, params: &[SqlValue]) -> Result<i32, DbError> / pure {
        let mut stmt = self.prepare(sql)?;
        for (i, param) in params.iter().enumerate() {
            stmt.bind((i + 1) as i32, param)?;
        }
        stmt.execute()
    }

    /// Get the last inserted row ID
    fn last_insert_rowid(&self) -> i64 / pure {
        @unsafe { sqlite3_last_insert_rowid(self.db) }
    }

    /// Begin a transaction
    fn begin_transaction(&self) -> Result<Transaction, DbError> / pure {
        self.execute("BEGIN TRANSACTION")?;
        Ok(Transaction {
            conn: self,
            committed: false,
        })
    }

    /// Check if database is open
    fn is_open(&self) -> bool / pure {
        !self.db.is_null()
    }
}

impl Drop for Connection {
    fn drop(&mut self) {
        if !self.db.is_null() {
            @unsafe { sqlite3_close(self.db) };
        }
    }
}

// ===========================================================================
// 7. Transaction
// ===========================================================================

/// A database transaction
struct Transaction<'a> {
    conn: &'a Connection,
    committed: bool,
}

impl<'a> Transaction<'a> {
    /// Commit the transaction
    fn commit(mut self) -> Result<(), DbError> / pure {
        self.conn.execute("COMMIT")?;
        self.committed = true;
        Ok(())
    }

    /// Rollback the transaction
    fn rollback(mut self) -> Result<(), DbError> / pure {
        self.conn.execute("ROLLBACK")?;
        self.committed = true;  // Mark as handled
        Ok(())
    }

    /// Execute within transaction
    fn execute(&self, sql: &str) -> Result<i32, DbError> / pure {
        self.conn.execute(sql)
    }

    /// Query within transaction
    fn query(&self, sql: &str) -> Result<Rows, DbError> / pure {
        self.conn.query(sql)
    }
}

impl<'a> Drop for Transaction<'a> {
    fn drop(&mut self) {
        // Auto-rollback if not committed
        if !self.committed {
            let _ = self.conn.execute("ROLLBACK");
        }
    }
}

// ===========================================================================
// 8. Query Builder
// ===========================================================================

/// Fluent query builder
struct QueryBuilder {
    table: String,
    select_cols: Vec<String>,
    where_clauses: Vec<String>,
    order_by: Option<String>,
    limit: Option<u32>,
    offset: Option<u32>,
    params: Vec<SqlValue>,
}

impl QueryBuilder {
    fn table(name: &str) -> QueryBuilder / pure {
        QueryBuilder {
            table: name.to_string(),
            select_cols: Vec::new(),
            where_clauses: Vec::new(),
            order_by: None,
            limit: None,
            offset: None,
            params: Vec::new(),
        }
    }

    fn select(mut self, cols: &[&str]) -> QueryBuilder / pure {
        self.select_cols = cols.iter().map(|s| s.to_string()).collect();
        self
    }

    fn where_eq<T: ToSql>(mut self, col: &str, value: T) -> QueryBuilder / pure {
        self.where_clauses.push(format!("{} = ?", col));
        self.params.push(value.to_sql());
        self
    }

    fn where_like(mut self, col: &str, pattern: &str) -> QueryBuilder / pure {
        self.where_clauses.push(format!("{} LIKE ?", col));
        self.params.push(SqlValue::Text(pattern.to_string()));
        self
    }

    fn where_gt<T: ToSql>(mut self, col: &str, value: T) -> QueryBuilder / pure {
        self.where_clauses.push(format!("{} > ?", col));
        self.params.push(value.to_sql());
        self
    }

    fn where_lt<T: ToSql>(mut self, col: &str, value: T) -> QueryBuilder / pure {
        self.where_clauses.push(format!("{} < ?", col));
        self.params.push(value.to_sql());
        self
    }

    fn where_in<T: ToSql>(mut self, col: &str, values: &[T]) -> QueryBuilder / pure {
        let placeholders: Vec<&str> = values.iter().map(|_| "?").collect();
        self.where_clauses.push(format!("{} IN ({})", col, placeholders.join(", ")));
        for v in values {
            self.params.push(v.to_sql());
        }
        self
    }

    fn order_by(mut self, col: &str, desc: bool) -> QueryBuilder / pure {
        let dir = if desc { "DESC" } else { "ASC" };
        self.order_by = Some(format!("{} {}", col, dir));
        self
    }

    fn limit(mut self, n: u32) -> QueryBuilder / pure {
        self.limit = Some(n);
        self
    }

    fn offset(mut self, n: u32) -> QueryBuilder / pure {
        self.offset = Some(n);
        self
    }

    fn build_sql(&self) -> String / pure {
        let cols = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut sql = format!("SELECT {} FROM {}", cols, self.table);

        if !self.where_clauses.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&self.where_clauses.join(" AND "));
        }

        if let Some(ref order) = self.order_by {
            sql.push_str(" ORDER BY ");
            sql.push_str(order);
        }

        if let Some(limit) = self.limit {
            sql.push_str(&format!(" LIMIT {}", limit));
        }

        if let Some(offset) = self.offset {
            sql.push_str(&format!(" OFFSET {}", offset));
        }

        sql
    }

    fn execute(&self, conn: &Connection) -> Result<Rows, DbError> / pure {
        let sql = self.build_sql();
        conn.query_with(&sql, &self.params)
    }
}

/// Insert builder
struct InsertBuilder {
    table: String,
    columns: Vec<String>,
    values: Vec<SqlValue>,
}

impl InsertBuilder {
    fn into(table: &str) -> InsertBuilder / pure {
        InsertBuilder {
            table: table.to_string(),
            columns: Vec::new(),
            values: Vec::new(),
        }
    }

    fn column<T: ToSql>(mut self, name: &str, value: T) -> InsertBuilder / pure {
        self.columns.push(name.to_string());
        self.values.push(value.to_sql());
        self
    }

    fn build_sql(&self) -> String / pure {
        let cols = self.columns.join(", ");
        let placeholders: Vec<&str> = self.columns.iter().map(|_| "?").collect();
        format!("INSERT INTO {} ({}) VALUES ({})", self.table, cols, placeholders.join(", "))
    }

    fn execute(&self, conn: &Connection) -> Result<i64, DbError> / pure {
        let sql = self.build_sql();
        conn.execute_with(&sql, &self.values)?;
        Ok(conn.last_insert_rowid())
    }
}

/// Update builder
struct UpdateBuilder {
    table: String,
    sets: Vec<String>,
    where_clauses: Vec<String>,
    params: Vec<SqlValue>,
}

impl UpdateBuilder {
    fn table(name: &str) -> UpdateBuilder / pure {
        UpdateBuilder {
            table: name.to_string(),
            sets: Vec::new(),
            where_clauses: Vec::new(),
            params: Vec::new(),
        }
    }

    fn set<T: ToSql>(mut self, col: &str, value: T) -> UpdateBuilder / pure {
        self.sets.push(format!("{} = ?", col));
        self.params.push(value.to_sql());
        self
    }

    fn where_eq<T: ToSql>(mut self, col: &str, value: T) -> UpdateBuilder / pure {
        self.where_clauses.push(format!("{} = ?", col));
        self.params.push(value.to_sql());
        self
    }

    fn build_sql(&self) -> String / pure {
        let mut sql = format!("UPDATE {} SET {}", self.table, self.sets.join(", "));
        if !self.where_clauses.is_empty() {
            sql.push_str(" WHERE ");
            sql.push_str(&self.where_clauses.join(" AND "));
        }
        sql
    }

    fn execute(&self, conn: &Connection) -> Result<i32, DbError> / pure {
        let sql = self.build_sql();
        conn.execute_with(&sql, &self.params)
    }
}

// ===========================================================================
// 9. Database Effect
// ===========================================================================

/// Effect for database operations
effect Database {
    /// Execute a query
    op query(sql: &str) -> Result<Rows, DbError>;

    /// Execute a statement
    op execute(sql: &str) -> Result<i32, DbError>;

    /// Begin a transaction
    op transaction<T>(f: fn() -> T) -> Result<T, DbError>;
}

/// Handler that uses a Connection
deep handler DbConnectionHandler for Database {
    let conn: &Connection

    return(x) { x }

    op query(sql) {
        let result = conn.query(sql);
        resume(result)
    }

    op execute(sql) {
        let result = conn.execute(sql);
        resume(result)
    }

    op transaction(f) {
        match conn.begin_transaction() {
            Ok(tx) => {
                let result = f();
                match tx.commit() {
                    Ok(()) => resume(Ok(result)),
                    Err(e) => resume(Err(e)),
                }
            }
            Err(e) => resume(Err(e)),
        }
    }
}

// ===========================================================================
// 10. Example Application
// ===========================================================================

/// Example: A simple user management system
fn main() -> i32 / {IO} {
    println!("Blood SQLite Driver Example");
    println!("===========================\n");

    // Open an in-memory database
    let conn = match Connection::open_in_memory() {
        Ok(c) => c,
        Err(e) => {
            println!("Failed to open database: {}", e.to_string());
            return 1;
        }
    };

    println!("Database opened successfully.\n");

    // Create tables
    let create_users = "
        CREATE TABLE users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL,
            age INTEGER,
            active INTEGER DEFAULT 1,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ";

    let create_posts = "
        CREATE TABLE posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT NOT NULL,
            content TEXT,
            published INTEGER DEFAULT 0,
            FOREIGN KEY (user_id) REFERENCES users(id)
        )
    ";

    if let Err(e) = conn.execute(create_users) {
        println!("Failed to create users table: {}", e.to_string());
        return 1;
    }

    if let Err(e) = conn.execute(create_posts) {
        println!("Failed to create posts table: {}", e.to_string());
        return 1;
    }

    println!("Tables created successfully.\n");

    // Insert some users using the query builder
    let alice_id = InsertBuilder::into("users")
        .column("name", "Alice")
        .column("email", "alice@example.com")
        .column("age", 30)
        .execute(&conn)
        .unwrap();

    let bob_id = InsertBuilder::into("users")
        .column("name", "Bob")
        .column("email", "bob@example.com")
        .column("age", 25)
        .execute(&conn)
        .unwrap();

    let charlie_id = InsertBuilder::into("users")
        .column("name", "Charlie")
        .column("email", "charlie@example.com")
        .column("age", 35)
        .column("active", false)
        .execute(&conn)
        .unwrap();

    println!("Inserted users: Alice (id={}), Bob (id={}), Charlie (id={})\n",
        alice_id, bob_id, charlie_id);

    // Insert some posts
    InsertBuilder::into("posts")
        .column("user_id", alice_id)
        .column("title", "Hello World")
        .column("content", "This is my first post!")
        .column("published", true)
        .execute(&conn)
        .unwrap();

    InsertBuilder::into("posts")
        .column("user_id", alice_id)
        .column("title", "Blood is Great")
        .column("content", "I love the effect system.")
        .column("published", true)
        .execute(&conn)
        .unwrap();

    InsertBuilder::into("posts")
        .column("user_id", bob_id)
        .column("title", "Draft Post")
        .column("content", "Work in progress...")
        .column("published", false)
        .execute(&conn)
        .unwrap();

    println!("Inserted posts.\n");

    // Query all users
    println!("=== All Users ===");
    let users = QueryBuilder::table("users")
        .select(&["id", "name", "email", "age", "active"])
        .order_by("name", false)
        .execute(&conn)
        .unwrap();

    for row in users.all() {
        println!("  {} | {} | {} | age: {} | active: {}",
            row.get_int(0).unwrap_or(0),
            row.get_string(1).unwrap_or(&"".to_string()),
            row.get_string(2).unwrap_or(&"".to_string()),
            row.get_int(3).unwrap_or(0),
            row.get_int(4).unwrap_or(0) == 1
        );
    }
    println!();

    // Query active users over 25
    println!("=== Active Users Over 25 ===");
    let active_users = QueryBuilder::table("users")
        .select(&["name", "age"])
        .where_eq("active", 1)
        .where_gt("age", 25)
        .order_by("age", true)
        .execute(&conn)
        .unwrap();

    for row in active_users.all() {
        println!("  {} (age {})",
            row.get_string(0).unwrap_or(&"".to_string()),
            row.get_int(1).unwrap_or(0)
        );
    }
    println!();

    // Query published posts with user join
    println!("=== Published Posts ===");
    let posts = conn.query("
        SELECT p.title, p.content, u.name as author
        FROM posts p
        JOIN users u ON p.user_id = u.id
        WHERE p.published = 1
        ORDER BY p.id
    ").unwrap();

    for row in posts.all() {
        println!("  \"{}\" by {}",
            row.get_string(0).unwrap_or(&"".to_string()),
            row.get_string_by_name("author").unwrap_or(&"".to_string())
        );
        println!("    {}", row.get_string(1).unwrap_or(&"".to_string()));
    }
    println!();

    // Update a user
    println!("=== Updating Bob's age ===");
    let updated = UpdateBuilder::table("users")
        .set("age", 26)
        .where_eq("name", "Bob")
        .execute(&conn)
        .unwrap();
    println!("Updated {} row(s)\n", updated);

    // Transaction example
    println!("=== Transaction Example ===");
    let tx = conn.begin_transaction().unwrap();

    tx.execute("UPDATE users SET age = age + 1 WHERE active = 1").unwrap();
    let count = tx.query("SELECT COUNT(*) FROM users WHERE active = 1").unwrap();
    println!("Active users count: {}", count.first().unwrap().get_int(0).unwrap_or(0));

    tx.commit().unwrap();
    println!("Transaction committed.\n");

    // Final user ages
    println!("=== Final User Ages ===");
    let final_users = conn.query("SELECT name, age FROM users ORDER BY name").unwrap();
    for row in final_users.all() {
        println!("  {}: {}",
            row.get_string(0).unwrap_or(&"".to_string()),
            row.get_int(1).unwrap_or(0)
        );
    }
    println!();

    // Parameterized query example
    println!("=== Parameterized Query ===");
    let result = conn.query_with(
        "SELECT * FROM users WHERE age > ? AND active = ?",
        &[SqlValue::Integer(25), SqlValue::Integer(1)]
    ).unwrap();
    println!("Found {} users over 25 and active.\n", result.len());

    println!("SQLite driver example complete!");
    0
}

// ===========================================================================
// 11. Tests
// ===========================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_open_in_memory() {
        let conn = Connection::open_in_memory().unwrap();
        assert!(conn.is_open());
    }

    #[test]
    fn test_create_table() {
        let conn = Connection::open_in_memory().unwrap();
        let result = conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)");
        assert!(result.is_ok());
    }

    #[test]
    fn test_insert_and_query() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)").unwrap();
        conn.execute("INSERT INTO test (name) VALUES ('Alice')").unwrap();

        let rows = conn.query("SELECT * FROM test").unwrap();
        assert_eq!(rows.len(), 1);
        assert_eq!(rows.first().unwrap().get_string(1), Some(&"Alice".to_string()));
    }

    #[test]
    fn test_parameterized_query() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)").unwrap();
        conn.execute_with(
            "INSERT INTO test (name, age) VALUES (?, ?)",
            &[SqlValue::Text("Bob".to_string()), SqlValue::Integer(30)]
        ).unwrap();

        let rows = conn.query_with(
            "SELECT * FROM test WHERE age > ?",
            &[SqlValue::Integer(25)]
        ).unwrap();
        assert_eq!(rows.len(), 1);
    }

    #[test]
    fn test_query_builder() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, active INTEGER)").unwrap();
        conn.execute("INSERT INTO users (name, active) VALUES ('Alice', 1)").unwrap();
        conn.execute("INSERT INTO users (name, active) VALUES ('Bob', 0)").unwrap();

        let rows = QueryBuilder::table("users")
            .select(&["name"])
            .where_eq("active", 1)
            .execute(&conn)
            .unwrap();

        assert_eq!(rows.len(), 1);
        assert_eq!(rows.first().unwrap().get_string(0), Some(&"Alice".to_string()));
    }

    #[test]
    fn test_insert_builder() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)").unwrap();

        let id = InsertBuilder::into("test")
            .column("name", "Test")
            .execute(&conn)
            .unwrap();

        assert_eq!(id, 1);
    }

    #[test]
    fn test_update_builder() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)").unwrap();
        conn.execute("INSERT INTO test (name) VALUES ('Old')").unwrap();

        let updated = UpdateBuilder::table("test")
            .set("name", "New")
            .where_eq("id", 1)
            .execute(&conn)
            .unwrap();

        assert_eq!(updated, 1);

        let rows = conn.query("SELECT name FROM test WHERE id = 1").unwrap();
        assert_eq!(rows.first().unwrap().get_string(0), Some(&"New".to_string()));
    }

    #[test]
    fn test_transaction_commit() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)").unwrap();

        {
            let tx = conn.begin_transaction().unwrap();
            tx.execute("INSERT INTO test (value) VALUES (42)").unwrap();
            tx.commit().unwrap();
        }

        let rows = conn.query("SELECT * FROM test").unwrap();
        assert_eq!(rows.len(), 1);
    }

    #[test]
    fn test_transaction_rollback() {
        let conn = Connection::open_in_memory().unwrap();
        conn.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)").unwrap();

        {
            let tx = conn.begin_transaction().unwrap();
            tx.execute("INSERT INTO test (value) VALUES (42)").unwrap();
            tx.rollback().unwrap();
        }

        let rows = conn.query("SELECT * FROM test").unwrap();
        assert_eq!(rows.len(), 0);
    }

    #[test]
    fn test_sql_value_types() {
        assert!(SqlValue::Null.is_null());
        assert_eq!(SqlValue::Integer(42).as_int(), Some(42));
        assert_eq!(SqlValue::Real(3.14).as_float(), Some(3.14));
        assert_eq!(SqlValue::Text("hello".to_string()).as_string(), Some(&"hello".to_string()));
    }

    #[test]
    fn test_row_get_by_name() {
        let row = Row {
            columns: vec!["id".to_string(), "name".to_string()],
            values: vec![SqlValue::Integer(1), SqlValue::Text("Alice".to_string())],
        };

        assert_eq!(row.get_int_by_name("id"), Some(1));
        assert_eq!(row.get_string_by_name("name"), Some(&"Alice".to_string()));
        assert!(row.get_by_name("nonexistent").is_none());
    }
}
