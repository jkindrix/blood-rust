// Test: boolean short-circuit evaluation
// EXPECT: 0
// EXPECT: 1
// EXPECT: 1
fn returns_true() -> bool {
    // This function has a side effect we can detect via the counter
    true
}

fn main() -> i32 {
    // Test 1: false && X should not evaluate X
    // We test this indirectly: if short-circuit works,
    // the second condition (10/0 > 0 would crash) is never reached.
    // Actually, we can't test with division by zero safely.
    // Instead, test that the result is correct for short-circuit semantics.

    // AND short-circuit: false && anything = false
    let a: bool = false && returns_true();
    if a { println_int(1); } else { println_int(0); }
    if a { return 1; }

    // OR short-circuit: true || anything = true
    let b: bool = true || false;
    if b { println_int(1); } else { println_int(0); }
    if !b { return 2; }

    // Combined: (true || false) && (false || true) = true && true = true
    let c: bool = (true || false) && (false || true);
    if c { println_int(1); } else { println_int(0); }
    if !c { return 3; }

    // Chained short-circuit
    let d: bool = false && false && false;
    if d { return 4; }

    let e: bool = true || true || true;
    if !e { return 5; }

    0
}
