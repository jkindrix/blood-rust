// Test: nested match on enum with multiple patterns
// EXPECT: 5
// EXPECT: 0
// EXPECT: 99
enum Expr {
    Num(i32),
    Neg(i32),
    Add(i32, i32),
}

fn eval(e: Expr) -> i32 {
    match e {
        Expr::Num(n) => n,
        Expr::Neg(n) => 0 - n,
        Expr::Add(a, b) => a + b,
    }
}

fn main() -> i32 {
    let e1: Expr = Expr::Num(5);
    let e2: Expr = Expr::Neg(0);
    let e3: Expr = Expr::Add(33, 66);

    let r1: i32 = eval(e1);
    let r2: i32 = eval(e2);
    let r3: i32 = eval(e3);

    println_int(r1);
    println_int(r2);
    println_int(r3);

    if r1 != 5 { return 1; }
    if r2 != 0 { return 2; }
    if r3 != 99 { return 3; }
    0
}
