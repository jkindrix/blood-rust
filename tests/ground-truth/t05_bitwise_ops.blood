// Test: bitwise operations (AND, OR, XOR, SHL, SHR)
// EXPECT: 0
// EXPECT: 15
// EXPECT: 10
// EXPECT: 40
// EXPECT: 5
fn main() -> i32 {
    // Bitwise AND
    let a: i32 = 12 & 10;  // 1100 & 1010 = 1000 = 8
    if a != 8 { return 1; }

    // 5 & 3 = 101 & 011 = 001 = 1
    let b: i32 = 5 & 3;
    if b != 1 { return 2; }

    // AND with zero
    let c: i32 = 255 & 0;
    println_int(c); // 0
    if c != 0 { return 3; }

    // Bitwise OR
    let d: i32 = 10 | 5;  // 1010 | 0101 = 1111 = 15
    println_int(d); // 15
    if d != 15 { return 4; }

    // OR with zero (identity)
    let e: i32 = 42 | 0;
    if e != 42 { return 5; }

    // Bitwise XOR
    let f: i32 = 15 ^ 5;  // 1111 ^ 0101 = 1010 = 10
    println_int(f); // 10
    if f != 10 { return 6; }

    // XOR with self = 0
    let g: i32 = 99 ^ 99;
    if g != 0 { return 7; }

    // Shift left
    let h: i32 = 5 << 3;  // 5 * 8 = 40
    println_int(h); // 40
    if h != 40 { return 8; }

    // Shift left by 1 = multiply by 2
    let i: i32 = 7 << 1;
    if i != 14 { return 9; }

    // Shift right
    let j: i32 = 40 >> 3;  // 40 / 8 = 5
    println_int(j); // 5
    if j != 5 { return 10; }

    // Shift right by 1 = divide by 2
    let k: i32 = 100 >> 1;
    if k != 50 { return 11; }

    // Combined bitwise operations
    let mask: i32 = 0xFF;  // 255
    let val: i32 = 0xABCD; // 43981
    let low_byte: i32 = val & mask;
    if low_byte != 0xCD { return 12; }  // 205

    // Set bits with OR, clear with AND
    let flags: i32 = 0;
    let flags2: i32 = flags | 1;   // set bit 0
    let flags3: i32 = flags2 | 4;  // set bit 2
    if flags3 != 5 { return 13; }  // 0101 = 5

    let flags4: i32 = flags3 & (0xFFFFFFFF ^ 1); // clear bit 0
    if flags4 != 4 { return 14; }

    0
}
