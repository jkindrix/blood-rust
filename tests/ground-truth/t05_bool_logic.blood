// Test: complex boolean logic and short-circuit evaluation
// EXPECT: 1
// EXPECT: 0
// EXPECT: 1
// EXPECT: 1
fn all_positive(a: i32, b: i32, c: i32) -> bool {
    a > 0 && b > 0 && c > 0
}

fn any_zero(a: i32, b: i32, c: i32) -> bool {
    a == 0 || b == 0 || c == 0
}

fn xor(a: bool, b: bool) -> bool {
    (a || b) && !(a && b)
}

fn implies(a: bool, b: bool) -> bool {
    !a || b
}

fn main() -> i32 {
    // all_positive
    let ap: bool = all_positive(1, 2, 3);
    if ap { println_int(1); } else { println_int(0); }
    if !ap { return 1; }

    // all_positive with a negative
    let ap2: bool = all_positive(1, -1, 3);
    if ap2 { println_int(1); } else { println_int(0); }
    if ap2 { return 2; }

    // xor: true xor false = true
    let x1: bool = xor(true, false);
    if x1 { println_int(1); } else { println_int(0); }
    if !x1 { return 3; }

    // xor: true xor true = false  ->  implies(true, false) = false
    // Actually let's test implies: true -> true = true
    let imp: bool = implies(true, true);
    if imp { println_int(1); } else { println_int(0); }
    if !imp { return 4; }

    // implies: true -> false = false
    let imp2: bool = implies(true, false);
    if imp2 { return 5; }

    // implies: false -> false = true
    let imp3: bool = implies(false, false);
    if !imp3 { return 6; }

    0
}
