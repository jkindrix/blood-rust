// Test: triple-nested handlers (Error + State + Console)
// EXPECT: 10
effect State<S> {
    op get() -> S;
    op put(s: S) -> ();
}

effect Console {
    op print(msg: i32) -> ();
    op read() -> i32;
}

effect Error<E> {
    op raise(err: E) -> ();
}

deep handler LocalState<S> for State<S> {
    let mut state: S
    return(x) { x }
    op get() { resume(state) }
    op put(s) { state = s; resume(()) }
}

deep handler MockConsole for Console {
    let mut last_printed: i32
    let mut read_value: i32
    return(x) { x }
    op print(msg) { last_printed = msg; resume(()) }
    op read() { resume(read_value) }
}

deep handler TryError<E> for Error<E> {
    let mut error_value: E
    return(x) { x }
    op raise(err) {
        error_value = err;
        ()
    }
}

fn main() -> i32 {
    let result: i32 = with TryError { error_value: 0 } handle {
        with LocalState { state: 0 } handle {
            with MockConsole { last_printed: 0, read_value: 10 } handle {
                let val: i32 = perform Console.read();
                if val < 0 {
                    perform Error.raise(1);
                    0
                } else {
                    perform State.put(val);
                    perform Console.print(val);
                    perform State.get()
                }
            }
        }
    };

    println_int(result);

    if result != 10 { return 1; }
    0
}
