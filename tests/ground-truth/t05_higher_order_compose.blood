// Test: higher-order function composition
// EXPECT: 7
// EXPECT: 50
fn apply_twice(f: fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn apply_n(f: fn(i32) -> i32, x: i32, n: i32) -> i32 {
    let mut result: i32 = x;
    let mut i: i32 = 0;
    while i < n {
        result = f(result);
        i = i + 1;
    }
    result
}

fn add_one(x: i32) -> i32 { x + 1 }
fn double(x: i32) -> i32 { x * 2 }
fn square(x: i32) -> i32 { x * x }

fn main() -> i32 {
    // apply_twice(add_one, 5) = add_one(add_one(5)) = 7
    let r1: i32 = apply_twice(add_one, 5);
    println_int(r1);

    // apply_twice(double, 5) = double(double(5)) = double(10) = 20
    let r2: i32 = apply_twice(double, 5);
    if r2 != 20 { return 1; }

    // apply_n(add_one, 0, 50) = 50
    let r3: i32 = apply_n(add_one, 0, 50);
    println_int(r3);

    // apply_n(double, 1, 10) = 1024
    let r4: i32 = apply_n(double, 1, 10);
    if r4 != 1024 { return 2; }

    // Selecting function dynamically
    let mut total: i32 = 0;
    let mut j: i32 = 0;
    while j < 5 {
        let step: i32 = apply_twice(add_one, j);
        total = total + step;
        j = j + 1;
    }
    // j=0: 2, j=1: 3, j=2: 4, j=3: 5, j=4: 6 => total=20
    if total != 20 { return 3; }

    if r1 != 7 { return 4; }
    if r3 != 50 { return 5; }
    0
}
