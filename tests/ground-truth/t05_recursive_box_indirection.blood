// Test: recursive types using Box<T> for indirection (not infinite size)
// EXPECT: 6
// EXPECT: 3
enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn sum_list(lst: List) -> i32 {
    match lst {
        List::Cons(head, tail) => head + sum_list(*tail),
        List::Nil => 0,
    }
}

fn len_list(lst: List) -> i32 {
    match lst {
        List::Cons(_, tail) => 1 + len_list(*tail),
        List::Nil => 0,
    }
}

fn main() -> i32 {
    // Recursive enum with Box indirection
    let lst: List = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));
    let s: i32 = sum_list(lst);
    println_int(s); // 6
    if s != 6 { return 1; }

    // Create a separate list for len_list test
    let lst2: List = List::Cons(10, Box::new(List::Cons(20, Box::new(List::Cons(30, Box::new(List::Nil))))));
    let n: i32 = len_list(lst2);
    println_int(n); // 3
    if n != 3 { return 2; }

    0
}
